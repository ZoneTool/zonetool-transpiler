// ======================================================================
// Code generated by zonetool-transpiler.
// Do not modify the contents of this file. Any change will be
//   overwritten when re-running the tool.
// 
// "No matter how hard or unlikely, if it's possible, it will be done."
// ======================================================================

#include "stdafx.hpp"
#include "base_types.hpp"
#include "iw4.hpp"

namespace zonetool::linkers::iw4
{
$C8D87EB0090687D323381DFB7A82089C* AllocLoad_$C8D87EB0090687D323381DFB7A82089C();
$C8D87EB0090687D323381DFB7A82089C** AllocLoad_$C8D87EB0090687D323381DFB7A82089CPtr();
$E43DBA5037697D705289B74D87E76C70* AllocLoad_$E43DBA5037697D705289B74D87E76C70();
$E43DBA5037697D705289B74D87E76C70** AllocLoad_$E43DBA5037697D705289B74D87E76C70Ptr();
Bounds* AllocLoad_Bounds();
Bounds** AllocLoad_BoundsPtr();
BrushWrapper* AllocLoad_BrushWrapper();
BrushWrapper** AllocLoad_BrushWrapperPtr();
CardMemory* AllocLoad_CardMemory();
CardMemory** AllocLoad_CardMemoryPtr();
ClipMaterial* AllocLoad_ClipMaterial();
ClipMaterial** AllocLoad_ClipMaterialPtr();
CollisionAabbTree* AllocLoad_CollisionAabbTree();
CollisionAabbTree** AllocLoad_CollisionAabbTreePtr();
CollisionAabbTreeIndex* AllocLoad_CollisionAabbTreeIndex();
CollisionAabbTreeIndex** AllocLoad_CollisionAabbTreeIndexPtr();
CollisionBorder* AllocLoad_CollisionBorder();
CollisionBorder** AllocLoad_CollisionBorderPtr();
CollisionPartition* AllocLoad_CollisionPartition();
CollisionPartition** AllocLoad_CollisionPartitionPtr();
ComPrimaryLight* AllocLoad_ComPrimaryLight();
ComPrimaryLight** AllocLoad_ComPrimaryLightPtr();
ComWorld* AllocLoad_ComWorld();
ComWorld** AllocLoad_ComWorldPtr();
ConditionalScript* AllocLoad_ConditionalScript();
ConditionalScript** AllocLoad_ConditionalScriptPtr();
DObjAnimMat* AllocLoad_DObjAnimMat();
DObjAnimMat** AllocLoad_DObjAnimMatPtr();
DynEntityClient* AllocLoad_DynEntityClient();
DynEntityClient** AllocLoad_DynEntityClientPtr();
DynEntityColl* AllocLoad_DynEntityColl();
DynEntityColl** AllocLoad_DynEntityCollPtr();
DynEntityDef* AllocLoad_DynEntityDef();
DynEntityDef** AllocLoad_DynEntityDefPtr();
DynEntityPose* AllocLoad_DynEntityPose();
DynEntityPose** AllocLoad_DynEntityPosePtr();
EventData* AllocLoad_EventData();
EventData** AllocLoad_EventDataPtr();
ExpressionString* AllocLoad_ExpressionString();
ExpressionString** AllocLoad_ExpressionStringPtr();
ExpressionSupportingData* AllocLoad_ExpressionSupportingData();
ExpressionSupportingData** AllocLoad_ExpressionSupportingDataPtr();
Font_s* AllocLoad_Font_s();
Font_s** AllocLoad_Font_sPtr();
FxEffectDef* AllocLoad_FxEffectDef();
FxEffectDef** AllocLoad_FxEffectDefPtr();
FxEffectDefRef* AllocLoad_FxEffectDefRef();
FxEffectDefRef** AllocLoad_FxEffectDefRefPtr();
FxElemAtlas* AllocLoad_FxElemAtlas();
FxElemAtlas** AllocLoad_FxElemAtlasPtr();
FxElemDef* AllocLoad_FxElemDef();
FxElemDef** AllocLoad_FxElemDefPtr();
FxElemDefVisuals* AllocLoad_FxElemDefVisuals();
FxElemDefVisuals** AllocLoad_FxElemDefVisualsPtr();
FxElemExtendedDefPtr* AllocLoad_FxElemExtendedDefPtr();
FxElemExtendedDefPtr** AllocLoad_FxElemExtendedDefPtrPtr();
FxElemMarkVisuals* AllocLoad_FxElemMarkVisuals();
FxElemMarkVisuals** AllocLoad_FxElemMarkVisualsPtr();
FxElemVec3Range* AllocLoad_FxElemVec3Range();
FxElemVec3Range** AllocLoad_FxElemVec3RangePtr();
FxElemVelStateInFrame* AllocLoad_FxElemVelStateInFrame();
FxElemVelStateInFrame** AllocLoad_FxElemVelStateInFramePtr();
FxElemVelStateSample* AllocLoad_FxElemVelStateSample();
FxElemVelStateSample** AllocLoad_FxElemVelStateSamplePtr();
FxElemVisStateSample* AllocLoad_FxElemVisStateSample();
FxElemVisStateSample** AllocLoad_FxElemVisStateSamplePtr();
FxElemVisualState* AllocLoad_FxElemVisualState();
FxElemVisualState** AllocLoad_FxElemVisualStatePtr();
FxElemVisuals* AllocLoad_FxElemVisuals();
FxElemVisuals** AllocLoad_FxElemVisualsPtr();
FxFloatRange* AllocLoad_FxFloatRange();
FxFloatRange** AllocLoad_FxFloatRangePtr();
FxGlassCrackHeader* AllocLoad_FxGlassCrackHeader();
FxGlassCrackHeader** AllocLoad_FxGlassCrackHeaderPtr();
FxGlassDef* AllocLoad_FxGlassDef();
FxGlassDef** AllocLoad_FxGlassDefPtr();
FxGlassGeometryData* AllocLoad_FxGlassGeometryData();
FxGlassGeometryData** AllocLoad_FxGlassGeometryDataPtr();
FxGlassHoleHeader* AllocLoad_FxGlassHoleHeader();
FxGlassHoleHeader** AllocLoad_FxGlassHoleHeaderPtr();
FxGlassInitPieceState* AllocLoad_FxGlassInitPieceState();
FxGlassInitPieceState** AllocLoad_FxGlassInitPieceStatePtr();
FxGlassPieceDynamics* AllocLoad_FxGlassPieceDynamics();
FxGlassPieceDynamics** AllocLoad_FxGlassPieceDynamicsPtr();
FxGlassPiecePlace* AllocLoad_FxGlassPiecePlace();
FxGlassPiecePlace** AllocLoad_FxGlassPiecePlacePtr();
FxGlassPieceState* AllocLoad_FxGlassPieceState();
FxGlassPieceState** AllocLoad_FxGlassPieceStatePtr();
FxGlassSystem* AllocLoad_FxGlassSystem();
FxGlassSystem** AllocLoad_FxGlassSystemPtr();
FxGlassVertex* AllocLoad_FxGlassVertex();
FxGlassVertex** AllocLoad_FxGlassVertexPtr();
FxIntRange* AllocLoad_FxIntRange();
FxIntRange** AllocLoad_FxIntRangePtr();
FxSparkFountainDef* AllocLoad_FxSparkFountainDef();
FxSparkFountainDef** AllocLoad_FxSparkFountainDefPtr();
FxSpatialFrame* AllocLoad_FxSpatialFrame();
FxSpatialFrame** AllocLoad_FxSpatialFramePtr();
FxSpawnDef* AllocLoad_FxSpawnDef();
FxSpawnDef** AllocLoad_FxSpawnDefPtr();
FxSpawnDefLooping* AllocLoad_FxSpawnDefLooping();
FxSpawnDefLooping** AllocLoad_FxSpawnDefLoopingPtr();
FxSpawnDefOneShot* AllocLoad_FxSpawnDefOneShot();
FxSpawnDefOneShot** AllocLoad_FxSpawnDefOneShotPtr();
FxTrailDef* AllocLoad_FxTrailDef();
FxTrailDef** AllocLoad_FxTrailDefPtr();
FxTrailVertex* AllocLoad_FxTrailVertex();
FxTrailVertex** AllocLoad_FxTrailVertexPtr();
FxWorld* AllocLoad_FxWorld();
FxWorld** AllocLoad_FxWorldPtr();
G_GlassData* AllocLoad_G_GlassData();
G_GlassData** AllocLoad_G_GlassDataPtr();
G_GlassName* AllocLoad_G_GlassName();
G_GlassName** AllocLoad_G_GlassNamePtr();
G_GlassPiece* AllocLoad_G_GlassPiece();
G_GlassPiece** AllocLoad_G_GlassPiecePtr();
GameWorldMp* AllocLoad_GameWorldMp();
GameWorldMp** AllocLoad_GameWorldMpPtr();
GfxColor* AllocLoad_GfxColor();
GfxColor** AllocLoad_GfxColorPtr();
GfxDrawSurf* AllocLoad_GfxDrawSurf();
GfxDrawSurf** AllocLoad_GfxDrawSurfPtr();
GfxImage* AllocLoad_GfxImage();
GfxImage** AllocLoad_GfxImagePtr();
GfxImageLoadDef* AllocLoad_GfxImageLoadDef();
GfxImageLoadDef** AllocLoad_GfxImageLoadDefPtr();
GfxLightDef* AllocLoad_GfxLightDef();
GfxLightDef** AllocLoad_GfxLightDefPtr();
GfxLightImage* AllocLoad_GfxLightImage();
GfxLightImage** AllocLoad_GfxLightImagePtr();
GfxPackedVertex* AllocLoad_GfxPackedVertex();
GfxPackedVertex** AllocLoad_GfxPackedVertexPtr();
GfxPixelShaderLoadDef* AllocLoad_GfxPixelShaderLoadDef();
GfxPixelShaderLoadDef** AllocLoad_GfxPixelShaderLoadDefPtr();
GfxPlacement* AllocLoad_GfxPlacement();
GfxPlacement** AllocLoad_GfxPlacementPtr();
GfxStateBits* AllocLoad_GfxStateBits();
GfxStateBits** AllocLoad_GfxStateBitsPtr();
GfxTexture* AllocLoad_GfxTexture();
GfxTexture** AllocLoad_GfxTexturePtr();
GfxVertexShaderLoadDef* AllocLoad_GfxVertexShaderLoadDef();
GfxVertexShaderLoadDef** AllocLoad_GfxVertexShaderLoadDefPtr();
Glyph* AllocLoad_Glyph();
Glyph** AllocLoad_GlyphPtr();
ItemFloatExpression* AllocLoad_ItemFloatExpression();
ItemFloatExpression** AllocLoad_ItemFloatExpressionPtr();
ItemKeyHandler* AllocLoad_ItemKeyHandler();
ItemKeyHandler** AllocLoad_ItemKeyHandlerPtr();
LbColumnDef* AllocLoad_LbColumnDef();
LbColumnDef** AllocLoad_LbColumnDefPtr();
LeaderboardDef* AllocLoad_LeaderboardDef();
LeaderboardDef** AllocLoad_LeaderboardDefPtr();
LoadedSound* AllocLoad_LoadedSound();
LoadedSound** AllocLoad_LoadedSoundPtr();
LocalizeEntry* AllocLoad_LocalizeEntry();
LocalizeEntry** AllocLoad_LocalizeEntryPtr();
MSSChannelMap* AllocLoad_MSSChannelMap();
MSSChannelMap** AllocLoad_MSSChannelMapPtr();
MSSSpeakerLevels* AllocLoad_MSSSpeakerLevels();
MSSSpeakerLevels** AllocLoad_MSSSpeakerLevelsPtr();
MapEnts* AllocLoad_MapEnts();
MapEnts** AllocLoad_MapEntsPtr();
MapTriggers* AllocLoad_MapTriggers();
MapTriggers** AllocLoad_MapTriggersPtr();
Material* AllocLoad_Material();
Material** AllocLoad_MaterialPtr();
MaterialArgumentCodeConst* AllocLoad_MaterialArgumentCodeConst();
MaterialArgumentCodeConst** AllocLoad_MaterialArgumentCodeConstPtr();
MaterialArgumentDef* AllocLoad_MaterialArgumentDef();
MaterialArgumentDef** AllocLoad_MaterialArgumentDefPtr();
MaterialConstantDef* AllocLoad_MaterialConstantDef();
MaterialConstantDef** AllocLoad_MaterialConstantDefPtr();
MaterialInfo* AllocLoad_MaterialInfo();
MaterialInfo** AllocLoad_MaterialInfoPtr();
MaterialPass* AllocLoad_MaterialPass();
MaterialPass** AllocLoad_MaterialPassPtr();
MaterialPixelShader* AllocLoad_MaterialPixelShader();
MaterialPixelShader** AllocLoad_MaterialPixelShaderPtr();
MaterialPixelShaderProgram* AllocLoad_MaterialPixelShaderProgram();
MaterialPixelShaderProgram** AllocLoad_MaterialPixelShaderProgramPtr();
MaterialShaderArgument* AllocLoad_MaterialShaderArgument();
MaterialShaderArgument** AllocLoad_MaterialShaderArgumentPtr();
MaterialStreamRouting* AllocLoad_MaterialStreamRouting();
MaterialStreamRouting** AllocLoad_MaterialStreamRoutingPtr();
MaterialTechnique* AllocLoad_MaterialTechnique();
MaterialTechnique** AllocLoad_MaterialTechniquePtr();
MaterialTechniqueSet* AllocLoad_MaterialTechniqueSet();
MaterialTechniqueSet** AllocLoad_MaterialTechniqueSetPtr();
MaterialTextureDef* AllocLoad_MaterialTextureDef();
MaterialTextureDef** AllocLoad_MaterialTextureDefPtr();
MaterialTextureDefInfo* AllocLoad_MaterialTextureDefInfo();
MaterialTextureDefInfo** AllocLoad_MaterialTextureDefInfoPtr();
MaterialVertexDeclaration* AllocLoad_MaterialVertexDeclaration();
MaterialVertexDeclaration** AllocLoad_MaterialVertexDeclarationPtr();
MaterialVertexShader* AllocLoad_MaterialVertexShader();
MaterialVertexShader** AllocLoad_MaterialVertexShaderPtr();
MaterialVertexShaderProgram* AllocLoad_MaterialVertexShaderProgram();
MaterialVertexShaderProgram** AllocLoad_MaterialVertexShaderProgramPtr();
MaterialVertexStreamRouting* AllocLoad_MaterialVertexStreamRouting();
MaterialVertexStreamRouting** AllocLoad_MaterialVertexStreamRoutingPtr();
MenuEventHandler* AllocLoad_MenuEventHandler();
MenuEventHandler** AllocLoad_MenuEventHandlerPtr();
MenuEventHandlerSet* AllocLoad_MenuEventHandlerSet();
MenuEventHandlerSet** AllocLoad_MenuEventHandlerSetPtr();
MenuList* AllocLoad_MenuList();
MenuList** AllocLoad_MenuListPtr();
MssSound* AllocLoad_MssSound();
MssSound** AllocLoad_MssSoundPtr();
Operand* AllocLoad_Operand();
Operand** AllocLoad_OperandPtr();
PackedTexCoords* AllocLoad_PackedTexCoords();
PackedTexCoords** AllocLoad_PackedTexCoordsPtr();
PackedUnitVec* AllocLoad_PackedUnitVec();
PackedUnitVec** AllocLoad_PackedUnitVecPtr();
PhysCollmap* AllocLoad_PhysCollmap();
PhysCollmap** AllocLoad_PhysCollmapPtr();
PhysGeomInfo* AllocLoad_PhysGeomInfo();
PhysGeomInfo** AllocLoad_PhysGeomInfoPtr();
PhysMass* AllocLoad_PhysMass();
PhysMass** AllocLoad_PhysMassPtr();
PhysPreset* AllocLoad_PhysPreset();
PhysPreset** AllocLoad_PhysPresetPtr();
Picmip* AllocLoad_Picmip();
Picmip** AllocLoad_PicmipPtr();
RawFile* AllocLoad_RawFile();
RawFile** AllocLoad_RawFilePtr();
SModelAabbNode* AllocLoad_SModelAabbNode();
SModelAabbNode** AllocLoad_SModelAabbNodePtr();
ScriptStringList* AllocLoad_ScriptStringList();
ScriptStringList** AllocLoad_ScriptStringListPtr();
SetLocalVarData* AllocLoad_SetLocalVarData();
SetLocalVarData** AllocLoad_SetLocalVarDataPtr();
SndCurve* AllocLoad_SndCurve();
SndCurve** AllocLoad_SndCurvePtr();
SndDriverGlobals* AllocLoad_SndDriverGlobals();
SndDriverGlobals** AllocLoad_SndDriverGlobalsPtr();
SoundFile* AllocLoad_SoundFile();
SoundFile** AllocLoad_SoundFilePtr();
SoundFileRef* AllocLoad_SoundFileRef();
SoundFileRef** AllocLoad_SoundFileRefPtr();
SpeakerMap* AllocLoad_SpeakerMap();
SpeakerMap** AllocLoad_SpeakerMapPtr();
Stage* AllocLoad_Stage();
Stage** AllocLoad_StagePtr();
Statement_s* AllocLoad_Statement_s();
Statement_s** AllocLoad_Statement_sPtr();
StaticDvar* AllocLoad_StaticDvar();
StaticDvar** AllocLoad_StaticDvarPtr();
StaticDvarList* AllocLoad_StaticDvarList();
StaticDvarList** AllocLoad_StaticDvarListPtr();
StreamFileInfo* AllocLoad_StreamFileInfo();
StreamFileInfo** AllocLoad_StreamFileInfoPtr();
StreamFileName* AllocLoad_StreamFileName();
StreamFileName** AllocLoad_StreamFileNamePtr();
StreamFileNameRaw* AllocLoad_StreamFileNameRaw();
StreamFileNameRaw** AllocLoad_StreamFileNameRawPtr();
StreamedSound* AllocLoad_StreamedSound();
StreamedSound** AllocLoad_StreamedSoundPtr();
StringList* AllocLoad_StringList();
StringList** AllocLoad_StringListPtr();
StringTable* AllocLoad_StringTable();
StringTable** AllocLoad_StringTablePtr();
StringTableCell* AllocLoad_StringTableCell();
StringTableCell** AllocLoad_StringTableCellPtr();
StructuredDataDef* AllocLoad_StructuredDataDef();
StructuredDataDef** AllocLoad_StructuredDataDefPtr();
StructuredDataDefSet* AllocLoad_StructuredDataDefSet();
StructuredDataDefSet** AllocLoad_StructuredDataDefSetPtr();
StructuredDataEnum* AllocLoad_StructuredDataEnum();
StructuredDataEnum** AllocLoad_StructuredDataEnumPtr();
StructuredDataEnumEntry* AllocLoad_StructuredDataEnumEntry();
StructuredDataEnumEntry** AllocLoad_StructuredDataEnumEntryPtr();
StructuredDataEnumedArray* AllocLoad_StructuredDataEnumedArray();
StructuredDataEnumedArray** AllocLoad_StructuredDataEnumedArrayPtr();
StructuredDataIndexedArray* AllocLoad_StructuredDataIndexedArray();
StructuredDataIndexedArray** AllocLoad_StructuredDataIndexedArrayPtr();
StructuredDataStruct* AllocLoad_StructuredDataStruct();
StructuredDataStruct** AllocLoad_StructuredDataStructPtr();
StructuredDataStructProperty* AllocLoad_StructuredDataStructProperty();
StructuredDataStructProperty** AllocLoad_StructuredDataStructPropertyPtr();
StructuredDataType* AllocLoad_StructuredDataType();
StructuredDataType** AllocLoad_StructuredDataTypePtr();
StructuredDataTypeUnion* AllocLoad_StructuredDataTypeUnion();
StructuredDataTypeUnion** AllocLoad_StructuredDataTypeUnionPtr();
TempString* AllocLoad_TempString();
TempString** AllocLoad_TempStringPtr();
TracerDef* AllocLoad_TracerDef();
TracerDef** AllocLoad_TracerDefPtr();
TriIndice* AllocLoad_TriIndice();
TriIndice** AllocLoad_TriIndicePtr();
TriggerHull* AllocLoad_TriggerHull();
TriggerHull** AllocLoad_TriggerHullPtr();
TriggerModel* AllocLoad_TriggerModel();
TriggerModel** AllocLoad_TriggerModelPtr();
TriggerSlab* AllocLoad_TriggerSlab();
TriggerSlab** AllocLoad_TriggerSlabPtr();
UIFunctionList* AllocLoad_UIFunctionList();
UIFunctionList** AllocLoad_UIFunctionListPtr();
WaterWritable* AllocLoad_WaterWritable();
WaterWritable** AllocLoad_WaterWritablePtr();
XAnimDeltaPart* AllocLoad_XAnimDeltaPart();
XAnimDeltaPart** AllocLoad_XAnimDeltaPartPtr();
XAnimDeltaPartQuat* AllocLoad_XAnimDeltaPartQuat();
XAnimDeltaPartQuat** AllocLoad_XAnimDeltaPartQuatPtr();
XAnimDeltaPartQuat2* AllocLoad_XAnimDeltaPartQuat2();
XAnimDeltaPartQuat2** AllocLoad_XAnimDeltaPartQuat2Ptr();
XAnimDeltaPartQuatData* AllocLoad_XAnimDeltaPartQuatData();
XAnimDeltaPartQuatData** AllocLoad_XAnimDeltaPartQuatDataPtr();
XAnimDeltaPartQuatData2* AllocLoad_XAnimDeltaPartQuatData2();
XAnimDeltaPartQuatData2** AllocLoad_XAnimDeltaPartQuatData2Ptr();
XAnimDeltaPartQuatDataFrames* AllocLoad_XAnimDeltaPartQuatDataFrames();
XAnimDeltaPartQuatDataFrames** AllocLoad_XAnimDeltaPartQuatDataFramesPtr();
XAnimDeltaPartQuatDataFrames2* AllocLoad_XAnimDeltaPartQuatDataFrames2();
XAnimDeltaPartQuatDataFrames2** AllocLoad_XAnimDeltaPartQuatDataFrames2Ptr();
XAnimDynamicFrames* AllocLoad_XAnimDynamicFrames();
XAnimDynamicFrames** AllocLoad_XAnimDynamicFramesPtr();
XAnimDynamicIndices* AllocLoad_XAnimDynamicIndices();
XAnimDynamicIndices** AllocLoad_XAnimDynamicIndicesPtr();
XAnimIndices* AllocLoad_XAnimIndices();
XAnimIndices** AllocLoad_XAnimIndicesPtr();
XAnimNotifyInfo* AllocLoad_XAnimNotifyInfo();
XAnimNotifyInfo** AllocLoad_XAnimNotifyInfoPtr();
XAnimPartTrans* AllocLoad_XAnimPartTrans();
XAnimPartTrans** AllocLoad_XAnimPartTransPtr();
XAnimPartTransData* AllocLoad_XAnimPartTransData();
XAnimPartTransData** AllocLoad_XAnimPartTransDataPtr();
XAnimPartTransFrames* AllocLoad_XAnimPartTransFrames();
XAnimPartTransFrames** AllocLoad_XAnimPartTransFramesPtr();
XAnimParts* AllocLoad_XAnimParts();
XAnimParts** AllocLoad_XAnimPartsPtr();
XAsset* AllocLoad_XAsset();
XAsset** AllocLoad_XAssetPtr();
XAssetHeader* AllocLoad_XAssetHeader();
XAssetHeader** AllocLoad_XAssetHeaderPtr();
XAssetList* AllocLoad_XAssetList();
XAssetList** AllocLoad_XAssetListPtr();
XBoneInfo* AllocLoad_XBoneInfo();
XBoneInfo** AllocLoad_XBoneInfoPtr();
XModel* AllocLoad_XModel();
XModel** AllocLoad_XModelPtr();
XModelCollSurf_s* AllocLoad_XModelCollSurf_s();
XModelCollSurf_s** AllocLoad_XModelCollSurf_sPtr();
XModelCollTri_s* AllocLoad_XModelCollTri_s();
XModelCollTri_s** AllocLoad_XModelCollTri_sPtr();
XModelLodInfo* AllocLoad_XModelLodInfo();
XModelLodInfo** AllocLoad_XModelLodInfoPtr();
XModelSurfs* AllocLoad_XModelSurfs();
XModelSurfs** AllocLoad_XModelSurfsPtr();
XRigidVertList* AllocLoad_XRigidVertList();
XRigidVertList** AllocLoad_XRigidVertListPtr();
XString* AllocLoad_XString();
XString** AllocLoad_XStringPtr();
XSurface* AllocLoad_XSurface();
XSurface** AllocLoad_XSurfacePtr();
XSurfaceCollisionAabb* AllocLoad_XSurfaceCollisionAabb();
XSurfaceCollisionAabb** AllocLoad_XSurfaceCollisionAabbPtr();
XSurfaceCollisionLeaf* AllocLoad_XSurfaceCollisionLeaf();
XSurfaceCollisionLeaf** AllocLoad_XSurfaceCollisionLeafPtr();
XSurfaceCollisionNode* AllocLoad_XSurfaceCollisionNode();
XSurfaceCollisionNode** AllocLoad_XSurfaceCollisionNodePtr();
XSurfaceCollisionTree* AllocLoad_XSurfaceCollisionTree();
XSurfaceCollisionTree** AllocLoad_XSurfaceCollisionTreePtr();
XSurfaceVertexInfo* AllocLoad_XSurfaceVertexInfo();
XSurfaceVertexInfo** AllocLoad_XSurfaceVertexInfoPtr();
_AILSOUNDINFO* AllocLoad__AILSOUNDINFO();
_AILSOUNDINFO** AllocLoad__AILSOUNDINFOPtr();
bool* AllocLoad_bool();
bool** AllocLoad_boolPtr();
cLeafBrushNodeChildren_t* AllocLoad_cLeafBrushNodeChildren_t();
cLeafBrushNodeChildren_t** AllocLoad_cLeafBrushNodeChildren_tPtr();
cLeafBrushNodeData_t* AllocLoad_cLeafBrushNodeData_t();
cLeafBrushNodeData_t** AllocLoad_cLeafBrushNodeData_tPtr();
cLeafBrushNodeLeaf_t* AllocLoad_cLeafBrushNodeLeaf_t();
cLeafBrushNodeLeaf_t** AllocLoad_cLeafBrushNodeLeaf_tPtr();
cLeafBrushNode_s* AllocLoad_cLeafBrushNode_s();
cLeafBrushNode_s** AllocLoad_cLeafBrushNode_sPtr();
cLeaf_t* AllocLoad_cLeaf_t();
cLeaf_t** AllocLoad_cLeaf_tPtr();
cNode_t* AllocLoad_cNode_t();
cNode_t** AllocLoad_cNode_tPtr();
cStaticModel_s* AllocLoad_cStaticModel_s();
cStaticModel_s** AllocLoad_cStaticModel_sPtr();
cbrush_t* AllocLoad_cbrush_t();
cbrush_t** AllocLoad_cbrush_tPtr();
cbrushside_t* AllocLoad_cbrushside_t();
cbrushside_t** AllocLoad_cbrushside_tPtr();
char* AllocLoad_char();
char** AllocLoad_charPtr();
char16* AllocLoad_char16();
char16** AllocLoad_char16Ptr();
clipMap_t* AllocLoad_clipMap_t();
clipMap_t** AllocLoad_clipMap_tPtr();
cmodel_t* AllocLoad_cmodel_t();
cmodel_t** AllocLoad_cmodel_tPtr();
columnInfo_s* AllocLoad_columnInfo_s();
columnInfo_s** AllocLoad_columnInfo_sPtr();
complex_s* AllocLoad_complex_s();
complex_s** AllocLoad_complex_sPtr();
const char *DB_ComWorldGetName(XAssetHeader* header);
const char *DB_Font_sGetName(XAssetHeader* header);
const char *DB_FxEffectDefGetName(XAssetHeader* header);
const char *DB_FxWorldGetName(XAssetHeader* header);
const char *DB_GameWorldMpGetName(XAssetHeader* header);
const char *DB_GfxImageGetName(XAssetHeader* header);
const char *DB_GfxLightDefGetName(XAssetHeader* header);
const char *DB_LeaderboardDefGetName(XAssetHeader* header);
const char *DB_LocalizeEntryGetName(XAssetHeader* header);
const char *DB_MapEntsGetName(XAssetHeader* header);
const char *DB_MaterialGetName(XAssetHeader* header);
const char *DB_MaterialPixelShaderGetName(XAssetHeader* header);
const char *DB_MaterialTechniqueSetGetName(XAssetHeader* header);
const char *DB_MaterialVertexDeclarationGetName(XAssetHeader* header);
const char *DB_MaterialVertexShaderGetName(XAssetHeader* header);
const char *DB_MenuListGetName(XAssetHeader* header);
const char *DB_PhysCollmapGetName(XAssetHeader* header);
const char *DB_PhysPresetGetName(XAssetHeader* header);
const char *DB_RawFileGetName(XAssetHeader* header);
const char *DB_SndCurveGetName(XAssetHeader* header);
const char *DB_StringTableGetName(XAssetHeader* header);
const char *DB_StructuredDataDefSetGetName(XAssetHeader* header);
const char *DB_TracerDefGetName(XAssetHeader* header);
const char *DB_XAnimPartsGetName(XAssetHeader* header);
const char *DB_XModelGetName(XAssetHeader* header);
const char *DB_XModelSurfsGetName(XAssetHeader* header);
const char *DB_clipMap_tGetName(XAssetHeader* header);
const char *DB_menuDef_tGetName(XAssetHeader* header);
const char *DB_snd_alias_list_tGetName(XAssetHeader* header);
cplane_s* AllocLoad_cplane_s();
cplane_s** AllocLoad_cplane_sPtr();
double* AllocLoad_double();
double** AllocLoad_doublePtr();
editFieldDef_s* AllocLoad_editFieldDef_s();
editFieldDef_s** AllocLoad_editFieldDef_sPtr();
entryInternalData* AllocLoad_entryInternalData();
entryInternalData** AllocLoad_entryInternalDataPtr();
expressionEntry* AllocLoad_expressionEntry();
expressionEntry** AllocLoad_expressionEntryPtr();
float* AllocLoad_float();
float** AllocLoad_floatPtr();
float16* AllocLoad_float16();
float16** AllocLoad_float16Ptr();
int16* AllocLoad_int16();
int16** AllocLoad_int16Ptr();
int32* AllocLoad_int32();
int32** AllocLoad_int32Ptr();
int64* AllocLoad_int64();
int64** AllocLoad_int64Ptr();
int8* AllocLoad_int8();
int8** AllocLoad_int8Ptr();
itemDefData_t* AllocLoad_itemDefData_t();
itemDefData_t** AllocLoad_itemDefData_tPtr();
itemDef_s* AllocLoad_itemDef_s();
itemDef_s** AllocLoad_itemDef_sPtr();
listBoxDef_s* AllocLoad_listBoxDef_s();
listBoxDef_s** AllocLoad_listBoxDef_sPtr();
menuDef_t* AllocLoad_menuDef_t();
menuDef_t** AllocLoad_menuDef_tPtr();
menuTransition* AllocLoad_menuTransition();
menuTransition** AllocLoad_menuTransitionPtr();
multiDef_s* AllocLoad_multiDef_s();
multiDef_s** AllocLoad_multiDef_sPtr();
newsTickerDef_s* AllocLoad_newsTickerDef_s();
newsTickerDef_s** AllocLoad_newsTickerDef_sPtr();
operandInternalDataUnion* AllocLoad_operandInternalDataUnion();
operandInternalDataUnion** AllocLoad_operandInternalDataUnionPtr();
rectDef_s* AllocLoad_rectDef_s();
rectDef_s** AllocLoad_rectDef_sPtr();
snd_alias_list_t* AllocLoad_snd_alias_list_t();
snd_alias_list_t** AllocLoad_snd_alias_list_tPtr();
snd_alias_t* AllocLoad_snd_alias_t();
snd_alias_t** AllocLoad_snd_alias_tPtr();
textScrollDef_s* AllocLoad_textScrollDef_s();
textScrollDef_s** AllocLoad_textScrollDef_sPtr();
uint16* AllocLoad_uint16();
uint16** AllocLoad_uint16Ptr();
uint32* AllocLoad_uint32();
uint32** AllocLoad_uint32Ptr();
uint64* AllocLoad_uint64();
uint64** AllocLoad_uint64Ptr();
uint8* AllocLoad_uint8();
uint8** AllocLoad_uint8Ptr();
vec1_t* AllocLoad_vec1_t();
vec1_t** AllocLoad_vec1_tPtr();
vec2_t* AllocLoad_vec2_t();
vec2_t** AllocLoad_vec2_tPtr();
vec3_t* AllocLoad_vec3_t();
vec3_t** AllocLoad_vec3_tPtr();
vec4_t* AllocLoad_vec4_t();
vec4_t** AllocLoad_vec4_tPtr();
void Load_$C8D87EB0090687D323381DFB7A82089C(bool atStreamStart);
void Load_$C8D87EB0090687D323381DFB7A82089CArray(bool atStreamStart, int count);
void Load_$C8D87EB0090687D323381DFB7A82089CPtr(bool atStreamStart);
void Load_$C8D87EB0090687D323381DFB7A82089CPtrArray(bool atStreamStart, int count);
void Load_$E43DBA5037697D705289B74D87E76C70(bool atStreamStart);
void Load_$E43DBA5037697D705289B74D87E76C70Array(bool atStreamStart, int count);
void Load_$E43DBA5037697D705289B74D87E76C70Ptr(bool atStreamStart);
void Load_$E43DBA5037697D705289B74D87E76C70PtrArray(bool atStreamStart, int count);
void Load_Bounds(bool atStreamStart);
void Load_BoundsArray(bool atStreamStart, int count);
void Load_BoundsPtr(bool atStreamStart);
void Load_BoundsPtrArray(bool atStreamStart, int count);
void Load_BrushWrapper(bool atStreamStart);
void Load_BrushWrapperArray(bool atStreamStart, int count);
void Load_BrushWrapperPtr(bool atStreamStart);
void Load_BrushWrapperPtrArray(bool atStreamStart, int count);
void Load_CardMemory(bool atStreamStart);
void Load_CardMemoryArray(bool atStreamStart, int count);
void Load_CardMemoryPtr(bool atStreamStart);
void Load_CardMemoryPtrArray(bool atStreamStart, int count);
void Load_ClipMaterial(bool atStreamStart);
void Load_ClipMaterialArray(bool atStreamStart, int count);
void Load_ClipMaterialPtr(bool atStreamStart);
void Load_ClipMaterialPtrArray(bool atStreamStart, int count);
void Load_CollisionAabbTree(bool atStreamStart);
void Load_CollisionAabbTreeArray(bool atStreamStart, int count);
void Load_CollisionAabbTreeIndex(bool atStreamStart);
void Load_CollisionAabbTreeIndexArray(bool atStreamStart, int count);
void Load_CollisionAabbTreeIndexPtr(bool atStreamStart);
void Load_CollisionAabbTreeIndexPtrArray(bool atStreamStart, int count);
void Load_CollisionAabbTreePtr(bool atStreamStart);
void Load_CollisionAabbTreePtrArray(bool atStreamStart, int count);
void Load_CollisionBorder(bool atStreamStart);
void Load_CollisionBorderArray(bool atStreamStart, int count);
void Load_CollisionBorderPtr(bool atStreamStart);
void Load_CollisionBorderPtrArray(bool atStreamStart, int count);
void Load_CollisionPartition(bool atStreamStart);
void Load_CollisionPartitionArray(bool atStreamStart, int count);
void Load_CollisionPartitionPtr(bool atStreamStart);
void Load_CollisionPartitionPtrArray(bool atStreamStart, int count);
void Load_ComPrimaryLight(bool atStreamStart);
void Load_ComPrimaryLightArray(bool atStreamStart, int count);
void Load_ComPrimaryLightPtr(bool atStreamStart);
void Load_ComPrimaryLightPtrArray(bool atStreamStart, int count);
void Load_ComWorld(bool atStreamStart);
void Load_ComWorldArray(bool atStreamStart, int count);
void Load_ComWorldAsset(ComWorld** asset);
void Load_ComWorldPtr(bool atStreamStart);
void Load_ComWorldPtrArray(bool atStreamStart, int count);
void Load_ConditionalScript(bool atStreamStart);
void Load_ConditionalScriptArray(bool atStreamStart, int count);
void Load_ConditionalScriptPtr(bool atStreamStart);
void Load_ConditionalScriptPtrArray(bool atStreamStart, int count);
void Load_DObjAnimMat(bool atStreamStart);
void Load_DObjAnimMatArray(bool atStreamStart, int count);
void Load_DObjAnimMatPtr(bool atStreamStart);
void Load_DObjAnimMatPtrArray(bool atStreamStart, int count);
void Load_DynEntityClient(bool atStreamStart);
void Load_DynEntityClientArray(bool atStreamStart, int count);
void Load_DynEntityClientPtr(bool atStreamStart);
void Load_DynEntityClientPtrArray(bool atStreamStart, int count);
void Load_DynEntityColl(bool atStreamStart);
void Load_DynEntityCollArray(bool atStreamStart, int count);
void Load_DynEntityCollPtr(bool atStreamStart);
void Load_DynEntityCollPtrArray(bool atStreamStart, int count);
void Load_DynEntityDef(bool atStreamStart);
void Load_DynEntityDefArray(bool atStreamStart, int count);
void Load_DynEntityDefPtr(bool atStreamStart);
void Load_DynEntityDefPtrArray(bool atStreamStart, int count);
void Load_DynEntityPose(bool atStreamStart);
void Load_DynEntityPoseArray(bool atStreamStart, int count);
void Load_DynEntityPosePtr(bool atStreamStart);
void Load_DynEntityPosePtrArray(bool atStreamStart, int count);
void Load_EventData(bool atStreamStart);
void Load_EventDataArray(bool atStreamStart, int count);
void Load_EventDataPtr(bool atStreamStart);
void Load_EventDataPtrArray(bool atStreamStart, int count);
void Load_ExpressionString(bool atStreamStart);
void Load_ExpressionStringArray(bool atStreamStart, int count);
void Load_ExpressionStringPtr(bool atStreamStart);
void Load_ExpressionStringPtrArray(bool atStreamStart, int count);
void Load_ExpressionSupportingData(bool atStreamStart);
void Load_ExpressionSupportingDataArray(bool atStreamStart, int count);
void Load_ExpressionSupportingDataPtr(bool atStreamStart);
void Load_ExpressionSupportingDataPtrArray(bool atStreamStart, int count);
void Load_Font_s(bool atStreamStart);
void Load_Font_sArray(bool atStreamStart, int count);
void Load_Font_sAsset(Font_s** asset);
void Load_Font_sPtr(bool atStreamStart);
void Load_Font_sPtrArray(bool atStreamStart, int count);
void Load_FxEffectDef(bool atStreamStart);
void Load_FxEffectDefArray(bool atStreamStart, int count);
void Load_FxEffectDefAsset(FxEffectDef** asset);
void Load_FxEffectDefPtr(bool atStreamStart);
void Load_FxEffectDefPtrArray(bool atStreamStart, int count);
void Load_FxEffectDefRef(bool atStreamStart);
void Load_FxEffectDefRefArray(bool atStreamStart, int count);
void Load_FxEffectDefRefPtr(bool atStreamStart);
void Load_FxEffectDefRefPtrArray(bool atStreamStart, int count);
void Load_FxElemAtlas(bool atStreamStart);
void Load_FxElemAtlasArray(bool atStreamStart, int count);
void Load_FxElemAtlasPtr(bool atStreamStart);
void Load_FxElemAtlasPtrArray(bool atStreamStart, int count);
void Load_FxElemDef(bool atStreamStart);
void Load_FxElemDefArray(bool atStreamStart, int count);
void Load_FxElemDefPtr(bool atStreamStart);
void Load_FxElemDefPtrArray(bool atStreamStart, int count);
void Load_FxElemDefVisuals(bool atStreamStart);
void Load_FxElemDefVisualsArray(bool atStreamStart, int count);
void Load_FxElemDefVisualsPtr(bool atStreamStart);
void Load_FxElemDefVisualsPtrArray(bool atStreamStart, int count);
void Load_FxElemExtendedDefPtr(bool atStreamStart);
void Load_FxElemExtendedDefPtrArray(bool atStreamStart, int count);
void Load_FxElemExtendedDefPtrPtr(bool atStreamStart);
void Load_FxElemExtendedDefPtrPtrArray(bool atStreamStart, int count);
void Load_FxElemMarkVisuals(bool atStreamStart);
void Load_FxElemMarkVisualsArray(bool atStreamStart, int count);
void Load_FxElemMarkVisualsPtr(bool atStreamStart);
void Load_FxElemMarkVisualsPtrArray(bool atStreamStart, int count);
void Load_FxElemVec3Range(bool atStreamStart);
void Load_FxElemVec3RangeArray(bool atStreamStart, int count);
void Load_FxElemVec3RangePtr(bool atStreamStart);
void Load_FxElemVec3RangePtrArray(bool atStreamStart, int count);
void Load_FxElemVelStateInFrame(bool atStreamStart);
void Load_FxElemVelStateInFrameArray(bool atStreamStart, int count);
void Load_FxElemVelStateInFramePtr(bool atStreamStart);
void Load_FxElemVelStateInFramePtrArray(bool atStreamStart, int count);
void Load_FxElemVelStateSample(bool atStreamStart);
void Load_FxElemVelStateSampleArray(bool atStreamStart, int count);
void Load_FxElemVelStateSamplePtr(bool atStreamStart);
void Load_FxElemVelStateSamplePtrArray(bool atStreamStart, int count);
void Load_FxElemVisStateSample(bool atStreamStart);
void Load_FxElemVisStateSampleArray(bool atStreamStart, int count);
void Load_FxElemVisStateSamplePtr(bool atStreamStart);
void Load_FxElemVisStateSamplePtrArray(bool atStreamStart, int count);
void Load_FxElemVisualState(bool atStreamStart);
void Load_FxElemVisualStateArray(bool atStreamStart, int count);
void Load_FxElemVisualStatePtr(bool atStreamStart);
void Load_FxElemVisualStatePtrArray(bool atStreamStart, int count);
void Load_FxElemVisuals(bool atStreamStart);
void Load_FxElemVisualsArray(bool atStreamStart, int count);
void Load_FxElemVisualsPtr(bool atStreamStart);
void Load_FxElemVisualsPtrArray(bool atStreamStart, int count);
void Load_FxFloatRange(bool atStreamStart);
void Load_FxFloatRangeArray(bool atStreamStart, int count);
void Load_FxFloatRangePtr(bool atStreamStart);
void Load_FxFloatRangePtrArray(bool atStreamStart, int count);
void Load_FxGlassCrackHeader(bool atStreamStart);
void Load_FxGlassCrackHeaderArray(bool atStreamStart, int count);
void Load_FxGlassCrackHeaderPtr(bool atStreamStart);
void Load_FxGlassCrackHeaderPtrArray(bool atStreamStart, int count);
void Load_FxGlassDef(bool atStreamStart);
void Load_FxGlassDefArray(bool atStreamStart, int count);
void Load_FxGlassDefPtr(bool atStreamStart);
void Load_FxGlassDefPtrArray(bool atStreamStart, int count);
void Load_FxGlassGeometryData(bool atStreamStart);
void Load_FxGlassGeometryDataArray(bool atStreamStart, int count);
void Load_FxGlassGeometryDataPtr(bool atStreamStart);
void Load_FxGlassGeometryDataPtrArray(bool atStreamStart, int count);
void Load_FxGlassHoleHeader(bool atStreamStart);
void Load_FxGlassHoleHeaderArray(bool atStreamStart, int count);
void Load_FxGlassHoleHeaderPtr(bool atStreamStart);
void Load_FxGlassHoleHeaderPtrArray(bool atStreamStart, int count);
void Load_FxGlassInitPieceState(bool atStreamStart);
void Load_FxGlassInitPieceStateArray(bool atStreamStart, int count);
void Load_FxGlassInitPieceStatePtr(bool atStreamStart);
void Load_FxGlassInitPieceStatePtrArray(bool atStreamStart, int count);
void Load_FxGlassPieceDynamics(bool atStreamStart);
void Load_FxGlassPieceDynamicsArray(bool atStreamStart, int count);
void Load_FxGlassPieceDynamicsPtr(bool atStreamStart);
void Load_FxGlassPieceDynamicsPtrArray(bool atStreamStart, int count);
void Load_FxGlassPiecePlace(bool atStreamStart);
void Load_FxGlassPiecePlaceArray(bool atStreamStart, int count);
void Load_FxGlassPiecePlacePtr(bool atStreamStart);
void Load_FxGlassPiecePlacePtrArray(bool atStreamStart, int count);
void Load_FxGlassPieceState(bool atStreamStart);
void Load_FxGlassPieceStateArray(bool atStreamStart, int count);
void Load_FxGlassPieceStatePtr(bool atStreamStart);
void Load_FxGlassPieceStatePtrArray(bool atStreamStart, int count);
void Load_FxGlassSystem(bool atStreamStart);
void Load_FxGlassSystemArray(bool atStreamStart, int count);
void Load_FxGlassSystemPtr(bool atStreamStart);
void Load_FxGlassSystemPtrArray(bool atStreamStart, int count);
void Load_FxGlassVertex(bool atStreamStart);
void Load_FxGlassVertexArray(bool atStreamStart, int count);
void Load_FxGlassVertexPtr(bool atStreamStart);
void Load_FxGlassVertexPtrArray(bool atStreamStart, int count);
void Load_FxIntRange(bool atStreamStart);
void Load_FxIntRangeArray(bool atStreamStart, int count);
void Load_FxIntRangePtr(bool atStreamStart);
void Load_FxIntRangePtrArray(bool atStreamStart, int count);
void Load_FxSparkFountainDef(bool atStreamStart);
void Load_FxSparkFountainDefArray(bool atStreamStart, int count);
void Load_FxSparkFountainDefPtr(bool atStreamStart);
void Load_FxSparkFountainDefPtrArray(bool atStreamStart, int count);
void Load_FxSpatialFrame(bool atStreamStart);
void Load_FxSpatialFrameArray(bool atStreamStart, int count);
void Load_FxSpatialFramePtr(bool atStreamStart);
void Load_FxSpatialFramePtrArray(bool atStreamStart, int count);
void Load_FxSpawnDef(bool atStreamStart);
void Load_FxSpawnDefArray(bool atStreamStart, int count);
void Load_FxSpawnDefLooping(bool atStreamStart);
void Load_FxSpawnDefLoopingArray(bool atStreamStart, int count);
void Load_FxSpawnDefLoopingPtr(bool atStreamStart);
void Load_FxSpawnDefLoopingPtrArray(bool atStreamStart, int count);
void Load_FxSpawnDefOneShot(bool atStreamStart);
void Load_FxSpawnDefOneShotArray(bool atStreamStart, int count);
void Load_FxSpawnDefOneShotPtr(bool atStreamStart);
void Load_FxSpawnDefOneShotPtrArray(bool atStreamStart, int count);
void Load_FxSpawnDefPtr(bool atStreamStart);
void Load_FxSpawnDefPtrArray(bool atStreamStart, int count);
void Load_FxTrailDef(bool atStreamStart);
void Load_FxTrailDefArray(bool atStreamStart, int count);
void Load_FxTrailDefPtr(bool atStreamStart);
void Load_FxTrailDefPtrArray(bool atStreamStart, int count);
void Load_FxTrailVertex(bool atStreamStart);
void Load_FxTrailVertexArray(bool atStreamStart, int count);
void Load_FxTrailVertexPtr(bool atStreamStart);
void Load_FxTrailVertexPtrArray(bool atStreamStart, int count);
void Load_FxWorld(bool atStreamStart);
void Load_FxWorldArray(bool atStreamStart, int count);
void Load_FxWorldAsset(FxWorld** asset);
void Load_FxWorldPtr(bool atStreamStart);
void Load_FxWorldPtrArray(bool atStreamStart, int count);
void Load_G_GlassData(bool atStreamStart);
void Load_G_GlassDataArray(bool atStreamStart, int count);
void Load_G_GlassDataPtr(bool atStreamStart);
void Load_G_GlassDataPtrArray(bool atStreamStart, int count);
void Load_G_GlassName(bool atStreamStart);
void Load_G_GlassNameArray(bool atStreamStart, int count);
void Load_G_GlassNamePtr(bool atStreamStart);
void Load_G_GlassNamePtrArray(bool atStreamStart, int count);
void Load_G_GlassPiece(bool atStreamStart);
void Load_G_GlassPieceArray(bool atStreamStart, int count);
void Load_G_GlassPiecePtr(bool atStreamStart);
void Load_G_GlassPiecePtrArray(bool atStreamStart, int count);
void Load_GameWorldMp(bool atStreamStart);
void Load_GameWorldMpArray(bool atStreamStart, int count);
void Load_GameWorldMpAsset(GameWorldMp** asset);
void Load_GameWorldMpPtr(bool atStreamStart);
void Load_GameWorldMpPtrArray(bool atStreamStart, int count);
void Load_GfxColor(bool atStreamStart);
void Load_GfxColorArray(bool atStreamStart, int count);
void Load_GfxColorPtr(bool atStreamStart);
void Load_GfxColorPtrArray(bool atStreamStart, int count);
void Load_GfxDrawSurf(bool atStreamStart);
void Load_GfxDrawSurfArray(bool atStreamStart, int count);
void Load_GfxDrawSurfPtr(bool atStreamStart);
void Load_GfxDrawSurfPtrArray(bool atStreamStart, int count);
void Load_GfxImage(bool atStreamStart);
void Load_GfxImageArray(bool atStreamStart, int count);
void Load_GfxImageAsset(GfxImage** asset);
void Load_GfxImageLoadDef(bool atStreamStart);
void Load_GfxImageLoadDefArray(bool atStreamStart, int count);
void Load_GfxImageLoadDefPtr(bool atStreamStart);
void Load_GfxImageLoadDefPtrArray(bool atStreamStart, int count);
void Load_GfxImagePtr(bool atStreamStart);
void Load_GfxImagePtrArray(bool atStreamStart, int count);
void Load_GfxLightDef(bool atStreamStart);
void Load_GfxLightDefArray(bool atStreamStart, int count);
void Load_GfxLightDefAsset(GfxLightDef** asset);
void Load_GfxLightDefPtr(bool atStreamStart);
void Load_GfxLightDefPtrArray(bool atStreamStart, int count);
void Load_GfxLightImage(bool atStreamStart);
void Load_GfxLightImageArray(bool atStreamStart, int count);
void Load_GfxLightImagePtr(bool atStreamStart);
void Load_GfxLightImagePtrArray(bool atStreamStart, int count);
void Load_GfxPackedVertex(bool atStreamStart);
void Load_GfxPackedVertexArray(bool atStreamStart, int count);
void Load_GfxPackedVertexPtr(bool atStreamStart);
void Load_GfxPackedVertexPtrArray(bool atStreamStart, int count);
void Load_GfxPixelShaderLoadDef(bool atStreamStart);
void Load_GfxPixelShaderLoadDefArray(bool atStreamStart, int count);
void Load_GfxPixelShaderLoadDefPtr(bool atStreamStart);
void Load_GfxPixelShaderLoadDefPtrArray(bool atStreamStart, int count);
void Load_GfxPlacement(bool atStreamStart);
void Load_GfxPlacementArray(bool atStreamStart, int count);
void Load_GfxPlacementPtr(bool atStreamStart);
void Load_GfxPlacementPtrArray(bool atStreamStart, int count);
void Load_GfxStateBits(bool atStreamStart);
void Load_GfxStateBitsArray(bool atStreamStart, int count);
void Load_GfxStateBitsPtr(bool atStreamStart);
void Load_GfxStateBitsPtrArray(bool atStreamStart, int count);
void Load_GfxTexture(bool atStreamStart);
void Load_GfxTextureArray(bool atStreamStart, int count);
void Load_GfxTexturePtr(bool atStreamStart);
void Load_GfxTexturePtrArray(bool atStreamStart, int count);
void Load_GfxVertexShaderLoadDef(bool atStreamStart);
void Load_GfxVertexShaderLoadDefArray(bool atStreamStart, int count);
void Load_GfxVertexShaderLoadDefPtr(bool atStreamStart);
void Load_GfxVertexShaderLoadDefPtrArray(bool atStreamStart, int count);
void Load_Glyph(bool atStreamStart);
void Load_GlyphArray(bool atStreamStart, int count);
void Load_GlyphPtr(bool atStreamStart);
void Load_GlyphPtrArray(bool atStreamStart, int count);
void Load_ItemFloatExpression(bool atStreamStart);
void Load_ItemFloatExpressionArray(bool atStreamStart, int count);
void Load_ItemFloatExpressionPtr(bool atStreamStart);
void Load_ItemFloatExpressionPtrArray(bool atStreamStart, int count);
void Load_ItemKeyHandler(bool atStreamStart);
void Load_ItemKeyHandlerArray(bool atStreamStart, int count);
void Load_ItemKeyHandlerPtr(bool atStreamStart);
void Load_ItemKeyHandlerPtrArray(bool atStreamStart, int count);
void Load_LbColumnDef(bool atStreamStart);
void Load_LbColumnDefArray(bool atStreamStart, int count);
void Load_LbColumnDefPtr(bool atStreamStart);
void Load_LbColumnDefPtrArray(bool atStreamStart, int count);
void Load_LeaderboardDef(bool atStreamStart);
void Load_LeaderboardDefArray(bool atStreamStart, int count);
void Load_LeaderboardDefAsset(LeaderboardDef** asset);
void Load_LeaderboardDefPtr(bool atStreamStart);
void Load_LeaderboardDefPtrArray(bool atStreamStart, int count);
void Load_LoadedSound(bool atStreamStart);
void Load_LoadedSoundArray(bool atStreamStart, int count);
void Load_LoadedSoundPtr(bool atStreamStart);
void Load_LoadedSoundPtrArray(bool atStreamStart, int count);
void Load_LocalizeEntry(bool atStreamStart);
void Load_LocalizeEntryArray(bool atStreamStart, int count);
void Load_LocalizeEntryAsset(LocalizeEntry** asset);
void Load_LocalizeEntryPtr(bool atStreamStart);
void Load_LocalizeEntryPtrArray(bool atStreamStart, int count);
void Load_MSSChannelMap(bool atStreamStart);
void Load_MSSChannelMapArray(bool atStreamStart, int count);
void Load_MSSChannelMapPtr(bool atStreamStart);
void Load_MSSChannelMapPtrArray(bool atStreamStart, int count);
void Load_MSSSpeakerLevels(bool atStreamStart);
void Load_MSSSpeakerLevelsArray(bool atStreamStart, int count);
void Load_MSSSpeakerLevelsPtr(bool atStreamStart);
void Load_MSSSpeakerLevelsPtrArray(bool atStreamStart, int count);
void Load_MapEnts(bool atStreamStart);
void Load_MapEntsArray(bool atStreamStart, int count);
void Load_MapEntsAsset(MapEnts** asset);
void Load_MapEntsPtr(bool atStreamStart);
void Load_MapEntsPtrArray(bool atStreamStart, int count);
void Load_MapTriggers(bool atStreamStart);
void Load_MapTriggersArray(bool atStreamStart, int count);
void Load_MapTriggersPtr(bool atStreamStart);
void Load_MapTriggersPtrArray(bool atStreamStart, int count);
void Load_Material(bool atStreamStart);
void Load_MaterialArgumentCodeConst(bool atStreamStart);
void Load_MaterialArgumentCodeConstArray(bool atStreamStart, int count);
void Load_MaterialArgumentCodeConstPtr(bool atStreamStart);
void Load_MaterialArgumentCodeConstPtrArray(bool atStreamStart, int count);
void Load_MaterialArgumentDef(bool atStreamStart);
void Load_MaterialArgumentDefArray(bool atStreamStart, int count);
void Load_MaterialArgumentDefPtr(bool atStreamStart);
void Load_MaterialArgumentDefPtrArray(bool atStreamStart, int count);
void Load_MaterialArray(bool atStreamStart, int count);
void Load_MaterialAsset(Material** asset);
void Load_MaterialConstantDef(bool atStreamStart);
void Load_MaterialConstantDefArray(bool atStreamStart, int count);
void Load_MaterialConstantDefPtr(bool atStreamStart);
void Load_MaterialConstantDefPtrArray(bool atStreamStart, int count);
void Load_MaterialInfo(bool atStreamStart);
void Load_MaterialInfoArray(bool atStreamStart, int count);
void Load_MaterialInfoPtr(bool atStreamStart);
void Load_MaterialInfoPtrArray(bool atStreamStart, int count);
void Load_MaterialPass(bool atStreamStart);
void Load_MaterialPassArray(bool atStreamStart, int count);
void Load_MaterialPassPtr(bool atStreamStart);
void Load_MaterialPassPtrArray(bool atStreamStart, int count);
void Load_MaterialPixelShader(bool atStreamStart);
void Load_MaterialPixelShaderArray(bool atStreamStart, int count);
void Load_MaterialPixelShaderAsset(MaterialPixelShader** asset);
void Load_MaterialPixelShaderProgram(bool atStreamStart);
void Load_MaterialPixelShaderProgramArray(bool atStreamStart, int count);
void Load_MaterialPixelShaderProgramPtr(bool atStreamStart);
void Load_MaterialPixelShaderProgramPtrArray(bool atStreamStart, int count);
void Load_MaterialPixelShaderPtr(bool atStreamStart);
void Load_MaterialPixelShaderPtrArray(bool atStreamStart, int count);
void Load_MaterialPtr(bool atStreamStart);
void Load_MaterialPtrArray(bool atStreamStart, int count);
void Load_MaterialShaderArgument(bool atStreamStart);
void Load_MaterialShaderArgumentArray(bool atStreamStart, int count);
void Load_MaterialShaderArgumentPtr(bool atStreamStart);
void Load_MaterialShaderArgumentPtrArray(bool atStreamStart, int count);
void Load_MaterialStreamRouting(bool atStreamStart);
void Load_MaterialStreamRoutingArray(bool atStreamStart, int count);
void Load_MaterialStreamRoutingPtr(bool atStreamStart);
void Load_MaterialStreamRoutingPtrArray(bool atStreamStart, int count);
void Load_MaterialTechnique(bool atStreamStart);
void Load_MaterialTechniqueArray(bool atStreamStart, int count);
void Load_MaterialTechniquePtr(bool atStreamStart);
void Load_MaterialTechniquePtrArray(bool atStreamStart, int count);
void Load_MaterialTechniqueSet(bool atStreamStart);
void Load_MaterialTechniqueSetArray(bool atStreamStart, int count);
void Load_MaterialTechniqueSetAsset(MaterialTechniqueSet** asset);
void Load_MaterialTechniqueSetPtr(bool atStreamStart);
void Load_MaterialTechniqueSetPtrArray(bool atStreamStart, int count);
void Load_MaterialTextureDef(bool atStreamStart);
void Load_MaterialTextureDefArray(bool atStreamStart, int count);
void Load_MaterialTextureDefInfo(bool atStreamStart);
void Load_MaterialTextureDefInfoArray(bool atStreamStart, int count);
void Load_MaterialTextureDefInfoPtr(bool atStreamStart);
void Load_MaterialTextureDefInfoPtrArray(bool atStreamStart, int count);
void Load_MaterialTextureDefPtr(bool atStreamStart);
void Load_MaterialTextureDefPtrArray(bool atStreamStart, int count);
void Load_MaterialVertexDeclaration(bool atStreamStart);
void Load_MaterialVertexDeclarationArray(bool atStreamStart, int count);
void Load_MaterialVertexDeclarationAsset(MaterialVertexDeclaration** asset);
void Load_MaterialVertexDeclarationPtr(bool atStreamStart);
void Load_MaterialVertexDeclarationPtrArray(bool atStreamStart, int count);
void Load_MaterialVertexShader(bool atStreamStart);
void Load_MaterialVertexShaderArray(bool atStreamStart, int count);
void Load_MaterialVertexShaderAsset(MaterialVertexShader** asset);
void Load_MaterialVertexShaderProgram(bool atStreamStart);
void Load_MaterialVertexShaderProgramArray(bool atStreamStart, int count);
void Load_MaterialVertexShaderProgramPtr(bool atStreamStart);
void Load_MaterialVertexShaderProgramPtrArray(bool atStreamStart, int count);
void Load_MaterialVertexShaderPtr(bool atStreamStart);
void Load_MaterialVertexShaderPtrArray(bool atStreamStart, int count);
void Load_MaterialVertexStreamRouting(bool atStreamStart);
void Load_MaterialVertexStreamRoutingArray(bool atStreamStart, int count);
void Load_MaterialVertexStreamRoutingPtr(bool atStreamStart);
void Load_MaterialVertexStreamRoutingPtrArray(bool atStreamStart, int count);
void Load_MenuEventHandler(bool atStreamStart);
void Load_MenuEventHandlerArray(bool atStreamStart, int count);
void Load_MenuEventHandlerPtr(bool atStreamStart);
void Load_MenuEventHandlerPtrArray(bool atStreamStart, int count);
void Load_MenuEventHandlerSet(bool atStreamStart);
void Load_MenuEventHandlerSetArray(bool atStreamStart, int count);
void Load_MenuEventHandlerSetPtr(bool atStreamStart);
void Load_MenuEventHandlerSetPtrArray(bool atStreamStart, int count);
void Load_MenuList(bool atStreamStart);
void Load_MenuListArray(bool atStreamStart, int count);
void Load_MenuListAsset(MenuList** asset);
void Load_MenuListPtr(bool atStreamStart);
void Load_MenuListPtrArray(bool atStreamStart, int count);
void Load_MssSound(bool atStreamStart);
void Load_MssSoundArray(bool atStreamStart, int count);
void Load_MssSoundPtr(bool atStreamStart);
void Load_MssSoundPtrArray(bool atStreamStart, int count);
void Load_Operand(bool atStreamStart);
void Load_OperandArray(bool atStreamStart, int count);
void Load_OperandPtr(bool atStreamStart);
void Load_OperandPtrArray(bool atStreamStart, int count);
void Load_PackedTexCoords(bool atStreamStart);
void Load_PackedTexCoordsArray(bool atStreamStart, int count);
void Load_PackedTexCoordsPtr(bool atStreamStart);
void Load_PackedTexCoordsPtrArray(bool atStreamStart, int count);
void Load_PackedUnitVec(bool atStreamStart);
void Load_PackedUnitVecArray(bool atStreamStart, int count);
void Load_PackedUnitVecPtr(bool atStreamStart);
void Load_PackedUnitVecPtrArray(bool atStreamStart, int count);
void Load_PhysCollmap(bool atStreamStart);
void Load_PhysCollmapArray(bool atStreamStart, int count);
void Load_PhysCollmapAsset(PhysCollmap** asset);
void Load_PhysCollmapPtr(bool atStreamStart);
void Load_PhysCollmapPtrArray(bool atStreamStart, int count);
void Load_PhysGeomInfo(bool atStreamStart);
void Load_PhysGeomInfoArray(bool atStreamStart, int count);
void Load_PhysGeomInfoPtr(bool atStreamStart);
void Load_PhysGeomInfoPtrArray(bool atStreamStart, int count);
void Load_PhysMass(bool atStreamStart);
void Load_PhysMassArray(bool atStreamStart, int count);
void Load_PhysMassPtr(bool atStreamStart);
void Load_PhysMassPtrArray(bool atStreamStart, int count);
void Load_PhysPreset(bool atStreamStart);
void Load_PhysPresetArray(bool atStreamStart, int count);
void Load_PhysPresetAsset(PhysPreset** asset);
void Load_PhysPresetPtr(bool atStreamStart);
void Load_PhysPresetPtrArray(bool atStreamStart, int count);
void Load_Picmip(bool atStreamStart);
void Load_PicmipArray(bool atStreamStart, int count);
void Load_PicmipPtr(bool atStreamStart);
void Load_PicmipPtrArray(bool atStreamStart, int count);
void Load_RawFile(bool atStreamStart);
void Load_RawFileArray(bool atStreamStart, int count);
void Load_RawFileAsset(RawFile** asset);
void Load_RawFilePtr(bool atStreamStart);
void Load_RawFilePtrArray(bool atStreamStart, int count);
void Load_SModelAabbNode(bool atStreamStart);
void Load_SModelAabbNodeArray(bool atStreamStart, int count);
void Load_SModelAabbNodePtr(bool atStreamStart);
void Load_SModelAabbNodePtrArray(bool atStreamStart, int count);
void Load_ScriptStringList(bool atStreamStart);
void Load_ScriptStringListArray(bool atStreamStart, int count);
void Load_ScriptStringListPtr(bool atStreamStart);
void Load_ScriptStringListPtrArray(bool atStreamStart, int count);
void Load_SetLocalVarData(bool atStreamStart);
void Load_SetLocalVarDataArray(bool atStreamStart, int count);
void Load_SetLocalVarDataPtr(bool atStreamStart);
void Load_SetLocalVarDataPtrArray(bool atStreamStart, int count);
void Load_SndCurve(bool atStreamStart);
void Load_SndCurveArray(bool atStreamStart, int count);
void Load_SndCurveAsset(SndCurve** asset);
void Load_SndCurvePtr(bool atStreamStart);
void Load_SndCurvePtrArray(bool atStreamStart, int count);
void Load_SndDriverGlobals(bool atStreamStart);
void Load_SndDriverGlobalsArray(bool atStreamStart, int count);
void Load_SndDriverGlobalsPtr(bool atStreamStart);
void Load_SndDriverGlobalsPtrArray(bool atStreamStart, int count);
void Load_SoundFile(bool atStreamStart);
void Load_SoundFileArray(bool atStreamStart, int count);
void Load_SoundFilePtr(bool atStreamStart);
void Load_SoundFilePtrArray(bool atStreamStart, int count);
void Load_SoundFileRef(bool atStreamStart);
void Load_SoundFileRefArray(bool atStreamStart, int count);
void Load_SoundFileRefPtr(bool atStreamStart);
void Load_SoundFileRefPtrArray(bool atStreamStart, int count);
void Load_SpeakerMap(bool atStreamStart);
void Load_SpeakerMapArray(bool atStreamStart, int count);
void Load_SpeakerMapPtr(bool atStreamStart);
void Load_SpeakerMapPtrArray(bool atStreamStart, int count);
void Load_Stage(bool atStreamStart);
void Load_StageArray(bool atStreamStart, int count);
void Load_StagePtr(bool atStreamStart);
void Load_StagePtrArray(bool atStreamStart, int count);
void Load_Statement_s(bool atStreamStart);
void Load_Statement_sArray(bool atStreamStart, int count);
void Load_Statement_sPtr(bool atStreamStart);
void Load_Statement_sPtrArray(bool atStreamStart, int count);
void Load_StaticDvar(bool atStreamStart);
void Load_StaticDvarArray(bool atStreamStart, int count);
void Load_StaticDvarList(bool atStreamStart);
void Load_StaticDvarListArray(bool atStreamStart, int count);
void Load_StaticDvarListPtr(bool atStreamStart);
void Load_StaticDvarListPtrArray(bool atStreamStart, int count);
void Load_StaticDvarPtr(bool atStreamStart);
void Load_StaticDvarPtrArray(bool atStreamStart, int count);
void Load_StreamFileInfo(bool atStreamStart);
void Load_StreamFileInfoArray(bool atStreamStart, int count);
void Load_StreamFileInfoPtr(bool atStreamStart);
void Load_StreamFileInfoPtrArray(bool atStreamStart, int count);
void Load_StreamFileName(bool atStreamStart);
void Load_StreamFileNameArray(bool atStreamStart, int count);
void Load_StreamFileNamePtr(bool atStreamStart);
void Load_StreamFileNamePtrArray(bool atStreamStart, int count);
void Load_StreamFileNameRaw(bool atStreamStart);
void Load_StreamFileNameRawArray(bool atStreamStart, int count);
void Load_StreamFileNameRawPtr(bool atStreamStart);
void Load_StreamFileNameRawPtrArray(bool atStreamStart, int count);
void Load_StreamedSound(bool atStreamStart);
void Load_StreamedSoundArray(bool atStreamStart, int count);
void Load_StreamedSoundPtr(bool atStreamStart);
void Load_StreamedSoundPtrArray(bool atStreamStart, int count);
void Load_StringList(bool atStreamStart);
void Load_StringListArray(bool atStreamStart, int count);
void Load_StringListPtr(bool atStreamStart);
void Load_StringListPtrArray(bool atStreamStart, int count);
void Load_StringTable(bool atStreamStart);
void Load_StringTableArray(bool atStreamStart, int count);
void Load_StringTableAsset(StringTable** asset);
void Load_StringTableCell(bool atStreamStart);
void Load_StringTableCellArray(bool atStreamStart, int count);
void Load_StringTableCellPtr(bool atStreamStart);
void Load_StringTableCellPtrArray(bool atStreamStart, int count);
void Load_StringTablePtr(bool atStreamStart);
void Load_StringTablePtrArray(bool atStreamStart, int count);
void Load_StructuredDataDef(bool atStreamStart);
void Load_StructuredDataDefArray(bool atStreamStart, int count);
void Load_StructuredDataDefPtr(bool atStreamStart);
void Load_StructuredDataDefPtrArray(bool atStreamStart, int count);
void Load_StructuredDataDefSet(bool atStreamStart);
void Load_StructuredDataDefSetArray(bool atStreamStart, int count);
void Load_StructuredDataDefSetAsset(StructuredDataDefSet** asset);
void Load_StructuredDataDefSetPtr(bool atStreamStart);
void Load_StructuredDataDefSetPtrArray(bool atStreamStart, int count);
void Load_StructuredDataEnum(bool atStreamStart);
void Load_StructuredDataEnumArray(bool atStreamStart, int count);
void Load_StructuredDataEnumEntry(bool atStreamStart);
void Load_StructuredDataEnumEntryArray(bool atStreamStart, int count);
void Load_StructuredDataEnumEntryPtr(bool atStreamStart);
void Load_StructuredDataEnumEntryPtrArray(bool atStreamStart, int count);
void Load_StructuredDataEnumPtr(bool atStreamStart);
void Load_StructuredDataEnumPtrArray(bool atStreamStart, int count);
void Load_StructuredDataEnumedArray(bool atStreamStart);
void Load_StructuredDataEnumedArrayArray(bool atStreamStart, int count);
void Load_StructuredDataEnumedArrayPtr(bool atStreamStart);
void Load_StructuredDataEnumedArrayPtrArray(bool atStreamStart, int count);
void Load_StructuredDataIndexedArray(bool atStreamStart);
void Load_StructuredDataIndexedArrayArray(bool atStreamStart, int count);
void Load_StructuredDataIndexedArrayPtr(bool atStreamStart);
void Load_StructuredDataIndexedArrayPtrArray(bool atStreamStart, int count);
void Load_StructuredDataStruct(bool atStreamStart);
void Load_StructuredDataStructArray(bool atStreamStart, int count);
void Load_StructuredDataStructProperty(bool atStreamStart);
void Load_StructuredDataStructPropertyArray(bool atStreamStart, int count);
void Load_StructuredDataStructPropertyPtr(bool atStreamStart);
void Load_StructuredDataStructPropertyPtrArray(bool atStreamStart, int count);
void Load_StructuredDataStructPtr(bool atStreamStart);
void Load_StructuredDataStructPtrArray(bool atStreamStart, int count);
void Load_StructuredDataType(bool atStreamStart);
void Load_StructuredDataTypeArray(bool atStreamStart, int count);
void Load_StructuredDataTypePtr(bool atStreamStart);
void Load_StructuredDataTypePtrArray(bool atStreamStart, int count);
void Load_StructuredDataTypeUnion(bool atStreamStart);
void Load_StructuredDataTypeUnionArray(bool atStreamStart, int count);
void Load_StructuredDataTypeUnionPtr(bool atStreamStart);
void Load_StructuredDataTypeUnionPtrArray(bool atStreamStart, int count);
void Load_TempStringArray(bool atStreamStart, int count);
void Load_TempStringPtr(bool atStreamStart);
void Load_TempStringPtrArray(bool atStreamStart, int count);
void Load_TracerDef(bool atStreamStart);
void Load_TracerDefArray(bool atStreamStart, int count);
void Load_TracerDefAsset(TracerDef** asset);
void Load_TracerDefPtr(bool atStreamStart);
void Load_TracerDefPtrArray(bool atStreamStart, int count);
void Load_TriIndice(bool atStreamStart);
void Load_TriIndiceArray(bool atStreamStart, int count);
void Load_TriIndicePtr(bool atStreamStart);
void Load_TriIndicePtrArray(bool atStreamStart, int count);
void Load_TriggerHull(bool atStreamStart);
void Load_TriggerHullArray(bool atStreamStart, int count);
void Load_TriggerHullPtr(bool atStreamStart);
void Load_TriggerHullPtrArray(bool atStreamStart, int count);
void Load_TriggerModel(bool atStreamStart);
void Load_TriggerModelArray(bool atStreamStart, int count);
void Load_TriggerModelPtr(bool atStreamStart);
void Load_TriggerModelPtrArray(bool atStreamStart, int count);
void Load_TriggerSlab(bool atStreamStart);
void Load_TriggerSlabArray(bool atStreamStart, int count);
void Load_TriggerSlabPtr(bool atStreamStart);
void Load_TriggerSlabPtrArray(bool atStreamStart, int count);
void Load_UIFunctionList(bool atStreamStart);
void Load_UIFunctionListArray(bool atStreamStart, int count);
void Load_UIFunctionListPtr(bool atStreamStart);
void Load_UIFunctionListPtrArray(bool atStreamStart, int count);
void Load_WaterWritable(bool atStreamStart);
void Load_WaterWritableArray(bool atStreamStart, int count);
void Load_WaterWritablePtr(bool atStreamStart);
void Load_WaterWritablePtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPart(bool atStreamStart);
void Load_XAnimDeltaPartArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartPtr(bool atStreamStart);
void Load_XAnimDeltaPartPtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuat(bool atStreamStart);
void Load_XAnimDeltaPartQuat2(bool atStreamStart);
void Load_XAnimDeltaPartQuat2Array(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuat2Ptr(bool atStreamStart);
void Load_XAnimDeltaPartQuat2PtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatData(bool atStreamStart);
void Load_XAnimDeltaPartQuatData2(bool atStreamStart);
void Load_XAnimDeltaPartQuatData2Array(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatData2Ptr(bool atStreamStart);
void Load_XAnimDeltaPartQuatData2PtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatDataArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatDataFrames(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataFrames2(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataFrames2Array(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatDataFrames2Ptr(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataFrames2PtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatDataFramesArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatDataFramesPtr(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataFramesPtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatDataPtr(bool atStreamStart);
void Load_XAnimDeltaPartQuatDataPtrArray(bool atStreamStart, int count);
void Load_XAnimDeltaPartQuatPtr(bool atStreamStart);
void Load_XAnimDeltaPartQuatPtrArray(bool atStreamStart, int count);
void Load_XAnimDynamicFrames(bool atStreamStart);
void Load_XAnimDynamicFramesArray(bool atStreamStart, int count);
void Load_XAnimDynamicFramesPtr(bool atStreamStart);
void Load_XAnimDynamicFramesPtrArray(bool atStreamStart, int count);
void Load_XAnimDynamicIndices(bool atStreamStart);
void Load_XAnimDynamicIndicesArray(bool atStreamStart, int count);
void Load_XAnimDynamicIndicesPtr(bool atStreamStart);
void Load_XAnimDynamicIndicesPtrArray(bool atStreamStart, int count);
void Load_XAnimIndices(bool atStreamStart);
void Load_XAnimIndicesArray(bool atStreamStart, int count);
void Load_XAnimIndicesPtr(bool atStreamStart);
void Load_XAnimIndicesPtrArray(bool atStreamStart, int count);
void Load_XAnimNotifyInfo(bool atStreamStart);
void Load_XAnimNotifyInfoArray(bool atStreamStart, int count);
void Load_XAnimNotifyInfoPtr(bool atStreamStart);
void Load_XAnimNotifyInfoPtrArray(bool atStreamStart, int count);
void Load_XAnimPartTrans(bool atStreamStart);
void Load_XAnimPartTransArray(bool atStreamStart, int count);
void Load_XAnimPartTransData(bool atStreamStart);
void Load_XAnimPartTransDataArray(bool atStreamStart, int count);
void Load_XAnimPartTransDataPtr(bool atStreamStart);
void Load_XAnimPartTransDataPtrArray(bool atStreamStart, int count);
void Load_XAnimPartTransFrames(bool atStreamStart);
void Load_XAnimPartTransFramesArray(bool atStreamStart, int count);
void Load_XAnimPartTransFramesPtr(bool atStreamStart);
void Load_XAnimPartTransFramesPtrArray(bool atStreamStart, int count);
void Load_XAnimPartTransPtr(bool atStreamStart);
void Load_XAnimPartTransPtrArray(bool atStreamStart, int count);
void Load_XAnimParts(bool atStreamStart);
void Load_XAnimPartsArray(bool atStreamStart, int count);
void Load_XAnimPartsAsset(XAnimParts** asset);
void Load_XAnimPartsPtr(bool atStreamStart);
void Load_XAnimPartsPtrArray(bool atStreamStart, int count);
void Load_XAsset(bool atStreamStart);
void Load_XAssetArray(bool atStreamStart, int count);
void Load_XAssetHeader(bool atStreamStart);
void Load_XAssetHeaderArray(bool atStreamStart, int count);
void Load_XAssetHeaderPtr(bool atStreamStart);
void Load_XAssetHeaderPtrArray(bool atStreamStart, int count);
void Load_XAssetList(bool atStreamStart);
void Load_XAssetListArray(bool atStreamStart, int count);
void Load_XAssetListAsset(XAssetList** asset);
void Load_XAssetListPtr(bool atStreamStart);
void Load_XAssetListPtrArray(bool atStreamStart, int count);
void Load_XAssetPtr(bool atStreamStart);
void Load_XAssetPtrArray(bool atStreamStart, int count);
void Load_XBoneInfo(bool atStreamStart);
void Load_XBoneInfoArray(bool atStreamStart, int count);
void Load_XBoneInfoPtr(bool atStreamStart);
void Load_XBoneInfoPtrArray(bool atStreamStart, int count);
void Load_XModel(bool atStreamStart);
void Load_XModelArray(bool atStreamStart, int count);
void Load_XModelAsset(XModel** asset);
void Load_XModelCollSurf_s(bool atStreamStart);
void Load_XModelCollSurf_sArray(bool atStreamStart, int count);
void Load_XModelCollSurf_sPtr(bool atStreamStart);
void Load_XModelCollSurf_sPtrArray(bool atStreamStart, int count);
void Load_XModelCollTri_s(bool atStreamStart);
void Load_XModelCollTri_sArray(bool atStreamStart, int count);
void Load_XModelCollTri_sPtr(bool atStreamStart);
void Load_XModelCollTri_sPtrArray(bool atStreamStart, int count);
void Load_XModelLodInfo(bool atStreamStart);
void Load_XModelLodInfoArray(bool atStreamStart, int count);
void Load_XModelLodInfoPtr(bool atStreamStart);
void Load_XModelLodInfoPtrArray(bool atStreamStart, int count);
void Load_XModelPtr(bool atStreamStart);
void Load_XModelPtrArray(bool atStreamStart, int count);
void Load_XModelSurfs(bool atStreamStart);
void Load_XModelSurfsArray(bool atStreamStart, int count);
void Load_XModelSurfsAsset(XModelSurfs** asset);
void Load_XModelSurfsPtr(bool atStreamStart);
void Load_XModelSurfsPtrArray(bool atStreamStart, int count);
void Load_XRigidVertList(bool atStreamStart);
void Load_XRigidVertListArray(bool atStreamStart, int count);
void Load_XRigidVertListPtr(bool atStreamStart);
void Load_XRigidVertListPtrArray(bool atStreamStart, int count);
void Load_XStringArray(bool atStreamStart, int count);
void Load_XStringPtr(bool atStreamStart);
void Load_XStringPtrArray(bool atStreamStart, int count);
void Load_XSurface(bool atStreamStart);
void Load_XSurfaceArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionAabb(bool atStreamStart);
void Load_XSurfaceCollisionAabbArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionAabbPtr(bool atStreamStart);
void Load_XSurfaceCollisionAabbPtrArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionLeaf(bool atStreamStart);
void Load_XSurfaceCollisionLeafArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionLeafPtr(bool atStreamStart);
void Load_XSurfaceCollisionLeafPtrArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionNode(bool atStreamStart);
void Load_XSurfaceCollisionNodeArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionNodePtr(bool atStreamStart);
void Load_XSurfaceCollisionNodePtrArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionTree(bool atStreamStart);
void Load_XSurfaceCollisionTreeArray(bool atStreamStart, int count);
void Load_XSurfaceCollisionTreePtr(bool atStreamStart);
void Load_XSurfaceCollisionTreePtrArray(bool atStreamStart, int count);
void Load_XSurfacePtr(bool atStreamStart);
void Load_XSurfacePtrArray(bool atStreamStart, int count);
void Load_XSurfaceVertexInfo(bool atStreamStart);
void Load_XSurfaceVertexInfoArray(bool atStreamStart, int count);
void Load_XSurfaceVertexInfoPtr(bool atStreamStart);
void Load_XSurfaceVertexInfoPtrArray(bool atStreamStart, int count);
void Load__AILSOUNDINFO(bool atStreamStart);
void Load__AILSOUNDINFOArray(bool atStreamStart, int count);
void Load__AILSOUNDINFOPtr(bool atStreamStart);
void Load__AILSOUNDINFOPtrArray(bool atStreamStart, int count);
void Load_bool(bool atStreamStart);
void Load_boolArray(bool atStreamStart, int count);
void Load_boolPtr(bool atStreamStart);
void Load_boolPtrArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeChildren_t(bool atStreamStart);
void Load_cLeafBrushNodeChildren_tArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeChildren_tPtr(bool atStreamStart);
void Load_cLeafBrushNodeChildren_tPtrArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeData_t(bool atStreamStart);
void Load_cLeafBrushNodeData_tArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeData_tPtr(bool atStreamStart);
void Load_cLeafBrushNodeData_tPtrArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeLeaf_t(bool atStreamStart);
void Load_cLeafBrushNodeLeaf_tArray(bool atStreamStart, int count);
void Load_cLeafBrushNodeLeaf_tPtr(bool atStreamStart);
void Load_cLeafBrushNodeLeaf_tPtrArray(bool atStreamStart, int count);
void Load_cLeafBrushNode_s(bool atStreamStart);
void Load_cLeafBrushNode_sArray(bool atStreamStart, int count);
void Load_cLeafBrushNode_sPtr(bool atStreamStart);
void Load_cLeafBrushNode_sPtrArray(bool atStreamStart, int count);
void Load_cLeaf_t(bool atStreamStart);
void Load_cLeaf_tArray(bool atStreamStart, int count);
void Load_cLeaf_tPtr(bool atStreamStart);
void Load_cLeaf_tPtrArray(bool atStreamStart, int count);
void Load_cNode_t(bool atStreamStart);
void Load_cNode_tArray(bool atStreamStart, int count);
void Load_cNode_tPtr(bool atStreamStart);
void Load_cNode_tPtrArray(bool atStreamStart, int count);
void Load_cStaticModel_s(bool atStreamStart);
void Load_cStaticModel_sArray(bool atStreamStart, int count);
void Load_cStaticModel_sPtr(bool atStreamStart);
void Load_cStaticModel_sPtrArray(bool atStreamStart, int count);
void Load_cbrush_t(bool atStreamStart);
void Load_cbrush_tArray(bool atStreamStart, int count);
void Load_cbrush_tPtr(bool atStreamStart);
void Load_cbrush_tPtrArray(bool atStreamStart, int count);
void Load_cbrushside_t(bool atStreamStart);
void Load_cbrushside_tArray(bool atStreamStart, int count);
void Load_cbrushside_tPtr(bool atStreamStart);
void Load_cbrushside_tPtrArray(bool atStreamStart, int count);
void Load_char(bool atStreamStart);
void Load_char16(bool atStreamStart);
void Load_char16Array(bool atStreamStart, int count);
void Load_char16Ptr(bool atStreamStart);
void Load_char16PtrArray(bool atStreamStart, int count);
void Load_charArray(bool atStreamStart, int count);
void Load_charPtr(bool atStreamStart);
void Load_charPtrArray(bool atStreamStart, int count);
void Load_clipMap_t(bool atStreamStart);
void Load_clipMap_tArray(bool atStreamStart, int count);
void Load_clipMap_tAsset(clipMap_t** asset);
void Load_clipMap_tPtr(bool atStreamStart);
void Load_clipMap_tPtrArray(bool atStreamStart, int count);
void Load_cmodel_t(bool atStreamStart);
void Load_cmodel_tArray(bool atStreamStart, int count);
void Load_cmodel_tPtr(bool atStreamStart);
void Load_cmodel_tPtrArray(bool atStreamStart, int count);
void Load_columnInfo_s(bool atStreamStart);
void Load_columnInfo_sArray(bool atStreamStart, int count);
void Load_columnInfo_sPtr(bool atStreamStart);
void Load_columnInfo_sPtrArray(bool atStreamStart, int count);
void Load_complex_s(bool atStreamStart);
void Load_complex_sArray(bool atStreamStart, int count);
void Load_complex_sPtr(bool atStreamStart);
void Load_complex_sPtrArray(bool atStreamStart, int count);
void Load_cplane_s(bool atStreamStart);
void Load_cplane_sArray(bool atStreamStart, int count);
void Load_cplane_sPtr(bool atStreamStart);
void Load_cplane_sPtrArray(bool atStreamStart, int count);
void Load_double(bool atStreamStart);
void Load_doubleArray(bool atStreamStart, int count);
void Load_doublePtr(bool atStreamStart);
void Load_doublePtrArray(bool atStreamStart, int count);
void Load_editFieldDef_s(bool atStreamStart);
void Load_editFieldDef_sArray(bool atStreamStart, int count);
void Load_editFieldDef_sPtr(bool atStreamStart);
void Load_editFieldDef_sPtrArray(bool atStreamStart, int count);
void Load_entryInternalData(bool atStreamStart);
void Load_entryInternalDataArray(bool atStreamStart, int count);
void Load_entryInternalDataPtr(bool atStreamStart);
void Load_entryInternalDataPtrArray(bool atStreamStart, int count);
void Load_expressionEntry(bool atStreamStart);
void Load_expressionEntryArray(bool atStreamStart, int count);
void Load_expressionEntryPtr(bool atStreamStart);
void Load_expressionEntryPtrArray(bool atStreamStart, int count);
void Load_float(bool atStreamStart);
void Load_float16(bool atStreamStart);
void Load_float16Array(bool atStreamStart, int count);
void Load_float16Ptr(bool atStreamStart);
void Load_float16PtrArray(bool atStreamStart, int count);
void Load_floatArray(bool atStreamStart, int count);
void Load_floatPtr(bool atStreamStart);
void Load_floatPtrArray(bool atStreamStart, int count);
void Load_int16(bool atStreamStart);
void Load_int16Array(bool atStreamStart, int count);
void Load_int16Ptr(bool atStreamStart);
void Load_int16PtrArray(bool atStreamStart, int count);
void Load_int32(bool atStreamStart);
void Load_int32Array(bool atStreamStart, int count);
void Load_int32Ptr(bool atStreamStart);
void Load_int32PtrArray(bool atStreamStart, int count);
void Load_int64(bool atStreamStart);
void Load_int64Array(bool atStreamStart, int count);
void Load_int64Ptr(bool atStreamStart);
void Load_int64PtrArray(bool atStreamStart, int count);
void Load_int8(bool atStreamStart);
void Load_int8Array(bool atStreamStart, int count);
void Load_int8Ptr(bool atStreamStart);
void Load_int8PtrArray(bool atStreamStart, int count);
void Load_itemDefData_t(bool atStreamStart);
void Load_itemDefData_tArray(bool atStreamStart, int count);
void Load_itemDefData_tPtr(bool atStreamStart);
void Load_itemDefData_tPtrArray(bool atStreamStart, int count);
void Load_itemDef_s(bool atStreamStart);
void Load_itemDef_sArray(bool atStreamStart, int count);
void Load_itemDef_sPtr(bool atStreamStart);
void Load_itemDef_sPtrArray(bool atStreamStart, int count);
void Load_listBoxDef_s(bool atStreamStart);
void Load_listBoxDef_sArray(bool atStreamStart, int count);
void Load_listBoxDef_sPtr(bool atStreamStart);
void Load_listBoxDef_sPtrArray(bool atStreamStart, int count);
void Load_menuDef_t(bool atStreamStart);
void Load_menuDef_tArray(bool atStreamStart, int count);
void Load_menuDef_tAsset(menuDef_t** asset);
void Load_menuDef_tPtr(bool atStreamStart);
void Load_menuDef_tPtrArray(bool atStreamStart, int count);
void Load_menuTransition(bool atStreamStart);
void Load_menuTransitionArray(bool atStreamStart, int count);
void Load_menuTransitionPtr(bool atStreamStart);
void Load_menuTransitionPtrArray(bool atStreamStart, int count);
void Load_multiDef_s(bool atStreamStart);
void Load_multiDef_sArray(bool atStreamStart, int count);
void Load_multiDef_sPtr(bool atStreamStart);
void Load_multiDef_sPtrArray(bool atStreamStart, int count);
void Load_newsTickerDef_s(bool atStreamStart);
void Load_newsTickerDef_sArray(bool atStreamStart, int count);
void Load_newsTickerDef_sPtr(bool atStreamStart);
void Load_newsTickerDef_sPtrArray(bool atStreamStart, int count);
void Load_operandInternalDataUnion(bool atStreamStart);
void Load_operandInternalDataUnionArray(bool atStreamStart, int count);
void Load_operandInternalDataUnionPtr(bool atStreamStart);
void Load_operandInternalDataUnionPtrArray(bool atStreamStart, int count);
void Load_rectDef_s(bool atStreamStart);
void Load_rectDef_sArray(bool atStreamStart, int count);
void Load_rectDef_sPtr(bool atStreamStart);
void Load_rectDef_sPtrArray(bool atStreamStart, int count);
void Load_snd_alias_list_t(bool atStreamStart);
void Load_snd_alias_list_tArray(bool atStreamStart, int count);
void Load_snd_alias_list_tAsset(snd_alias_list_t** asset);
void Load_snd_alias_list_tPtr(bool atStreamStart);
void Load_snd_alias_list_tPtrArray(bool atStreamStart, int count);
void Load_snd_alias_t(bool atStreamStart);
void Load_snd_alias_tArray(bool atStreamStart, int count);
void Load_snd_alias_tPtr(bool atStreamStart);
void Load_snd_alias_tPtrArray(bool atStreamStart, int count);
void Load_textScrollDef_s(bool atStreamStart);
void Load_textScrollDef_sArray(bool atStreamStart, int count);
void Load_textScrollDef_sPtr(bool atStreamStart);
void Load_textScrollDef_sPtrArray(bool atStreamStart, int count);
void Load_uint16(bool atStreamStart);
void Load_uint16Array(bool atStreamStart, int count);
void Load_uint16Ptr(bool atStreamStart);
void Load_uint16PtrArray(bool atStreamStart, int count);
void Load_uint32(bool atStreamStart);
void Load_uint32Array(bool atStreamStart, int count);
void Load_uint32Ptr(bool atStreamStart);
void Load_uint32PtrArray(bool atStreamStart, int count);
void Load_uint64(bool atStreamStart);
void Load_uint64Array(bool atStreamStart, int count);
void Load_uint64Ptr(bool atStreamStart);
void Load_uint64PtrArray(bool atStreamStart, int count);
void Load_uint8(bool atStreamStart);
void Load_uint8Array(bool atStreamStart, int count);
void Load_uint8Ptr(bool atStreamStart);
void Load_uint8PtrArray(bool atStreamStart, int count);
void Load_vec1_t(bool atStreamStart);
void Load_vec1_tArray(bool atStreamStart, int count);
void Load_vec1_tPtr(bool atStreamStart);
void Load_vec1_tPtrArray(bool atStreamStart, int count);
void Load_vec2_t(bool atStreamStart);
void Load_vec2_tArray(bool atStreamStart, int count);
void Load_vec2_tPtr(bool atStreamStart);
void Load_vec2_tPtrArray(bool atStreamStart, int count);
void Load_vec3_t(bool atStreamStart);
void Load_vec3_tArray(bool atStreamStart, int count);
void Load_vec3_tPtr(bool atStreamStart);
void Load_vec3_tPtrArray(bool atStreamStart, int count);
void Load_vec4_t(bool atStreamStart);
void Load_vec4_tArray(bool atStreamStart, int count);
void Load_vec4_tPtr(bool atStreamStart);
void Load_vec4_tPtrArray(bool atStreamStart, int count);
void Load_water_t(bool atStreamStart);
void Load_water_tArray(bool atStreamStart, int count);
void Load_water_tPtr(bool atStreamStart);
void Load_water_tPtrArray(bool atStreamStart, int count);
void Load_windowDef_t(bool atStreamStart);
void Load_windowDef_tArray(bool atStreamStart, int count);
void Load_windowDef_tPtr(bool atStreamStart);
void Load_windowDef_tPtrArray(bool atStreamStart, int count);
water_t* AllocLoad_water_t();
water_t** AllocLoad_water_tPtr();
windowDef_t* AllocLoad_windowDef_t();
windowDef_t** AllocLoad_windowDef_tPtr();

int64* varint64;
int64** varint64Ptr;
int64* outint64;
int64** outint64Ptr;
int64* streamint64;
int64** streamint64Ptr;
uint64* varuint64;
uint64** varuint64Ptr;
uint64* outuint64;
uint64** outuint64Ptr;
uint64* streamuint64;
uint64** streamuint64Ptr;
double* vardouble;
double** vardoublePtr;
double* outdouble;
double** outdoublePtr;
double* streamdouble;
double** streamdoublePtr;
int32* varint32;
int32** varint32Ptr;
int32* outint32;
int32** outint32Ptr;
int32* streamint32;
int32** streamint32Ptr;
uint32* varuint32;
uint32** varuint32Ptr;
uint32* outuint32;
uint32** outuint32Ptr;
uint32* streamuint32;
uint32** streamuint32Ptr;
float* varfloat;
float** varfloatPtr;
float* outfloat;
float** outfloatPtr;
float* streamfloat;
float** streamfloatPtr;
int16* varint16;
int16** varint16Ptr;
int16* outint16;
int16** outint16Ptr;
int16* streamint16;
int16** streamint16Ptr;
uint16* varuint16;
uint16** varuint16Ptr;
uint16* outuint16;
uint16** outuint16Ptr;
uint16* streamuint16;
uint16** streamuint16Ptr;
int8* varint8;
int8** varint8Ptr;
int8* outint8;
int8** outint8Ptr;
int8* streamint8;
int8** streamint8Ptr;
uint8* varuint8;
uint8** varuint8Ptr;
uint8* outuint8;
uint8** outuint8Ptr;
uint8* streamuint8;
uint8** streamuint8Ptr;
char* varchar;
char** varcharPtr;
char* outchar;
char** outcharPtr;
char* streamchar;
char** streamcharPtr;
bool* varbool;
bool** varboolPtr;
bool* outbool;
bool** outboolPtr;
bool* streambool;
bool** streamboolPtr;
void* varvoid;
void** varvoidPtr;
void* outvoid;
void** outvoidPtr;
void* streamvoid;
void** streamvoidPtr;
XString** varXStringPtr;
XString* outXString;
XString** outXStringPtr;
XString* streamXString;
XString** streamXStringPtr;
TempString** varTempStringPtr;
TempString* outTempString;
TempString** outTempStringPtr;
TempString* streamTempString;
TempString** streamTempStringPtr;
XFileBlock* varXFileBlock;
XFileBlock** varXFileBlockPtr;
XFileBlock* outXFileBlock;
XFileBlock** outXFileBlockPtr;
XFileBlock* streamXFileBlock;
XFileBlock** streamXFileBlockPtr;
vec1_t* varvec1_t;
vec1_t** varvec1_tPtr;
vec1_t* outvec1_t;
vec1_t** outvec1_tPtr;
vec1_t* streamvec1_t;
vec1_t** streamvec1_tPtr;
vec2_t* varvec2_t;
vec2_t** varvec2_tPtr;
vec2_t* outvec2_t;
vec2_t** outvec2_tPtr;
vec2_t* streamvec2_t;
vec2_t** streamvec2_tPtr;
vec3_t* varvec3_t;
vec3_t** varvec3_tPtr;
vec3_t* outvec3_t;
vec3_t** outvec3_tPtr;
vec3_t* streamvec3_t;
vec3_t** streamvec3_tPtr;
vec4_t* varvec4_t;
vec4_t** varvec4_tPtr;
vec4_t* outvec4_t;
vec4_t** outvec4_tPtr;
vec4_t* streamvec4_t;
vec4_t** streamvec4_tPtr;
Bounds* varBounds;
Bounds** varBoundsPtr;
Bounds* outBounds;
Bounds** outBoundsPtr;
Bounds* streamBounds;
Bounds** streamBoundsPtr;
cplane_s* varcplane_s;
cplane_s** varcplane_sPtr;
cplane_s* outcplane_s;
cplane_s** outcplane_sPtr;
cplane_s* streamcplane_s;
cplane_s** streamcplane_sPtr;
cbrush_t* varcbrush_t;
cbrush_t** varcbrush_tPtr;
cbrush_t* outcbrush_t;
cbrush_t** outcbrush_tPtr;
cbrush_t* streamcbrush_t;
cbrush_t** streamcbrush_tPtr;
BrushWrapper* varBrushWrapper;
BrushWrapper** varBrushWrapperPtr;
BrushWrapper* outBrushWrapper;
BrushWrapper** outBrushWrapperPtr;
BrushWrapper* streamBrushWrapper;
BrushWrapper** streamBrushWrapperPtr;
DObjAnimMat* varDObjAnimMat;
DObjAnimMat** varDObjAnimMatPtr;
DObjAnimMat* outDObjAnimMat;
DObjAnimMat** outDObjAnimMatPtr;
DObjAnimMat* streamDObjAnimMat;
DObjAnimMat** streamDObjAnimMatPtr;
XSurfaceVertexInfo* varXSurfaceVertexInfo;
XSurfaceVertexInfo** varXSurfaceVertexInfoPtr;
XSurfaceVertexInfo* outXSurfaceVertexInfo;
XSurfaceVertexInfo** outXSurfaceVertexInfoPtr;
XSurfaceVertexInfo* streamXSurfaceVertexInfo;
XSurfaceVertexInfo** streamXSurfaceVertexInfoPtr;
GfxColor* varGfxColor;
GfxColor** varGfxColorPtr;
GfxColor* outGfxColor;
GfxColor** outGfxColorPtr;
GfxColor* streamGfxColor;
GfxColor** streamGfxColorPtr;
PackedTexCoords* varPackedTexCoords;
PackedTexCoords** varPackedTexCoordsPtr;
PackedTexCoords* outPackedTexCoords;
PackedTexCoords** outPackedTexCoordsPtr;
PackedTexCoords* streamPackedTexCoords;
PackedTexCoords** streamPackedTexCoordsPtr;
PackedUnitVec* varPackedUnitVec;
PackedUnitVec** varPackedUnitVecPtr;
PackedUnitVec* outPackedUnitVec;
PackedUnitVec** outPackedUnitVecPtr;
PackedUnitVec* streamPackedUnitVec;
PackedUnitVec** streamPackedUnitVecPtr;
GfxPackedVertex* varGfxPackedVertex;
GfxPackedVertex** varGfxPackedVertexPtr;
GfxPackedVertex* outGfxPackedVertex;
GfxPackedVertex** outGfxPackedVertexPtr;
GfxPackedVertex* streamGfxPackedVertex;
GfxPackedVertex** streamGfxPackedVertexPtr;
XSurfaceCollisionAabb* varXSurfaceCollisionAabb;
XSurfaceCollisionAabb** varXSurfaceCollisionAabbPtr;
XSurfaceCollisionAabb* outXSurfaceCollisionAabb;
XSurfaceCollisionAabb** outXSurfaceCollisionAabbPtr;
XSurfaceCollisionAabb* streamXSurfaceCollisionAabb;
XSurfaceCollisionAabb** streamXSurfaceCollisionAabbPtr;
XSurfaceCollisionNode* varXSurfaceCollisionNode;
XSurfaceCollisionNode** varXSurfaceCollisionNodePtr;
XSurfaceCollisionNode* outXSurfaceCollisionNode;
XSurfaceCollisionNode** outXSurfaceCollisionNodePtr;
XSurfaceCollisionNode* streamXSurfaceCollisionNode;
XSurfaceCollisionNode** streamXSurfaceCollisionNodePtr;
XSurfaceCollisionLeaf* varXSurfaceCollisionLeaf;
XSurfaceCollisionLeaf** varXSurfaceCollisionLeafPtr;
XSurfaceCollisionLeaf* outXSurfaceCollisionLeaf;
XSurfaceCollisionLeaf** outXSurfaceCollisionLeafPtr;
XSurfaceCollisionLeaf* streamXSurfaceCollisionLeaf;
XSurfaceCollisionLeaf** streamXSurfaceCollisionLeafPtr;
XSurfaceCollisionTree* varXSurfaceCollisionTree;
XSurfaceCollisionTree** varXSurfaceCollisionTreePtr;
XSurfaceCollisionTree* outXSurfaceCollisionTree;
XSurfaceCollisionTree** outXSurfaceCollisionTreePtr;
XSurfaceCollisionTree* streamXSurfaceCollisionTree;
XSurfaceCollisionTree** streamXSurfaceCollisionTreePtr;
XRigidVertList* varXRigidVertList;
XRigidVertList** varXRigidVertListPtr;
XRigidVertList* outXRigidVertList;
XRigidVertList** outXRigidVertListPtr;
XRigidVertList* streamXRigidVertList;
XRigidVertList** streamXRigidVertListPtr;
TriIndice* varTriIndice;
TriIndice** varTriIndicePtr;
TriIndice* outTriIndice;
TriIndice** outTriIndicePtr;
TriIndice* streamTriIndice;
TriIndice** streamTriIndicePtr;
XSurface* varXSurface;
XSurface** varXSurfacePtr;
XSurface* outXSurface;
XSurface** outXSurfacePtr;
XSurface* streamXSurface;
XSurface** streamXSurfacePtr;
XModelSurfs* varXModelSurfs;
XModelSurfs** varXModelSurfsPtr;
XModelSurfs* outXModelSurfs;
XModelSurfs** outXModelSurfsPtr;
XModelSurfs* streamXModelSurfs;
XModelSurfs** streamXModelSurfsPtr;
XModelLodInfo* varXModelLodInfo;
XModelLodInfo** varXModelLodInfoPtr;
XModelLodInfo* outXModelLodInfo;
XModelLodInfo** outXModelLodInfoPtr;
XModelLodInfo* streamXModelLodInfo;
XModelLodInfo** streamXModelLodInfoPtr;
XModelCollTri_s* varXModelCollTri_s;
XModelCollTri_s** varXModelCollTri_sPtr;
XModelCollTri_s* outXModelCollTri_s;
XModelCollTri_s** outXModelCollTri_sPtr;
XModelCollTri_s* streamXModelCollTri_s;
XModelCollTri_s** streamXModelCollTri_sPtr;
XModelCollSurf_s* varXModelCollSurf_s;
XModelCollSurf_s** varXModelCollSurf_sPtr;
XModelCollSurf_s* outXModelCollSurf_s;
XModelCollSurf_s** outXModelCollSurf_sPtr;
XModelCollSurf_s* streamXModelCollSurf_s;
XModelCollSurf_s** streamXModelCollSurf_sPtr;
XBoneInfo* varXBoneInfo;
XBoneInfo** varXBoneInfoPtr;
XBoneInfo* outXBoneInfo;
XBoneInfo** outXBoneInfoPtr;
XBoneInfo* streamXBoneInfo;
XBoneInfo** streamXBoneInfoPtr;
XAnimIndices* varXAnimIndices;
XAnimIndices** varXAnimIndicesPtr;
XAnimIndices* outXAnimIndices;
XAnimIndices** outXAnimIndicesPtr;
XAnimIndices* streamXAnimIndices;
XAnimIndices** streamXAnimIndicesPtr;
XAnimNotifyInfo* varXAnimNotifyInfo;
XAnimNotifyInfo** varXAnimNotifyInfoPtr;
XAnimNotifyInfo* outXAnimNotifyInfo;
XAnimNotifyInfo** outXAnimNotifyInfoPtr;
XAnimNotifyInfo* streamXAnimNotifyInfo;
XAnimNotifyInfo** streamXAnimNotifyInfoPtr;
XAnimDynamicFrames* varXAnimDynamicFrames;
XAnimDynamicFrames** varXAnimDynamicFramesPtr;
XAnimDynamicFrames* outXAnimDynamicFrames;
XAnimDynamicFrames** outXAnimDynamicFramesPtr;
XAnimDynamicFrames* streamXAnimDynamicFrames;
XAnimDynamicFrames** streamXAnimDynamicFramesPtr;
XAnimDynamicIndices* varXAnimDynamicIndices;
XAnimDynamicIndices** varXAnimDynamicIndicesPtr;
XAnimDynamicIndices* outXAnimDynamicIndices;
XAnimDynamicIndices** outXAnimDynamicIndicesPtr;
XAnimDynamicIndices* streamXAnimDynamicIndices;
XAnimDynamicIndices** streamXAnimDynamicIndicesPtr;
XAnimPartTransFrames* varXAnimPartTransFrames;
XAnimPartTransFrames** varXAnimPartTransFramesPtr;
XAnimPartTransFrames* outXAnimPartTransFrames;
XAnimPartTransFrames** outXAnimPartTransFramesPtr;
XAnimPartTransFrames* streamXAnimPartTransFrames;
XAnimPartTransFrames** streamXAnimPartTransFramesPtr;
XAnimPartTransData* varXAnimPartTransData;
XAnimPartTransData** varXAnimPartTransDataPtr;
XAnimPartTransData* outXAnimPartTransData;
XAnimPartTransData** outXAnimPartTransDataPtr;
XAnimPartTransData* streamXAnimPartTransData;
XAnimPartTransData** streamXAnimPartTransDataPtr;
XAnimPartTrans* varXAnimPartTrans;
XAnimPartTrans** varXAnimPartTransPtr;
XAnimPartTrans* outXAnimPartTrans;
XAnimPartTrans** outXAnimPartTransPtr;
XAnimPartTrans* streamXAnimPartTrans;
XAnimPartTrans** streamXAnimPartTransPtr;
XAnimDeltaPartQuatDataFrames2* varXAnimDeltaPartQuatDataFrames2;
XAnimDeltaPartQuatDataFrames2** varXAnimDeltaPartQuatDataFrames2Ptr;
XAnimDeltaPartQuatDataFrames2* outXAnimDeltaPartQuatDataFrames2;
XAnimDeltaPartQuatDataFrames2** outXAnimDeltaPartQuatDataFrames2Ptr;
XAnimDeltaPartQuatDataFrames2* streamXAnimDeltaPartQuatDataFrames2;
XAnimDeltaPartQuatDataFrames2** streamXAnimDeltaPartQuatDataFrames2Ptr;
XAnimDeltaPartQuatData2* varXAnimDeltaPartQuatData2;
XAnimDeltaPartQuatData2** varXAnimDeltaPartQuatData2Ptr;
XAnimDeltaPartQuatData2* outXAnimDeltaPartQuatData2;
XAnimDeltaPartQuatData2** outXAnimDeltaPartQuatData2Ptr;
XAnimDeltaPartQuatData2* streamXAnimDeltaPartQuatData2;
XAnimDeltaPartQuatData2** streamXAnimDeltaPartQuatData2Ptr;
XAnimDeltaPartQuat2* varXAnimDeltaPartQuat2;
XAnimDeltaPartQuat2** varXAnimDeltaPartQuat2Ptr;
XAnimDeltaPartQuat2* outXAnimDeltaPartQuat2;
XAnimDeltaPartQuat2** outXAnimDeltaPartQuat2Ptr;
XAnimDeltaPartQuat2* streamXAnimDeltaPartQuat2;
XAnimDeltaPartQuat2** streamXAnimDeltaPartQuat2Ptr;
XAnimDeltaPartQuatDataFrames* varXAnimDeltaPartQuatDataFrames;
XAnimDeltaPartQuatDataFrames** varXAnimDeltaPartQuatDataFramesPtr;
XAnimDeltaPartQuatDataFrames* outXAnimDeltaPartQuatDataFrames;
XAnimDeltaPartQuatDataFrames** outXAnimDeltaPartQuatDataFramesPtr;
XAnimDeltaPartQuatDataFrames* streamXAnimDeltaPartQuatDataFrames;
XAnimDeltaPartQuatDataFrames** streamXAnimDeltaPartQuatDataFramesPtr;
XAnimDeltaPartQuatData* varXAnimDeltaPartQuatData;
XAnimDeltaPartQuatData** varXAnimDeltaPartQuatDataPtr;
XAnimDeltaPartQuatData* outXAnimDeltaPartQuatData;
XAnimDeltaPartQuatData** outXAnimDeltaPartQuatDataPtr;
XAnimDeltaPartQuatData* streamXAnimDeltaPartQuatData;
XAnimDeltaPartQuatData** streamXAnimDeltaPartQuatDataPtr;
XAnimDeltaPartQuat* varXAnimDeltaPartQuat;
XAnimDeltaPartQuat** varXAnimDeltaPartQuatPtr;
XAnimDeltaPartQuat* outXAnimDeltaPartQuat;
XAnimDeltaPartQuat** outXAnimDeltaPartQuatPtr;
XAnimDeltaPartQuat* streamXAnimDeltaPartQuat;
XAnimDeltaPartQuat** streamXAnimDeltaPartQuatPtr;
XAnimDeltaPart* varXAnimDeltaPart;
XAnimDeltaPart** varXAnimDeltaPartPtr;
XAnimDeltaPart* outXAnimDeltaPart;
XAnimDeltaPart** outXAnimDeltaPartPtr;
XAnimDeltaPart* streamXAnimDeltaPart;
XAnimDeltaPart** streamXAnimDeltaPartPtr;
XAnimParts* varXAnimParts;
XAnimParts** varXAnimPartsPtr;
XAnimParts* outXAnimParts;
XAnimParts** outXAnimPartsPtr;
XAnimParts* streamXAnimParts;
XAnimParts** streamXAnimPartsPtr;
PhysPreset* varPhysPreset;
PhysPreset** varPhysPresetPtr;
PhysPreset* outPhysPreset;
PhysPreset** outPhysPresetPtr;
PhysPreset* streamPhysPreset;
PhysPreset** streamPhysPresetPtr;
PhysGeomInfo* varPhysGeomInfo;
PhysGeomInfo** varPhysGeomInfoPtr;
PhysGeomInfo* outPhysGeomInfo;
PhysGeomInfo** outPhysGeomInfoPtr;
PhysGeomInfo* streamPhysGeomInfo;
PhysGeomInfo** streamPhysGeomInfoPtr;
PhysMass* varPhysMass;
PhysMass** varPhysMassPtr;
PhysMass* outPhysMass;
PhysMass** outPhysMassPtr;
PhysMass* streamPhysMass;
PhysMass** streamPhysMassPtr;
PhysCollmap* varPhysCollmap;
PhysCollmap** varPhysCollmapPtr;
PhysCollmap* outPhysCollmap;
PhysCollmap** outPhysCollmapPtr;
PhysCollmap* streamPhysCollmap;
PhysCollmap** streamPhysCollmapPtr;
GfxDrawSurf* varGfxDrawSurf;
GfxDrawSurf** varGfxDrawSurfPtr;
GfxDrawSurf* outGfxDrawSurf;
GfxDrawSurf** outGfxDrawSurfPtr;
GfxDrawSurf* streamGfxDrawSurf;
GfxDrawSurf** streamGfxDrawSurfPtr;
MaterialInfo* varMaterialInfo;
MaterialInfo** varMaterialInfoPtr;
MaterialInfo* outMaterialInfo;
MaterialInfo** outMaterialInfoPtr;
MaterialInfo* streamMaterialInfo;
MaterialInfo** streamMaterialInfoPtr;
MaterialStreamRouting* varMaterialStreamRouting;
MaterialStreamRouting** varMaterialStreamRoutingPtr;
MaterialStreamRouting* outMaterialStreamRouting;
MaterialStreamRouting** outMaterialStreamRoutingPtr;
MaterialStreamRouting* streamMaterialStreamRouting;
MaterialStreamRouting** streamMaterialStreamRoutingPtr;
MaterialVertexStreamRouting* varMaterialVertexStreamRouting;
MaterialVertexStreamRouting** varMaterialVertexStreamRoutingPtr;
MaterialVertexStreamRouting* outMaterialVertexStreamRouting;
MaterialVertexStreamRouting** outMaterialVertexStreamRoutingPtr;
MaterialVertexStreamRouting* streamMaterialVertexStreamRouting;
MaterialVertexStreamRouting** streamMaterialVertexStreamRoutingPtr;
MaterialVertexDeclaration* varMaterialVertexDeclaration;
MaterialVertexDeclaration** varMaterialVertexDeclarationPtr;
MaterialVertexDeclaration* outMaterialVertexDeclaration;
MaterialVertexDeclaration** outMaterialVertexDeclarationPtr;
MaterialVertexDeclaration* streamMaterialVertexDeclaration;
MaterialVertexDeclaration** streamMaterialVertexDeclarationPtr;
GfxVertexShaderLoadDef* varGfxVertexShaderLoadDef;
GfxVertexShaderLoadDef** varGfxVertexShaderLoadDefPtr;
GfxVertexShaderLoadDef* outGfxVertexShaderLoadDef;
GfxVertexShaderLoadDef** outGfxVertexShaderLoadDefPtr;
GfxVertexShaderLoadDef* streamGfxVertexShaderLoadDef;
GfxVertexShaderLoadDef** streamGfxVertexShaderLoadDefPtr;
MaterialVertexShaderProgram* varMaterialVertexShaderProgram;
MaterialVertexShaderProgram** varMaterialVertexShaderProgramPtr;
MaterialVertexShaderProgram* outMaterialVertexShaderProgram;
MaterialVertexShaderProgram** outMaterialVertexShaderProgramPtr;
MaterialVertexShaderProgram* streamMaterialVertexShaderProgram;
MaterialVertexShaderProgram** streamMaterialVertexShaderProgramPtr;
MaterialVertexShader* varMaterialVertexShader;
MaterialVertexShader** varMaterialVertexShaderPtr;
MaterialVertexShader* outMaterialVertexShader;
MaterialVertexShader** outMaterialVertexShaderPtr;
MaterialVertexShader* streamMaterialVertexShader;
MaterialVertexShader** streamMaterialVertexShaderPtr;
GfxPixelShaderLoadDef* varGfxPixelShaderLoadDef;
GfxPixelShaderLoadDef** varGfxPixelShaderLoadDefPtr;
GfxPixelShaderLoadDef* outGfxPixelShaderLoadDef;
GfxPixelShaderLoadDef** outGfxPixelShaderLoadDefPtr;
GfxPixelShaderLoadDef* streamGfxPixelShaderLoadDef;
GfxPixelShaderLoadDef** streamGfxPixelShaderLoadDefPtr;
MaterialPixelShaderProgram* varMaterialPixelShaderProgram;
MaterialPixelShaderProgram** varMaterialPixelShaderProgramPtr;
MaterialPixelShaderProgram* outMaterialPixelShaderProgram;
MaterialPixelShaderProgram** outMaterialPixelShaderProgramPtr;
MaterialPixelShaderProgram* streamMaterialPixelShaderProgram;
MaterialPixelShaderProgram** streamMaterialPixelShaderProgramPtr;
MaterialPixelShader* varMaterialPixelShader;
MaterialPixelShader** varMaterialPixelShaderPtr;
MaterialPixelShader* outMaterialPixelShader;
MaterialPixelShader** outMaterialPixelShaderPtr;
MaterialPixelShader* streamMaterialPixelShader;
MaterialPixelShader** streamMaterialPixelShaderPtr;
MaterialArgumentCodeConst* varMaterialArgumentCodeConst;
MaterialArgumentCodeConst** varMaterialArgumentCodeConstPtr;
MaterialArgumentCodeConst* outMaterialArgumentCodeConst;
MaterialArgumentCodeConst** outMaterialArgumentCodeConstPtr;
MaterialArgumentCodeConst* streamMaterialArgumentCodeConst;
MaterialArgumentCodeConst** streamMaterialArgumentCodeConstPtr;
MaterialArgumentDef* varMaterialArgumentDef;
MaterialArgumentDef** varMaterialArgumentDefPtr;
MaterialArgumentDef* outMaterialArgumentDef;
MaterialArgumentDef** outMaterialArgumentDefPtr;
MaterialArgumentDef* streamMaterialArgumentDef;
MaterialArgumentDef** streamMaterialArgumentDefPtr;
MaterialShaderArgument* varMaterialShaderArgument;
MaterialShaderArgument** varMaterialShaderArgumentPtr;
MaterialShaderArgument* outMaterialShaderArgument;
MaterialShaderArgument** outMaterialShaderArgumentPtr;
MaterialShaderArgument* streamMaterialShaderArgument;
MaterialShaderArgument** streamMaterialShaderArgumentPtr;
MaterialPass* varMaterialPass;
MaterialPass** varMaterialPassPtr;
MaterialPass* outMaterialPass;
MaterialPass** outMaterialPassPtr;
MaterialPass* streamMaterialPass;
MaterialPass** streamMaterialPassPtr;
MaterialTechnique* varMaterialTechnique;
MaterialTechnique** varMaterialTechniquePtr;
MaterialTechnique* outMaterialTechnique;
MaterialTechnique** outMaterialTechniquePtr;
MaterialTechnique* streamMaterialTechnique;
MaterialTechnique** streamMaterialTechniquePtr;
MaterialTechniqueSet* varMaterialTechniqueSet;
MaterialTechniqueSet** varMaterialTechniqueSetPtr;
MaterialTechniqueSet* outMaterialTechniqueSet;
MaterialTechniqueSet** outMaterialTechniqueSetPtr;
MaterialTechniqueSet* streamMaterialTechniqueSet;
MaterialTechniqueSet** streamMaterialTechniqueSetPtr;
WaterWritable* varWaterWritable;
WaterWritable** varWaterWritablePtr;
WaterWritable* outWaterWritable;
WaterWritable** outWaterWritablePtr;
WaterWritable* streamWaterWritable;
WaterWritable** streamWaterWritablePtr;
complex_s* varcomplex_s;
complex_s** varcomplex_sPtr;
complex_s* outcomplex_s;
complex_s** outcomplex_sPtr;
complex_s* streamcomplex_s;
complex_s** streamcomplex_sPtr;
GfxImageLoadDef* varGfxImageLoadDef;
GfxImageLoadDef** varGfxImageLoadDefPtr;
GfxImageLoadDef* outGfxImageLoadDef;
GfxImageLoadDef** outGfxImageLoadDefPtr;
GfxImageLoadDef* streamGfxImageLoadDef;
GfxImageLoadDef** streamGfxImageLoadDefPtr;
GfxTexture* varGfxTexture;
GfxTexture** varGfxTexturePtr;
GfxTexture* outGfxTexture;
GfxTexture** outGfxTexturePtr;
GfxTexture* streamGfxTexture;
GfxTexture** streamGfxTexturePtr;
Picmip* varPicmip;
Picmip** varPicmipPtr;
Picmip* outPicmip;
Picmip** outPicmipPtr;
Picmip* streamPicmip;
Picmip** streamPicmipPtr;
CardMemory* varCardMemory;
CardMemory** varCardMemoryPtr;
CardMemory* outCardMemory;
CardMemory** outCardMemoryPtr;
CardMemory* streamCardMemory;
CardMemory** streamCardMemoryPtr;
GfxImage* varGfxImage;
GfxImage** varGfxImagePtr;
GfxImage* outGfxImage;
GfxImage** outGfxImagePtr;
GfxImage* streamGfxImage;
GfxImage** streamGfxImagePtr;
water_t* varwater_t;
water_t** varwater_tPtr;
water_t* outwater_t;
water_t** outwater_tPtr;
water_t* streamwater_t;
water_t** streamwater_tPtr;
MaterialTextureDefInfo* varMaterialTextureDefInfo;
MaterialTextureDefInfo** varMaterialTextureDefInfoPtr;
MaterialTextureDefInfo* outMaterialTextureDefInfo;
MaterialTextureDefInfo** outMaterialTextureDefInfoPtr;
MaterialTextureDefInfo* streamMaterialTextureDefInfo;
MaterialTextureDefInfo** streamMaterialTextureDefInfoPtr;
MaterialTextureDef* varMaterialTextureDef;
MaterialTextureDef** varMaterialTextureDefPtr;
MaterialTextureDef* outMaterialTextureDef;
MaterialTextureDef** outMaterialTextureDefPtr;
MaterialTextureDef* streamMaterialTextureDef;
MaterialTextureDef** streamMaterialTextureDefPtr;
MaterialConstantDef* varMaterialConstantDef;
MaterialConstantDef** varMaterialConstantDefPtr;
MaterialConstantDef* outMaterialConstantDef;
MaterialConstantDef** outMaterialConstantDefPtr;
MaterialConstantDef* streamMaterialConstantDef;
MaterialConstantDef** streamMaterialConstantDefPtr;
GfxStateBits* varGfxStateBits;
GfxStateBits** varGfxStateBitsPtr;
GfxStateBits* outGfxStateBits;
GfxStateBits** outGfxStateBitsPtr;
GfxStateBits* streamGfxStateBits;
GfxStateBits** streamGfxStateBitsPtr;
Material* varMaterial;
Material** varMaterialPtr;
Material* outMaterial;
Material** outMaterialPtr;
Material* streamMaterial;
Material** streamMaterialPtr;
XModel* varXModel;
XModel** varXModelPtr;
XModel* outXModel;
XModel** outXModelPtr;
XModel* streamXModel;
XModel** streamXModelPtr;
FxEffectDefRef* varFxEffectDefRef;
FxEffectDefRef** varFxEffectDefRefPtr;
FxEffectDefRef* outFxEffectDefRef;
FxEffectDefRef** outFxEffectDefRefPtr;
FxEffectDefRef* streamFxEffectDefRef;
FxEffectDefRef** streamFxEffectDefRefPtr;
FxElemVisuals* varFxElemVisuals;
FxElemVisuals** varFxElemVisualsPtr;
FxElemVisuals* outFxElemVisuals;
FxElemVisuals** outFxElemVisualsPtr;
FxElemVisuals* streamFxElemVisuals;
FxElemVisuals** streamFxElemVisualsPtr;
FxElemMarkVisuals* varFxElemMarkVisuals;
FxElemMarkVisuals** varFxElemMarkVisualsPtr;
FxElemMarkVisuals* outFxElemMarkVisuals;
FxElemMarkVisuals** outFxElemMarkVisualsPtr;
FxElemMarkVisuals* streamFxElemMarkVisuals;
FxElemMarkVisuals** streamFxElemMarkVisualsPtr;
FxElemDefVisuals* varFxElemDefVisuals;
FxElemDefVisuals** varFxElemDefVisualsPtr;
FxElemDefVisuals* outFxElemDefVisuals;
FxElemDefVisuals** outFxElemDefVisualsPtr;
FxElemDefVisuals* streamFxElemDefVisuals;
FxElemDefVisuals** streamFxElemDefVisualsPtr;
FxTrailVertex* varFxTrailVertex;
FxTrailVertex** varFxTrailVertexPtr;
FxTrailVertex* outFxTrailVertex;
FxTrailVertex** outFxTrailVertexPtr;
FxTrailVertex* streamFxTrailVertex;
FxTrailVertex** streamFxTrailVertexPtr;
FxTrailDef* varFxTrailDef;
FxTrailDef** varFxTrailDefPtr;
FxTrailDef* outFxTrailDef;
FxTrailDef** outFxTrailDefPtr;
FxTrailDef* streamFxTrailDef;
FxTrailDef** streamFxTrailDefPtr;
FxSparkFountainDef* varFxSparkFountainDef;
FxSparkFountainDef** varFxSparkFountainDefPtr;
FxSparkFountainDef* outFxSparkFountainDef;
FxSparkFountainDef** outFxSparkFountainDefPtr;
FxSparkFountainDef* streamFxSparkFountainDef;
FxSparkFountainDef** streamFxSparkFountainDefPtr;
FxElemExtendedDefPtr* varFxElemExtendedDefPtr;
FxElemExtendedDefPtr** varFxElemExtendedDefPtrPtr;
FxElemExtendedDefPtr* outFxElemExtendedDefPtr;
FxElemExtendedDefPtr** outFxElemExtendedDefPtrPtr;
FxElemExtendedDefPtr* streamFxElemExtendedDefPtr;
FxElemExtendedDefPtr** streamFxElemExtendedDefPtrPtr;
FxElemVec3Range* varFxElemVec3Range;
FxElemVec3Range** varFxElemVec3RangePtr;
FxElemVec3Range* outFxElemVec3Range;
FxElemVec3Range** outFxElemVec3RangePtr;
FxElemVec3Range* streamFxElemVec3Range;
FxElemVec3Range** streamFxElemVec3RangePtr;
FxIntRange* varFxIntRange;
FxIntRange** varFxIntRangePtr;
FxIntRange* outFxIntRange;
FxIntRange** outFxIntRangePtr;
FxIntRange* streamFxIntRange;
FxIntRange** streamFxIntRangePtr;
FxSpawnDefOneShot* varFxSpawnDefOneShot;
FxSpawnDefOneShot** varFxSpawnDefOneShotPtr;
FxSpawnDefOneShot* outFxSpawnDefOneShot;
FxSpawnDefOneShot** outFxSpawnDefOneShotPtr;
FxSpawnDefOneShot* streamFxSpawnDefOneShot;
FxSpawnDefOneShot** streamFxSpawnDefOneShotPtr;
FxSpawnDefLooping* varFxSpawnDefLooping;
FxSpawnDefLooping** varFxSpawnDefLoopingPtr;
FxSpawnDefLooping* outFxSpawnDefLooping;
FxSpawnDefLooping** outFxSpawnDefLoopingPtr;
FxSpawnDefLooping* streamFxSpawnDefLooping;
FxSpawnDefLooping** streamFxSpawnDefLoopingPtr;
FxSpawnDef* varFxSpawnDef;
FxSpawnDef** varFxSpawnDefPtr;
FxSpawnDef* outFxSpawnDef;
FxSpawnDef** outFxSpawnDefPtr;
FxSpawnDef* streamFxSpawnDef;
FxSpawnDef** streamFxSpawnDefPtr;
FxFloatRange* varFxFloatRange;
FxFloatRange** varFxFloatRangePtr;
FxFloatRange* outFxFloatRange;
FxFloatRange** outFxFloatRangePtr;
FxFloatRange* streamFxFloatRange;
FxFloatRange** streamFxFloatRangePtr;
FxElemAtlas* varFxElemAtlas;
FxElemAtlas** varFxElemAtlasPtr;
FxElemAtlas* outFxElemAtlas;
FxElemAtlas** outFxElemAtlasPtr;
FxElemAtlas* streamFxElemAtlas;
FxElemAtlas** streamFxElemAtlasPtr;
FxElemVelStateInFrame* varFxElemVelStateInFrame;
FxElemVelStateInFrame** varFxElemVelStateInFramePtr;
FxElemVelStateInFrame* outFxElemVelStateInFrame;
FxElemVelStateInFrame** outFxElemVelStateInFramePtr;
FxElemVelStateInFrame* streamFxElemVelStateInFrame;
FxElemVelStateInFrame** streamFxElemVelStateInFramePtr;
FxElemVelStateSample* varFxElemVelStateSample;
FxElemVelStateSample** varFxElemVelStateSamplePtr;
FxElemVelStateSample* outFxElemVelStateSample;
FxElemVelStateSample** outFxElemVelStateSamplePtr;
FxElemVelStateSample* streamFxElemVelStateSample;
FxElemVelStateSample** streamFxElemVelStateSamplePtr;
FxElemVisualState* varFxElemVisualState;
FxElemVisualState** varFxElemVisualStatePtr;
FxElemVisualState* outFxElemVisualState;
FxElemVisualState** outFxElemVisualStatePtr;
FxElemVisualState* streamFxElemVisualState;
FxElemVisualState** streamFxElemVisualStatePtr;
FxElemVisStateSample* varFxElemVisStateSample;
FxElemVisStateSample** varFxElemVisStateSamplePtr;
FxElemVisStateSample* outFxElemVisStateSample;
FxElemVisStateSample** outFxElemVisStateSamplePtr;
FxElemVisStateSample* streamFxElemVisStateSample;
FxElemVisStateSample** streamFxElemVisStateSamplePtr;
FxElemDef* varFxElemDef;
FxElemDef** varFxElemDefPtr;
FxElemDef* outFxElemDef;
FxElemDef** outFxElemDefPtr;
FxElemDef* streamFxElemDef;
FxElemDef** streamFxElemDefPtr;
FxEffectDef* varFxEffectDef;
FxEffectDef** varFxEffectDefPtr;
FxEffectDef* outFxEffectDef;
FxEffectDef** outFxEffectDefPtr;
FxEffectDef* streamFxEffectDef;
FxEffectDef** streamFxEffectDefPtr;
cLeafBrushNodeLeaf_t* varcLeafBrushNodeLeaf_t;
cLeafBrushNodeLeaf_t** varcLeafBrushNodeLeaf_tPtr;
cLeafBrushNodeLeaf_t* outcLeafBrushNodeLeaf_t;
cLeafBrushNodeLeaf_t** outcLeafBrushNodeLeaf_tPtr;
cLeafBrushNodeLeaf_t* streamcLeafBrushNodeLeaf_t;
cLeafBrushNodeLeaf_t** streamcLeafBrushNodeLeaf_tPtr;
cLeafBrushNodeChildren_t* varcLeafBrushNodeChildren_t;
cLeafBrushNodeChildren_t** varcLeafBrushNodeChildren_tPtr;
cLeafBrushNodeChildren_t* outcLeafBrushNodeChildren_t;
cLeafBrushNodeChildren_t** outcLeafBrushNodeChildren_tPtr;
cLeafBrushNodeChildren_t* streamcLeafBrushNodeChildren_t;
cLeafBrushNodeChildren_t** streamcLeafBrushNodeChildren_tPtr;
cLeafBrushNodeData_t* varcLeafBrushNodeData_t;
cLeafBrushNodeData_t** varcLeafBrushNodeData_tPtr;
cLeafBrushNodeData_t* outcLeafBrushNodeData_t;
cLeafBrushNodeData_t** outcLeafBrushNodeData_tPtr;
cLeafBrushNodeData_t* streamcLeafBrushNodeData_t;
cLeafBrushNodeData_t** streamcLeafBrushNodeData_tPtr;
cLeafBrushNode_s* varcLeafBrushNode_s;
cLeafBrushNode_s** varcLeafBrushNode_sPtr;
cLeafBrushNode_s* outcLeafBrushNode_s;
cLeafBrushNode_s** outcLeafBrushNode_sPtr;
cLeafBrushNode_s* streamcLeafBrushNode_s;
cLeafBrushNode_s** streamcLeafBrushNode_sPtr;
ClipMaterial* varClipMaterial;
ClipMaterial** varClipMaterialPtr;
ClipMaterial* outClipMaterial;
ClipMaterial** outClipMaterialPtr;
ClipMaterial* streamClipMaterial;
ClipMaterial** streamClipMaterialPtr;
cStaticModel_s* varcStaticModel_s;
cStaticModel_s** varcStaticModel_sPtr;
cStaticModel_s* outcStaticModel_s;
cStaticModel_s** outcStaticModel_sPtr;
cStaticModel_s* streamcStaticModel_s;
cStaticModel_s** streamcStaticModel_sPtr;
CollisionBorder* varCollisionBorder;
CollisionBorder** varCollisionBorderPtr;
CollisionBorder* outCollisionBorder;
CollisionBorder** outCollisionBorderPtr;
CollisionBorder* streamCollisionBorder;
CollisionBorder** streamCollisionBorderPtr;
CollisionPartition* varCollisionPartition;
CollisionPartition** varCollisionPartitionPtr;
CollisionPartition* outCollisionPartition;
CollisionPartition** outCollisionPartitionPtr;
CollisionPartition* streamCollisionPartition;
CollisionPartition** streamCollisionPartitionPtr;
CollisionAabbTreeIndex* varCollisionAabbTreeIndex;
CollisionAabbTreeIndex** varCollisionAabbTreeIndexPtr;
CollisionAabbTreeIndex* outCollisionAabbTreeIndex;
CollisionAabbTreeIndex** outCollisionAabbTreeIndexPtr;
CollisionAabbTreeIndex* streamCollisionAabbTreeIndex;
CollisionAabbTreeIndex** streamCollisionAabbTreeIndexPtr;
CollisionAabbTree* varCollisionAabbTree;
CollisionAabbTree** varCollisionAabbTreePtr;
CollisionAabbTree* outCollisionAabbTree;
CollisionAabbTree** outCollisionAabbTreePtr;
CollisionAabbTree* streamCollisionAabbTree;
CollisionAabbTree** streamCollisionAabbTreePtr;
cLeaf_t* varcLeaf_t;
cLeaf_t** varcLeaf_tPtr;
cLeaf_t* outcLeaf_t;
cLeaf_t** outcLeaf_tPtr;
cLeaf_t* streamcLeaf_t;
cLeaf_t** streamcLeaf_tPtr;
cmodel_t* varcmodel_t;
cmodel_t** varcmodel_tPtr;
cmodel_t* outcmodel_t;
cmodel_t** outcmodel_tPtr;
cmodel_t* streamcmodel_t;
cmodel_t** streamcmodel_tPtr;
TriggerModel* varTriggerModel;
TriggerModel** varTriggerModelPtr;
TriggerModel* outTriggerModel;
TriggerModel** outTriggerModelPtr;
TriggerModel* streamTriggerModel;
TriggerModel** streamTriggerModelPtr;
TriggerSlab* varTriggerSlab;
TriggerSlab** varTriggerSlabPtr;
TriggerSlab* outTriggerSlab;
TriggerSlab** outTriggerSlabPtr;
TriggerSlab* streamTriggerSlab;
TriggerSlab** streamTriggerSlabPtr;
TriggerHull* varTriggerHull;
TriggerHull** varTriggerHullPtr;
TriggerHull* outTriggerHull;
TriggerHull** outTriggerHullPtr;
TriggerHull* streamTriggerHull;
TriggerHull** streamTriggerHullPtr;
MapTriggers* varMapTriggers;
MapTriggers** varMapTriggersPtr;
MapTriggers* outMapTriggers;
MapTriggers** outMapTriggersPtr;
MapTriggers* streamMapTriggers;
MapTriggers** streamMapTriggersPtr;
Stage* varStage;
Stage** varStagePtr;
Stage* outStage;
Stage** outStagePtr;
Stage* streamStage;
Stage** streamStagePtr;
MapEnts* varMapEnts;
MapEnts** varMapEntsPtr;
MapEnts* outMapEnts;
MapEnts** outMapEntsPtr;
MapEnts* streamMapEnts;
MapEnts** streamMapEntsPtr;
SModelAabbNode* varSModelAabbNode;
SModelAabbNode** varSModelAabbNodePtr;
SModelAabbNode* outSModelAabbNode;
SModelAabbNode** outSModelAabbNodePtr;
SModelAabbNode* streamSModelAabbNode;
SModelAabbNode** streamSModelAabbNodePtr;
GfxPlacement* varGfxPlacement;
GfxPlacement** varGfxPlacementPtr;
GfxPlacement* outGfxPlacement;
GfxPlacement** outGfxPlacementPtr;
GfxPlacement* streamGfxPlacement;
GfxPlacement** streamGfxPlacementPtr;
DynEntityType* varDynEntityType;
DynEntityType** varDynEntityTypePtr;
DynEntityType* outDynEntityType;
DynEntityType** outDynEntityTypePtr;
DynEntityType* streamDynEntityType;
DynEntityType** streamDynEntityTypePtr;
DynEntityDef* varDynEntityDef;
DynEntityDef** varDynEntityDefPtr;
DynEntityDef* outDynEntityDef;
DynEntityDef** outDynEntityDefPtr;
DynEntityDef* streamDynEntityDef;
DynEntityDef** streamDynEntityDefPtr;
DynEntityPose* varDynEntityPose;
DynEntityPose** varDynEntityPosePtr;
DynEntityPose* outDynEntityPose;
DynEntityPose** outDynEntityPosePtr;
DynEntityPose* streamDynEntityPose;
DynEntityPose** streamDynEntityPosePtr;
DynEntityClient* varDynEntityClient;
DynEntityClient** varDynEntityClientPtr;
DynEntityClient* outDynEntityClient;
DynEntityClient** outDynEntityClientPtr;
DynEntityClient* streamDynEntityClient;
DynEntityClient** streamDynEntityClientPtr;
DynEntityColl* varDynEntityColl;
DynEntityColl** varDynEntityCollPtr;
DynEntityColl* outDynEntityColl;
DynEntityColl** outDynEntityCollPtr;
DynEntityColl* streamDynEntityColl;
DynEntityColl** streamDynEntityCollPtr;
cbrushside_t* varcbrushside_t;
cbrushside_t** varcbrushside_tPtr;
cbrushside_t* outcbrushside_t;
cbrushside_t** outcbrushside_tPtr;
cbrushside_t* streamcbrushside_t;
cbrushside_t** streamcbrushside_tPtr;
cNode_t* varcNode_t;
cNode_t** varcNode_tPtr;
cNode_t* outcNode_t;
cNode_t** outcNode_tPtr;
cNode_t* streamcNode_t;
cNode_t** streamcNode_tPtr;
clipMap_t* varclipMap_t;
clipMap_t** varclipMap_tPtr;
clipMap_t* outclipMap_t;
clipMap_t** outclipMap_tPtr;
clipMap_t* streamclipMap_t;
clipMap_t** streamclipMap_tPtr;
RawFile* varRawFile;
RawFile** varRawFilePtr;
RawFile* outRawFile;
RawFile** outRawFilePtr;
RawFile* streamRawFile;
RawFile** streamRawFilePtr;
TracerDef* varTracerDef;
TracerDef** varTracerDefPtr;
TracerDef* outTracerDef;
TracerDef** outTracerDefPtr;
TracerDef* streamTracerDef;
TracerDef** streamTracerDefPtr;
MSSSpeakerLevels* varMSSSpeakerLevels;
MSSSpeakerLevels** varMSSSpeakerLevelsPtr;
MSSSpeakerLevels* outMSSSpeakerLevels;
MSSSpeakerLevels** outMSSSpeakerLevelsPtr;
MSSSpeakerLevels* streamMSSSpeakerLevels;
MSSSpeakerLevels** streamMSSSpeakerLevelsPtr;
MSSChannelMap* varMSSChannelMap;
MSSChannelMap** varMSSChannelMapPtr;
MSSChannelMap* outMSSChannelMap;
MSSChannelMap** outMSSChannelMapPtr;
MSSChannelMap* streamMSSChannelMap;
MSSChannelMap** streamMSSChannelMapPtr;
SpeakerMap* varSpeakerMap;
SpeakerMap** varSpeakerMapPtr;
SpeakerMap* outSpeakerMap;
SpeakerMap** outSpeakerMapPtr;
SpeakerMap* streamSpeakerMap;
SpeakerMap** streamSpeakerMapPtr;
_AILSOUNDINFO* var_AILSOUNDINFO;
_AILSOUNDINFO** var_AILSOUNDINFOPtr;
_AILSOUNDINFO* out_AILSOUNDINFO;
_AILSOUNDINFO** out_AILSOUNDINFOPtr;
_AILSOUNDINFO* stream_AILSOUNDINFO;
_AILSOUNDINFO** stream_AILSOUNDINFOPtr;
MssSound* varMssSound;
MssSound** varMssSoundPtr;
MssSound* outMssSound;
MssSound** outMssSoundPtr;
MssSound* streamMssSound;
MssSound** streamMssSoundPtr;
LoadedSound* varLoadedSound;
LoadedSound** varLoadedSoundPtr;
LoadedSound* outLoadedSound;
LoadedSound** outLoadedSoundPtr;
LoadedSound* streamLoadedSound;
LoadedSound** streamLoadedSoundPtr;
StreamFileNameRaw* varStreamFileNameRaw;
StreamFileNameRaw** varStreamFileNameRawPtr;
StreamFileNameRaw* outStreamFileNameRaw;
StreamFileNameRaw** outStreamFileNameRawPtr;
StreamFileNameRaw* streamStreamFileNameRaw;
StreamFileNameRaw** streamStreamFileNameRawPtr;
StreamFileInfo* varStreamFileInfo;
StreamFileInfo** varStreamFileInfoPtr;
StreamFileInfo* outStreamFileInfo;
StreamFileInfo** outStreamFileInfoPtr;
StreamFileInfo* streamStreamFileInfo;
StreamFileInfo** streamStreamFileInfoPtr;
StreamFileName* varStreamFileName;
StreamFileName** varStreamFileNamePtr;
StreamFileName* outStreamFileName;
StreamFileName** outStreamFileNamePtr;
StreamFileName* streamStreamFileName;
StreamFileName** streamStreamFileNamePtr;
StreamedSound* varStreamedSound;
StreamedSound** varStreamedSoundPtr;
StreamedSound* outStreamedSound;
StreamedSound** outStreamedSoundPtr;
StreamedSound* streamStreamedSound;
StreamedSound** streamStreamedSoundPtr;
SoundFileRef* varSoundFileRef;
SoundFileRef** varSoundFileRefPtr;
SoundFileRef* outSoundFileRef;
SoundFileRef** outSoundFileRefPtr;
SoundFileRef* streamSoundFileRef;
SoundFileRef** streamSoundFileRefPtr;
SoundFile* varSoundFile;
SoundFile** varSoundFilePtr;
SoundFile* outSoundFile;
SoundFile** outSoundFilePtr;
SoundFile* streamSoundFile;
SoundFile** streamSoundFilePtr;
SndCurve* varSndCurve;
SndCurve** varSndCurvePtr;
SndCurve* outSndCurve;
SndCurve** outSndCurvePtr;
SndCurve* streamSndCurve;
SndCurve** streamSndCurvePtr;
$C8D87EB0090687D323381DFB7A82089C* var$C8D87EB0090687D323381DFB7A82089C;
$C8D87EB0090687D323381DFB7A82089C** var$C8D87EB0090687D323381DFB7A82089CPtr;
$C8D87EB0090687D323381DFB7A82089C* out$C8D87EB0090687D323381DFB7A82089C;
$C8D87EB0090687D323381DFB7A82089C** out$C8D87EB0090687D323381DFB7A82089CPtr;
$C8D87EB0090687D323381DFB7A82089C* stream$C8D87EB0090687D323381DFB7A82089C;
$C8D87EB0090687D323381DFB7A82089C** stream$C8D87EB0090687D323381DFB7A82089CPtr;
snd_alias_t* varsnd_alias_t;
snd_alias_t** varsnd_alias_tPtr;
snd_alias_t* outsnd_alias_t;
snd_alias_t** outsnd_alias_tPtr;
snd_alias_t* streamsnd_alias_t;
snd_alias_t** streamsnd_alias_tPtr;
snd_alias_list_t* varsnd_alias_list_t;
snd_alias_list_t** varsnd_alias_list_tPtr;
snd_alias_list_t* outsnd_alias_list_t;
snd_alias_list_t** outsnd_alias_list_tPtr;
snd_alias_list_t* streamsnd_alias_list_t;
snd_alias_list_t** streamsnd_alias_list_tPtr;
StringTableCell* varStringTableCell;
StringTableCell** varStringTableCellPtr;
StringTableCell* outStringTableCell;
StringTableCell** outStringTableCellPtr;
StringTableCell* streamStringTableCell;
StringTableCell** streamStringTableCellPtr;
StringTable* varStringTable;
StringTable** varStringTablePtr;
StringTable* outStringTable;
StringTable** outStringTablePtr;
StringTable* streamStringTable;
StringTable** streamStringTablePtr;
SndDriverGlobals* varSndDriverGlobals;
SndDriverGlobals** varSndDriverGlobalsPtr;
SndDriverGlobals* outSndDriverGlobals;
SndDriverGlobals** outSndDriverGlobalsPtr;
SndDriverGlobals* streamSndDriverGlobals;
SndDriverGlobals** streamSndDriverGlobalsPtr;
menuDef_t* varmenuDef_t;
menuDef_t** varmenuDef_tPtr;
menuDef_t* outmenuDef_t;
menuDef_t** outmenuDef_tPtr;
menuDef_t* streammenuDef_t;
menuDef_t** streammenuDef_tPtr;
MenuEventHandlerSet* varMenuEventHandlerSet;
MenuEventHandlerSet** varMenuEventHandlerSetPtr;
MenuEventHandlerSet* outMenuEventHandlerSet;
MenuEventHandlerSet** outMenuEventHandlerSetPtr;
MenuEventHandlerSet* streamMenuEventHandlerSet;
MenuEventHandlerSet** streamMenuEventHandlerSetPtr;
Statement_s* varStatement_s;
Statement_s** varStatement_sPtr;
Statement_s* outStatement_s;
Statement_s** outStatement_sPtr;
Statement_s* streamStatement_s;
Statement_s** streamStatement_sPtr;
ExpressionSupportingData* varExpressionSupportingData;
ExpressionSupportingData** varExpressionSupportingDataPtr;
ExpressionSupportingData* outExpressionSupportingData;
ExpressionSupportingData** outExpressionSupportingDataPtr;
ExpressionSupportingData* streamExpressionSupportingData;
ExpressionSupportingData** streamExpressionSupportingDataPtr;
columnInfo_s* varcolumnInfo_s;
columnInfo_s** varcolumnInfo_sPtr;
columnInfo_s* outcolumnInfo_s;
columnInfo_s** outcolumnInfo_sPtr;
columnInfo_s* streamcolumnInfo_s;
columnInfo_s** streamcolumnInfo_sPtr;
listBoxDef_s* varlistBoxDef_s;
listBoxDef_s** varlistBoxDef_sPtr;
listBoxDef_s* outlistBoxDef_s;
listBoxDef_s** outlistBoxDef_sPtr;
listBoxDef_s* streamlistBoxDef_s;
listBoxDef_s** streamlistBoxDef_sPtr;
editFieldDef_s* vareditFieldDef_s;
editFieldDef_s** vareditFieldDef_sPtr;
editFieldDef_s* outeditFieldDef_s;
editFieldDef_s** outeditFieldDef_sPtr;
editFieldDef_s* streameditFieldDef_s;
editFieldDef_s** streameditFieldDef_sPtr;
multiDef_s* varmultiDef_s;
multiDef_s** varmultiDef_sPtr;
multiDef_s* outmultiDef_s;
multiDef_s** outmultiDef_sPtr;
multiDef_s* streammultiDef_s;
multiDef_s** streammultiDef_sPtr;
newsTickerDef_s* varnewsTickerDef_s;
newsTickerDef_s** varnewsTickerDef_sPtr;
newsTickerDef_s* outnewsTickerDef_s;
newsTickerDef_s** outnewsTickerDef_sPtr;
newsTickerDef_s* streamnewsTickerDef_s;
newsTickerDef_s** streamnewsTickerDef_sPtr;
textScrollDef_s* vartextScrollDef_s;
textScrollDef_s** vartextScrollDef_sPtr;
textScrollDef_s* outtextScrollDef_s;
textScrollDef_s** outtextScrollDef_sPtr;
textScrollDef_s* streamtextScrollDef_s;
textScrollDef_s** streamtextScrollDef_sPtr;
itemDefData_t* varitemDefData_t;
itemDefData_t** varitemDefData_tPtr;
itemDefData_t* outitemDefData_t;
itemDefData_t** outitemDefData_tPtr;
itemDefData_t* streamitemDefData_t;
itemDefData_t** streamitemDefData_tPtr;
ExpressionString* varExpressionString;
ExpressionString** varExpressionStringPtr;
ExpressionString* outExpressionString;
ExpressionString** outExpressionStringPtr;
ExpressionString* streamExpressionString;
ExpressionString** streamExpressionStringPtr;
operandInternalDataUnion* varoperandInternalDataUnion;
operandInternalDataUnion** varoperandInternalDataUnionPtr;
operandInternalDataUnion* outoperandInternalDataUnion;
operandInternalDataUnion** outoperandInternalDataUnionPtr;
operandInternalDataUnion* streamoperandInternalDataUnion;
operandInternalDataUnion** streamoperandInternalDataUnionPtr;
expDataType* varexpDataType;
expDataType** varexpDataTypePtr;
expDataType* outexpDataType;
expDataType** outexpDataTypePtr;
expDataType* streamexpDataType;
expDataType** streamexpDataTypePtr;
Operand* varOperand;
Operand** varOperandPtr;
Operand* outOperand;
Operand** outOperandPtr;
Operand* streamOperand;
Operand** streamOperandPtr;
entryInternalData* varentryInternalData;
entryInternalData** varentryInternalDataPtr;
entryInternalData* outentryInternalData;
entryInternalData** outentryInternalDataPtr;
entryInternalData* streamentryInternalData;
entryInternalData** streamentryInternalDataPtr;
expressionEntry* varexpressionEntry;
expressionEntry** varexpressionEntryPtr;
expressionEntry* outexpressionEntry;
expressionEntry** outexpressionEntryPtr;
expressionEntry* streamexpressionEntry;
expressionEntry** streamexpressionEntryPtr;
UIFunctionList* varUIFunctionList;
UIFunctionList** varUIFunctionListPtr;
UIFunctionList* outUIFunctionList;
UIFunctionList** outUIFunctionListPtr;
UIFunctionList* streamUIFunctionList;
UIFunctionList** streamUIFunctionListPtr;
StringList* varStringList;
StringList** varStringListPtr;
StringList* outStringList;
StringList** outStringListPtr;
StringList* streamStringList;
StringList** streamStringListPtr;
StaticDvar* varStaticDvar;
StaticDvar** varStaticDvarPtr;
StaticDvar* outStaticDvar;
StaticDvar** outStaticDvarPtr;
StaticDvar* streamStaticDvar;
StaticDvar** streamStaticDvarPtr;
StaticDvarList* varStaticDvarList;
StaticDvarList** varStaticDvarListPtr;
StaticDvarList* outStaticDvarList;
StaticDvarList** outStaticDvarListPtr;
StaticDvarList* streamStaticDvarList;
StaticDvarList** streamStaticDvarListPtr;
ConditionalScript* varConditionalScript;
ConditionalScript** varConditionalScriptPtr;
ConditionalScript* outConditionalScript;
ConditionalScript** outConditionalScriptPtr;
ConditionalScript* streamConditionalScript;
ConditionalScript** streamConditionalScriptPtr;
SetLocalVarData* varSetLocalVarData;
SetLocalVarData** varSetLocalVarDataPtr;
SetLocalVarData* outSetLocalVarData;
SetLocalVarData** outSetLocalVarDataPtr;
SetLocalVarData* streamSetLocalVarData;
SetLocalVarData** streamSetLocalVarDataPtr;
EventData* varEventData;
EventData** varEventDataPtr;
EventData* outEventData;
EventData** outEventDataPtr;
EventData* streamEventData;
EventData** streamEventDataPtr;
EventType* varEventType;
EventType** varEventTypePtr;
EventType* outEventType;
EventType** outEventTypePtr;
EventType* streamEventType;
EventType** streamEventTypePtr;
MenuEventHandler* varMenuEventHandler;
MenuEventHandler** varMenuEventHandlerPtr;
MenuEventHandler* outMenuEventHandler;
MenuEventHandler** outMenuEventHandlerPtr;
MenuEventHandler* streamMenuEventHandler;
MenuEventHandler** streamMenuEventHandlerPtr;
ItemKeyHandler* varItemKeyHandler;
ItemKeyHandler** varItemKeyHandlerPtr;
ItemKeyHandler* outItemKeyHandler;
ItemKeyHandler** outItemKeyHandlerPtr;
ItemKeyHandler* streamItemKeyHandler;
ItemKeyHandler** streamItemKeyHandlerPtr;
ItemFloatExpression* varItemFloatExpression;
ItemFloatExpression** varItemFloatExpressionPtr;
ItemFloatExpression* outItemFloatExpression;
ItemFloatExpression** outItemFloatExpressionPtr;
ItemFloatExpression* streamItemFloatExpression;
ItemFloatExpression** streamItemFloatExpressionPtr;
menuTransition* varmenuTransition;
menuTransition** varmenuTransitionPtr;
menuTransition* outmenuTransition;
menuTransition** outmenuTransitionPtr;
menuTransition* streammenuTransition;
menuTransition** streammenuTransitionPtr;
rectDef_s* varrectDef_s;
rectDef_s** varrectDef_sPtr;
rectDef_s* outrectDef_s;
rectDef_s** outrectDef_sPtr;
rectDef_s* streamrectDef_s;
rectDef_s** streamrectDef_sPtr;
windowDef_t* varwindowDef_t;
windowDef_t** varwindowDef_tPtr;
windowDef_t* outwindowDef_t;
windowDef_t** outwindowDef_tPtr;
windowDef_t* streamwindowDef_t;
windowDef_t** streamwindowDef_tPtr;
itemDef_s* varitemDef_s;
itemDef_s** varitemDef_sPtr;
itemDef_s* outitemDef_s;
itemDef_s** outitemDef_sPtr;
itemDef_s* streamitemDef_s;
itemDef_s** streamitemDef_sPtr;
MenuList* varMenuList;
MenuList** varMenuListPtr;
MenuList* outMenuList;
MenuList** outMenuListPtr;
MenuList* streamMenuList;
MenuList** streamMenuListPtr;
ComPrimaryLight* varComPrimaryLight;
ComPrimaryLight** varComPrimaryLightPtr;
ComPrimaryLight* outComPrimaryLight;
ComPrimaryLight** outComPrimaryLightPtr;
ComPrimaryLight* streamComPrimaryLight;
ComPrimaryLight** streamComPrimaryLightPtr;
ComWorld* varComWorld;
ComWorld** varComWorldPtr;
ComWorld* outComWorld;
ComWorld** outComWorldPtr;
ComWorld* streamComWorld;
ComWorld** streamComWorldPtr;
LocalizeEntry* varLocalizeEntry;
LocalizeEntry** varLocalizeEntryPtr;
LocalizeEntry* outLocalizeEntry;
LocalizeEntry** outLocalizeEntryPtr;
LocalizeEntry* streamLocalizeEntry;
LocalizeEntry** streamLocalizeEntryPtr;
G_GlassPiece* varG_GlassPiece;
G_GlassPiece** varG_GlassPiecePtr;
G_GlassPiece* outG_GlassPiece;
G_GlassPiece** outG_GlassPiecePtr;
G_GlassPiece* streamG_GlassPiece;
G_GlassPiece** streamG_GlassPiecePtr;
G_GlassName* varG_GlassName;
G_GlassName** varG_GlassNamePtr;
G_GlassName* outG_GlassName;
G_GlassName** outG_GlassNamePtr;
G_GlassName* streamG_GlassName;
G_GlassName** streamG_GlassNamePtr;
G_GlassData* varG_GlassData;
G_GlassData** varG_GlassDataPtr;
G_GlassData* outG_GlassData;
G_GlassData** outG_GlassDataPtr;
G_GlassData* streamG_GlassData;
G_GlassData** streamG_GlassDataPtr;
GameWorldMp* varGameWorldMp;
GameWorldMp** varGameWorldMpPtr;
GameWorldMp* outGameWorldMp;
GameWorldMp** outGameWorldMpPtr;
GameWorldMp* streamGameWorldMp;
GameWorldMp** streamGameWorldMpPtr;
FxGlassPieceState* varFxGlassPieceState;
FxGlassPieceState** varFxGlassPieceStatePtr;
FxGlassPieceState* outFxGlassPieceState;
FxGlassPieceState** outFxGlassPieceStatePtr;
FxGlassPieceState* streamFxGlassPieceState;
FxGlassPieceState** streamFxGlassPieceStatePtr;
FxGlassPieceDynamics* varFxGlassPieceDynamics;
FxGlassPieceDynamics** varFxGlassPieceDynamicsPtr;
FxGlassPieceDynamics* outFxGlassPieceDynamics;
FxGlassPieceDynamics** outFxGlassPieceDynamicsPtr;
FxGlassPieceDynamics* streamFxGlassPieceDynamics;
FxGlassPieceDynamics** streamFxGlassPieceDynamicsPtr;
FxGlassVertex* varFxGlassVertex;
FxGlassVertex** varFxGlassVertexPtr;
FxGlassVertex* outFxGlassVertex;
FxGlassVertex** outFxGlassVertexPtr;
FxGlassVertex* streamFxGlassVertex;
FxGlassVertex** streamFxGlassVertexPtr;
FxGlassHoleHeader* varFxGlassHoleHeader;
FxGlassHoleHeader** varFxGlassHoleHeaderPtr;
FxGlassHoleHeader* outFxGlassHoleHeader;
FxGlassHoleHeader** outFxGlassHoleHeaderPtr;
FxGlassHoleHeader* streamFxGlassHoleHeader;
FxGlassHoleHeader** streamFxGlassHoleHeaderPtr;
FxGlassCrackHeader* varFxGlassCrackHeader;
FxGlassCrackHeader** varFxGlassCrackHeaderPtr;
FxGlassCrackHeader* outFxGlassCrackHeader;
FxGlassCrackHeader** outFxGlassCrackHeaderPtr;
FxGlassCrackHeader* streamFxGlassCrackHeader;
FxGlassCrackHeader** streamFxGlassCrackHeaderPtr;
FxGlassGeometryData* varFxGlassGeometryData;
FxGlassGeometryData** varFxGlassGeometryDataPtr;
FxGlassGeometryData* outFxGlassGeometryData;
FxGlassGeometryData** outFxGlassGeometryDataPtr;
FxGlassGeometryData* streamFxGlassGeometryData;
FxGlassGeometryData** streamFxGlassGeometryDataPtr;
FxGlassDef* varFxGlassDef;
FxGlassDef** varFxGlassDefPtr;
FxGlassDef* outFxGlassDef;
FxGlassDef** outFxGlassDefPtr;
FxGlassDef* streamFxGlassDef;
FxGlassDef** streamFxGlassDefPtr;
FxSpatialFrame* varFxSpatialFrame;
FxSpatialFrame** varFxSpatialFramePtr;
FxSpatialFrame* outFxSpatialFrame;
FxSpatialFrame** outFxSpatialFramePtr;
FxSpatialFrame* streamFxSpatialFrame;
FxSpatialFrame** streamFxSpatialFramePtr;
$E43DBA5037697D705289B74D87E76C70* var$E43DBA5037697D705289B74D87E76C70;
$E43DBA5037697D705289B74D87E76C70** var$E43DBA5037697D705289B74D87E76C70Ptr;
$E43DBA5037697D705289B74D87E76C70* out$E43DBA5037697D705289B74D87E76C70;
$E43DBA5037697D705289B74D87E76C70** out$E43DBA5037697D705289B74D87E76C70Ptr;
$E43DBA5037697D705289B74D87E76C70* stream$E43DBA5037697D705289B74D87E76C70;
$E43DBA5037697D705289B74D87E76C70** stream$E43DBA5037697D705289B74D87E76C70Ptr;
FxGlassPiecePlace* varFxGlassPiecePlace;
FxGlassPiecePlace** varFxGlassPiecePlacePtr;
FxGlassPiecePlace* outFxGlassPiecePlace;
FxGlassPiecePlace** outFxGlassPiecePlacePtr;
FxGlassPiecePlace* streamFxGlassPiecePlace;
FxGlassPiecePlace** streamFxGlassPiecePlacePtr;
FxGlassInitPieceState* varFxGlassInitPieceState;
FxGlassInitPieceState** varFxGlassInitPieceStatePtr;
FxGlassInitPieceState* outFxGlassInitPieceState;
FxGlassInitPieceState** outFxGlassInitPieceStatePtr;
FxGlassInitPieceState* streamFxGlassInitPieceState;
FxGlassInitPieceState** streamFxGlassInitPieceStatePtr;
char16* varchar16;
char16** varchar16Ptr;
char16* outchar16;
char16** outchar16Ptr;
char16* streamchar16;
char16** streamchar16Ptr;
float16* varfloat16;
float16** varfloat16Ptr;
float16* outfloat16;
float16** outfloat16Ptr;
float16* streamfloat16;
float16** streamfloat16Ptr;
FxGlassSystem* varFxGlassSystem;
FxGlassSystem** varFxGlassSystemPtr;
FxGlassSystem* outFxGlassSystem;
FxGlassSystem** outFxGlassSystemPtr;
FxGlassSystem* streamFxGlassSystem;
FxGlassSystem** streamFxGlassSystemPtr;
FxWorld* varFxWorld;
FxWorld** varFxWorldPtr;
FxWorld* outFxWorld;
FxWorld** outFxWorldPtr;
FxWorld* streamFxWorld;
FxWorld** streamFxWorldPtr;
GfxLightImage* varGfxLightImage;
GfxLightImage** varGfxLightImagePtr;
GfxLightImage* outGfxLightImage;
GfxLightImage** outGfxLightImagePtr;
GfxLightImage* streamGfxLightImage;
GfxLightImage** streamGfxLightImagePtr;
GfxLightDef* varGfxLightDef;
GfxLightDef** varGfxLightDefPtr;
GfxLightDef* outGfxLightDef;
GfxLightDef** outGfxLightDefPtr;
GfxLightDef* streamGfxLightDef;
GfxLightDef** streamGfxLightDefPtr;
Glyph* varGlyph;
Glyph** varGlyphPtr;
Glyph* outGlyph;
Glyph** outGlyphPtr;
Glyph* streamGlyph;
Glyph** streamGlyphPtr;
Font_s* varFont_s;
Font_s** varFont_sPtr;
Font_s* outFont_s;
Font_s** outFont_sPtr;
Font_s* streamFont_s;
Font_s** streamFont_sPtr;
LbColType* varLbColType;
LbColType** varLbColTypePtr;
LbColType* outLbColType;
LbColType** outLbColTypePtr;
LbColType* streamLbColType;
LbColType** streamLbColTypePtr;
LbAggType* varLbAggType;
LbAggType** varLbAggTypePtr;
LbAggType* outLbAggType;
LbAggType** outLbAggTypePtr;
LbAggType* streamLbAggType;
LbAggType** streamLbAggTypePtr;
LbColumnDef* varLbColumnDef;
LbColumnDef** varLbColumnDefPtr;
LbColumnDef* outLbColumnDef;
LbColumnDef** outLbColumnDefPtr;
LbColumnDef* streamLbColumnDef;
LbColumnDef** streamLbColumnDefPtr;
LeaderboardDef* varLeaderboardDef;
LeaderboardDef** varLeaderboardDefPtr;
LeaderboardDef* outLeaderboardDef;
LeaderboardDef** outLeaderboardDefPtr;
LeaderboardDef* streamLeaderboardDef;
LeaderboardDef** streamLeaderboardDefPtr;
StructuredDataEnumEntry* varStructuredDataEnumEntry;
StructuredDataEnumEntry** varStructuredDataEnumEntryPtr;
StructuredDataEnumEntry* outStructuredDataEnumEntry;
StructuredDataEnumEntry** outStructuredDataEnumEntryPtr;
StructuredDataEnumEntry* streamStructuredDataEnumEntry;
StructuredDataEnumEntry** streamStructuredDataEnumEntryPtr;
StructuredDataEnum* varStructuredDataEnum;
StructuredDataEnum** varStructuredDataEnumPtr;
StructuredDataEnum* outStructuredDataEnum;
StructuredDataEnum** outStructuredDataEnumPtr;
StructuredDataEnum* streamStructuredDataEnum;
StructuredDataEnum** streamStructuredDataEnumPtr;
StructuredDataTypeUnion* varStructuredDataTypeUnion;
StructuredDataTypeUnion** varStructuredDataTypeUnionPtr;
StructuredDataTypeUnion* outStructuredDataTypeUnion;
StructuredDataTypeUnion** outStructuredDataTypeUnionPtr;
StructuredDataTypeUnion* streamStructuredDataTypeUnion;
StructuredDataTypeUnion** streamStructuredDataTypeUnionPtr;
StructuredDataTypeCategory* varStructuredDataTypeCategory;
StructuredDataTypeCategory** varStructuredDataTypeCategoryPtr;
StructuredDataTypeCategory* outStructuredDataTypeCategory;
StructuredDataTypeCategory** outStructuredDataTypeCategoryPtr;
StructuredDataTypeCategory* streamStructuredDataTypeCategory;
StructuredDataTypeCategory** streamStructuredDataTypeCategoryPtr;
StructuredDataType* varStructuredDataType;
StructuredDataType** varStructuredDataTypePtr;
StructuredDataType* outStructuredDataType;
StructuredDataType** outStructuredDataTypePtr;
StructuredDataType* streamStructuredDataType;
StructuredDataType** streamStructuredDataTypePtr;
StructuredDataStructProperty* varStructuredDataStructProperty;
StructuredDataStructProperty** varStructuredDataStructPropertyPtr;
StructuredDataStructProperty* outStructuredDataStructProperty;
StructuredDataStructProperty** outStructuredDataStructPropertyPtr;
StructuredDataStructProperty* streamStructuredDataStructProperty;
StructuredDataStructProperty** streamStructuredDataStructPropertyPtr;
StructuredDataStruct* varStructuredDataStruct;
StructuredDataStruct** varStructuredDataStructPtr;
StructuredDataStruct* outStructuredDataStruct;
StructuredDataStruct** outStructuredDataStructPtr;
StructuredDataStruct* streamStructuredDataStruct;
StructuredDataStruct** streamStructuredDataStructPtr;
StructuredDataIndexedArray* varStructuredDataIndexedArray;
StructuredDataIndexedArray** varStructuredDataIndexedArrayPtr;
StructuredDataIndexedArray* outStructuredDataIndexedArray;
StructuredDataIndexedArray** outStructuredDataIndexedArrayPtr;
StructuredDataIndexedArray* streamStructuredDataIndexedArray;
StructuredDataIndexedArray** streamStructuredDataIndexedArrayPtr;
StructuredDataEnumedArray* varStructuredDataEnumedArray;
StructuredDataEnumedArray** varStructuredDataEnumedArrayPtr;
StructuredDataEnumedArray* outStructuredDataEnumedArray;
StructuredDataEnumedArray** outStructuredDataEnumedArrayPtr;
StructuredDataEnumedArray* streamStructuredDataEnumedArray;
StructuredDataEnumedArray** streamStructuredDataEnumedArrayPtr;
StructuredDataDef* varStructuredDataDef;
StructuredDataDef** varStructuredDataDefPtr;
StructuredDataDef* outStructuredDataDef;
StructuredDataDef** outStructuredDataDefPtr;
StructuredDataDef* streamStructuredDataDef;
StructuredDataDef** streamStructuredDataDefPtr;
StructuredDataDefSet* varStructuredDataDefSet;
StructuredDataDefSet** varStructuredDataDefSetPtr;
StructuredDataDefSet* outStructuredDataDefSet;
StructuredDataDefSet** outStructuredDataDefSetPtr;
StructuredDataDefSet* streamStructuredDataDefSet;
StructuredDataDefSet** streamStructuredDataDefSetPtr;
XAssetType* varXAssetType;
XAssetType** varXAssetTypePtr;
XAssetType* outXAssetType;
XAssetType** outXAssetTypePtr;
XAssetType* streamXAssetType;
XAssetType** streamXAssetTypePtr;
ScriptStringList* varScriptStringList;
ScriptStringList** varScriptStringListPtr;
ScriptStringList* outScriptStringList;
ScriptStringList** outScriptStringListPtr;
ScriptStringList* streamScriptStringList;
ScriptStringList** streamScriptStringListPtr;
XAsset* varXAsset;
XAsset** varXAssetPtr;
XAsset* outXAsset;
XAsset** outXAssetPtr;
XAsset* streamXAsset;
XAsset** streamXAssetPtr;
XAssetList* varXAssetList;
XAssetList** varXAssetListPtr;
XAssetList* outXAssetList;
XAssetList** outXAssetListPtr;
XAssetList* streamXAssetList;
XAssetList** streamXAssetListPtr;
XAssetHeader* varXAssetHeader;
XAssetHeader** varXAssetHeaderPtr;
XAssetHeader* outXAssetHeader;
XAssetHeader** outXAssetHeaderPtr;
XAssetHeader* streamXAssetHeader;
XAssetHeader** streamXAssetHeaderPtr;

$C8D87EB0090687D323381DFB7A82089C* AllocLoad_$C8D87EB0090687D323381DFB7A82089C()
{
	return ($C8D87EB0090687D323381DFB7A82089C*)DB_AllocStreamPos(3);
}

$C8D87EB0090687D323381DFB7A82089C** AllocLoad_$C8D87EB0090687D323381DFB7A82089CPtr()
{
	return ($C8D87EB0090687D323381DFB7A82089C**)DB_AllocStreamPos(3);
}

$E43DBA5037697D705289B74D87E76C70* AllocLoad_$E43DBA5037697D705289B74D87E76C70()
{
	return ($E43DBA5037697D705289B74D87E76C70*)DB_AllocStreamPos(3);
}

$E43DBA5037697D705289B74D87E76C70** AllocLoad_$E43DBA5037697D705289B74D87E76C70Ptr()
{
	return ($E43DBA5037697D705289B74D87E76C70**)DB_AllocStreamPos(3);
}

Bounds* AllocLoad_Bounds()
{
	return (Bounds*)DB_AllocStreamPos(3);
}

Bounds** AllocLoad_BoundsPtr()
{
	return (Bounds**)DB_AllocStreamPos(3);
}

BrushWrapper* AllocLoad_BrushWrapper()
{
	return (BrushWrapper*)DB_AllocStreamPos(3);
}

BrushWrapper** AllocLoad_BrushWrapperPtr()
{
	return (BrushWrapper**)DB_AllocStreamPos(3);
}

CardMemory* AllocLoad_CardMemory()
{
	return (CardMemory*)DB_AllocStreamPos(3);
}

CardMemory** AllocLoad_CardMemoryPtr()
{
	return (CardMemory**)DB_AllocStreamPos(3);
}

ClipMaterial* AllocLoad_ClipMaterial()
{
	return (ClipMaterial*)DB_AllocStreamPos(3);
}

ClipMaterial** AllocLoad_ClipMaterialPtr()
{
	return (ClipMaterial**)DB_AllocStreamPos(3);
}

CollisionAabbTree* AllocLoad_CollisionAabbTree()
{
	return (CollisionAabbTree*)DB_AllocStreamPos(15);
}

CollisionAabbTree** AllocLoad_CollisionAabbTreePtr()
{
	return (CollisionAabbTree**)DB_AllocStreamPos(15);
}

CollisionAabbTreeIndex* AllocLoad_CollisionAabbTreeIndex()
{
	return (CollisionAabbTreeIndex*)DB_AllocStreamPos(3);
}

CollisionAabbTreeIndex** AllocLoad_CollisionAabbTreeIndexPtr()
{
	return (CollisionAabbTreeIndex**)DB_AllocStreamPos(3);
}

CollisionBorder* AllocLoad_CollisionBorder()
{
	return (CollisionBorder*)DB_AllocStreamPos(3);
}

CollisionBorder** AllocLoad_CollisionBorderPtr()
{
	return (CollisionBorder**)DB_AllocStreamPos(3);
}

CollisionPartition* AllocLoad_CollisionPartition()
{
	return (CollisionPartition*)DB_AllocStreamPos(3);
}

CollisionPartition** AllocLoad_CollisionPartitionPtr()
{
	return (CollisionPartition**)DB_AllocStreamPos(3);
}

ComPrimaryLight* AllocLoad_ComPrimaryLight()
{
	return (ComPrimaryLight*)DB_AllocStreamPos(3);
}

ComPrimaryLight** AllocLoad_ComPrimaryLightPtr()
{
	return (ComPrimaryLight**)DB_AllocStreamPos(3);
}

ComWorld* AllocLoad_ComWorld()
{
	return (ComWorld*)DB_AllocStreamPos(3);
}

ComWorld** AllocLoad_ComWorldPtr()
{
	return (ComWorld**)DB_AllocStreamPos(3);
}

ConditionalScript* AllocLoad_ConditionalScript()
{
	return (ConditionalScript*)DB_AllocStreamPos(3);
}

ConditionalScript** AllocLoad_ConditionalScriptPtr()
{
	return (ConditionalScript**)DB_AllocStreamPos(3);
}

DObjAnimMat* AllocLoad_DObjAnimMat()
{
	return (DObjAnimMat*)DB_AllocStreamPos(3);
}

DObjAnimMat** AllocLoad_DObjAnimMatPtr()
{
	return (DObjAnimMat**)DB_AllocStreamPos(3);
}

DynEntityClient* AllocLoad_DynEntityClient()
{
	return (DynEntityClient*)DB_AllocStreamPos(3);
}

DynEntityClient** AllocLoad_DynEntityClientPtr()
{
	return (DynEntityClient**)DB_AllocStreamPos(3);
}

DynEntityColl* AllocLoad_DynEntityColl()
{
	return (DynEntityColl*)DB_AllocStreamPos(3);
}

DynEntityColl** AllocLoad_DynEntityCollPtr()
{
	return (DynEntityColl**)DB_AllocStreamPos(3);
}

DynEntityDef* AllocLoad_DynEntityDef()
{
	return (DynEntityDef*)DB_AllocStreamPos(3);
}

DynEntityDef** AllocLoad_DynEntityDefPtr()
{
	return (DynEntityDef**)DB_AllocStreamPos(3);
}

DynEntityPose* AllocLoad_DynEntityPose()
{
	return (DynEntityPose*)DB_AllocStreamPos(3);
}

DynEntityPose** AllocLoad_DynEntityPosePtr()
{
	return (DynEntityPose**)DB_AllocStreamPos(3);
}

EventData* AllocLoad_EventData()
{
	return (EventData*)DB_AllocStreamPos(3);
}

EventData** AllocLoad_EventDataPtr()
{
	return (EventData**)DB_AllocStreamPos(3);
}

ExpressionString* AllocLoad_ExpressionString()
{
	return (ExpressionString*)DB_AllocStreamPos(3);
}

ExpressionString** AllocLoad_ExpressionStringPtr()
{
	return (ExpressionString**)DB_AllocStreamPos(3);
}

ExpressionSupportingData* AllocLoad_ExpressionSupportingData()
{
	return (ExpressionSupportingData*)DB_AllocStreamPos(3);
}

ExpressionSupportingData** AllocLoad_ExpressionSupportingDataPtr()
{
	return (ExpressionSupportingData**)DB_AllocStreamPos(3);
}

Font_s* AllocLoad_Font_s()
{
	return (Font_s*)DB_AllocStreamPos(3);
}

Font_s** AllocLoad_Font_sPtr()
{
	return (Font_s**)DB_AllocStreamPos(3);
}

FxEffectDef* AllocLoad_FxEffectDef()
{
	return (FxEffectDef*)DB_AllocStreamPos(3);
}

FxEffectDef** AllocLoad_FxEffectDefPtr()
{
	return (FxEffectDef**)DB_AllocStreamPos(3);
}

FxEffectDefRef* AllocLoad_FxEffectDefRef()
{
	return (FxEffectDefRef*)DB_AllocStreamPos(3);
}

FxEffectDefRef** AllocLoad_FxEffectDefRefPtr()
{
	return (FxEffectDefRef**)DB_AllocStreamPos(3);
}

FxElemAtlas* AllocLoad_FxElemAtlas()
{
	return (FxElemAtlas*)DB_AllocStreamPos(3);
}

FxElemAtlas** AllocLoad_FxElemAtlasPtr()
{
	return (FxElemAtlas**)DB_AllocStreamPos(3);
}

FxElemDef* AllocLoad_FxElemDef()
{
	return (FxElemDef*)DB_AllocStreamPos(3);
}

FxElemDef** AllocLoad_FxElemDefPtr()
{
	return (FxElemDef**)DB_AllocStreamPos(3);
}

FxElemDefVisuals* AllocLoad_FxElemDefVisuals()
{
	return (FxElemDefVisuals*)DB_AllocStreamPos(3);
}

FxElemDefVisuals** AllocLoad_FxElemDefVisualsPtr()
{
	return (FxElemDefVisuals**)DB_AllocStreamPos(3);
}

FxElemExtendedDefPtr* AllocLoad_FxElemExtendedDefPtr()
{
	return (FxElemExtendedDefPtr*)DB_AllocStreamPos(3);
}

FxElemExtendedDefPtr** AllocLoad_FxElemExtendedDefPtrPtr()
{
	return (FxElemExtendedDefPtr**)DB_AllocStreamPos(3);
}

FxElemMarkVisuals* AllocLoad_FxElemMarkVisuals()
{
	return (FxElemMarkVisuals*)DB_AllocStreamPos(3);
}

FxElemMarkVisuals** AllocLoad_FxElemMarkVisualsPtr()
{
	return (FxElemMarkVisuals**)DB_AllocStreamPos(3);
}

FxElemVec3Range* AllocLoad_FxElemVec3Range()
{
	return (FxElemVec3Range*)DB_AllocStreamPos(3);
}

FxElemVec3Range** AllocLoad_FxElemVec3RangePtr()
{
	return (FxElemVec3Range**)DB_AllocStreamPos(3);
}

FxElemVelStateInFrame* AllocLoad_FxElemVelStateInFrame()
{
	return (FxElemVelStateInFrame*)DB_AllocStreamPos(3);
}

FxElemVelStateInFrame** AllocLoad_FxElemVelStateInFramePtr()
{
	return (FxElemVelStateInFrame**)DB_AllocStreamPos(3);
}

FxElemVelStateSample* AllocLoad_FxElemVelStateSample()
{
	return (FxElemVelStateSample*)DB_AllocStreamPos(3);
}

FxElemVelStateSample** AllocLoad_FxElemVelStateSamplePtr()
{
	return (FxElemVelStateSample**)DB_AllocStreamPos(3);
}

FxElemVisStateSample* AllocLoad_FxElemVisStateSample()
{
	return (FxElemVisStateSample*)DB_AllocStreamPos(3);
}

FxElemVisStateSample** AllocLoad_FxElemVisStateSamplePtr()
{
	return (FxElemVisStateSample**)DB_AllocStreamPos(3);
}

FxElemVisualState* AllocLoad_FxElemVisualState()
{
	return (FxElemVisualState*)DB_AllocStreamPos(3);
}

FxElemVisualState** AllocLoad_FxElemVisualStatePtr()
{
	return (FxElemVisualState**)DB_AllocStreamPos(3);
}

FxElemVisuals* AllocLoad_FxElemVisuals()
{
	return (FxElemVisuals*)DB_AllocStreamPos(3);
}

FxElemVisuals** AllocLoad_FxElemVisualsPtr()
{
	return (FxElemVisuals**)DB_AllocStreamPos(3);
}

FxFloatRange* AllocLoad_FxFloatRange()
{
	return (FxFloatRange*)DB_AllocStreamPos(3);
}

FxFloatRange** AllocLoad_FxFloatRangePtr()
{
	return (FxFloatRange**)DB_AllocStreamPos(3);
}

FxGlassCrackHeader* AllocLoad_FxGlassCrackHeader()
{
	return (FxGlassCrackHeader*)DB_AllocStreamPos(3);
}

FxGlassCrackHeader** AllocLoad_FxGlassCrackHeaderPtr()
{
	return (FxGlassCrackHeader**)DB_AllocStreamPos(3);
}

FxGlassDef* AllocLoad_FxGlassDef()
{
	return (FxGlassDef*)DB_AllocStreamPos(3);
}

FxGlassDef** AllocLoad_FxGlassDefPtr()
{
	return (FxGlassDef**)DB_AllocStreamPos(3);
}

FxGlassGeometryData* AllocLoad_FxGlassGeometryData()
{
	return (FxGlassGeometryData*)DB_AllocStreamPos(3);
}

FxGlassGeometryData** AllocLoad_FxGlassGeometryDataPtr()
{
	return (FxGlassGeometryData**)DB_AllocStreamPos(3);
}

FxGlassHoleHeader* AllocLoad_FxGlassHoleHeader()
{
	return (FxGlassHoleHeader*)DB_AllocStreamPos(3);
}

FxGlassHoleHeader** AllocLoad_FxGlassHoleHeaderPtr()
{
	return (FxGlassHoleHeader**)DB_AllocStreamPos(3);
}

FxGlassInitPieceState* AllocLoad_FxGlassInitPieceState()
{
	return (FxGlassInitPieceState*)DB_AllocStreamPos(3);
}

FxGlassInitPieceState** AllocLoad_FxGlassInitPieceStatePtr()
{
	return (FxGlassInitPieceState**)DB_AllocStreamPos(3);
}

FxGlassPieceDynamics* AllocLoad_FxGlassPieceDynamics()
{
	return (FxGlassPieceDynamics*)DB_AllocStreamPos(3);
}

FxGlassPieceDynamics** AllocLoad_FxGlassPieceDynamicsPtr()
{
	return (FxGlassPieceDynamics**)DB_AllocStreamPos(3);
}

FxGlassPiecePlace* AllocLoad_FxGlassPiecePlace()
{
	return (FxGlassPiecePlace*)DB_AllocStreamPos(3);
}

FxGlassPiecePlace** AllocLoad_FxGlassPiecePlacePtr()
{
	return (FxGlassPiecePlace**)DB_AllocStreamPos(3);
}

FxGlassPieceState* AllocLoad_FxGlassPieceState()
{
	return (FxGlassPieceState*)DB_AllocStreamPos(3);
}

FxGlassPieceState** AllocLoad_FxGlassPieceStatePtr()
{
	return (FxGlassPieceState**)DB_AllocStreamPos(3);
}

FxGlassSystem* AllocLoad_FxGlassSystem()
{
	return (FxGlassSystem*)DB_AllocStreamPos(3);
}

FxGlassSystem** AllocLoad_FxGlassSystemPtr()
{
	return (FxGlassSystem**)DB_AllocStreamPos(3);
}

FxGlassVertex* AllocLoad_FxGlassVertex()
{
	return (FxGlassVertex*)DB_AllocStreamPos(3);
}

FxGlassVertex** AllocLoad_FxGlassVertexPtr()
{
	return (FxGlassVertex**)DB_AllocStreamPos(3);
}

FxIntRange* AllocLoad_FxIntRange()
{
	return (FxIntRange*)DB_AllocStreamPos(3);
}

FxIntRange** AllocLoad_FxIntRangePtr()
{
	return (FxIntRange**)DB_AllocStreamPos(3);
}

FxSparkFountainDef* AllocLoad_FxSparkFountainDef()
{
	return (FxSparkFountainDef*)DB_AllocStreamPos(3);
}

FxSparkFountainDef** AllocLoad_FxSparkFountainDefPtr()
{
	return (FxSparkFountainDef**)DB_AllocStreamPos(3);
}

FxSpatialFrame* AllocLoad_FxSpatialFrame()
{
	return (FxSpatialFrame*)DB_AllocStreamPos(3);
}

FxSpatialFrame** AllocLoad_FxSpatialFramePtr()
{
	return (FxSpatialFrame**)DB_AllocStreamPos(3);
}

FxSpawnDef* AllocLoad_FxSpawnDef()
{
	return (FxSpawnDef*)DB_AllocStreamPos(3);
}

FxSpawnDef** AllocLoad_FxSpawnDefPtr()
{
	return (FxSpawnDef**)DB_AllocStreamPos(3);
}

FxSpawnDefLooping* AllocLoad_FxSpawnDefLooping()
{
	return (FxSpawnDefLooping*)DB_AllocStreamPos(3);
}

FxSpawnDefLooping** AllocLoad_FxSpawnDefLoopingPtr()
{
	return (FxSpawnDefLooping**)DB_AllocStreamPos(3);
}

FxSpawnDefOneShot* AllocLoad_FxSpawnDefOneShot()
{
	return (FxSpawnDefOneShot*)DB_AllocStreamPos(3);
}

FxSpawnDefOneShot** AllocLoad_FxSpawnDefOneShotPtr()
{
	return (FxSpawnDefOneShot**)DB_AllocStreamPos(3);
}

FxTrailDef* AllocLoad_FxTrailDef()
{
	return (FxTrailDef*)DB_AllocStreamPos(3);
}

FxTrailDef** AllocLoad_FxTrailDefPtr()
{
	return (FxTrailDef**)DB_AllocStreamPos(3);
}

FxTrailVertex* AllocLoad_FxTrailVertex()
{
	return (FxTrailVertex*)DB_AllocStreamPos(3);
}

FxTrailVertex** AllocLoad_FxTrailVertexPtr()
{
	return (FxTrailVertex**)DB_AllocStreamPos(3);
}

FxWorld* AllocLoad_FxWorld()
{
	return (FxWorld*)DB_AllocStreamPos(3);
}

FxWorld** AllocLoad_FxWorldPtr()
{
	return (FxWorld**)DB_AllocStreamPos(3);
}

G_GlassData* AllocLoad_G_GlassData()
{
	return (G_GlassData*)DB_AllocStreamPos(3);
}

G_GlassData** AllocLoad_G_GlassDataPtr()
{
	return (G_GlassData**)DB_AllocStreamPos(3);
}

G_GlassName* AllocLoad_G_GlassName()
{
	return (G_GlassName*)DB_AllocStreamPos(3);
}

G_GlassName** AllocLoad_G_GlassNamePtr()
{
	return (G_GlassName**)DB_AllocStreamPos(3);
}

G_GlassPiece* AllocLoad_G_GlassPiece()
{
	return (G_GlassPiece*)DB_AllocStreamPos(1);
}

G_GlassPiece** AllocLoad_G_GlassPiecePtr()
{
	return (G_GlassPiece**)DB_AllocStreamPos(1);
}

GameWorldMp* AllocLoad_GameWorldMp()
{
	return (GameWorldMp*)DB_AllocStreamPos(3);
}

GameWorldMp** AllocLoad_GameWorldMpPtr()
{
	return (GameWorldMp**)DB_AllocStreamPos(3);
}

GfxColor* AllocLoad_GfxColor()
{
	return (GfxColor*)DB_AllocStreamPos(3);
}

GfxColor** AllocLoad_GfxColorPtr()
{
	return (GfxColor**)DB_AllocStreamPos(3);
}

GfxDrawSurf* AllocLoad_GfxDrawSurf()
{
	return (GfxDrawSurf*)DB_AllocStreamPos(3);
}

GfxDrawSurf** AllocLoad_GfxDrawSurfPtr()
{
	return (GfxDrawSurf**)DB_AllocStreamPos(3);
}

GfxImage* AllocLoad_GfxImage()
{
	return (GfxImage*)DB_AllocStreamPos(3);
}

GfxImage** AllocLoad_GfxImagePtr()
{
	return (GfxImage**)DB_AllocStreamPos(3);
}

GfxImageLoadDef* AllocLoad_GfxImageLoadDef()
{
	return (GfxImageLoadDef*)DB_AllocStreamPos(3);
}

GfxImageLoadDef** AllocLoad_GfxImageLoadDefPtr()
{
	return (GfxImageLoadDef**)DB_AllocStreamPos(3);
}

GfxLightDef* AllocLoad_GfxLightDef()
{
	return (GfxLightDef*)DB_AllocStreamPos(3);
}

GfxLightDef** AllocLoad_GfxLightDefPtr()
{
	return (GfxLightDef**)DB_AllocStreamPos(3);
}

GfxLightImage* AllocLoad_GfxLightImage()
{
	return (GfxLightImage*)DB_AllocStreamPos(3);
}

GfxLightImage** AllocLoad_GfxLightImagePtr()
{
	return (GfxLightImage**)DB_AllocStreamPos(3);
}

GfxPackedVertex* AllocLoad_GfxPackedVertex()
{
	return (GfxPackedVertex*)DB_AllocStreamPos(15);
}

GfxPackedVertex** AllocLoad_GfxPackedVertexPtr()
{
	return (GfxPackedVertex**)DB_AllocStreamPos(15);
}

GfxPixelShaderLoadDef* AllocLoad_GfxPixelShaderLoadDef()
{
	return (GfxPixelShaderLoadDef*)DB_AllocStreamPos(3);
}

GfxPixelShaderLoadDef** AllocLoad_GfxPixelShaderLoadDefPtr()
{
	return (GfxPixelShaderLoadDef**)DB_AllocStreamPos(3);
}

GfxPlacement* AllocLoad_GfxPlacement()
{
	return (GfxPlacement*)DB_AllocStreamPos(3);
}

GfxPlacement** AllocLoad_GfxPlacementPtr()
{
	return (GfxPlacement**)DB_AllocStreamPos(3);
}

GfxStateBits* AllocLoad_GfxStateBits()
{
	return (GfxStateBits*)DB_AllocStreamPos(3);
}

GfxStateBits** AllocLoad_GfxStateBitsPtr()
{
	return (GfxStateBits**)DB_AllocStreamPos(3);
}

GfxTexture* AllocLoad_GfxTexture()
{
	return (GfxTexture*)DB_AllocStreamPos(3);
}

GfxTexture** AllocLoad_GfxTexturePtr()
{
	return (GfxTexture**)DB_AllocStreamPos(3);
}

GfxVertexShaderLoadDef* AllocLoad_GfxVertexShaderLoadDef()
{
	return (GfxVertexShaderLoadDef*)DB_AllocStreamPos(3);
}

GfxVertexShaderLoadDef** AllocLoad_GfxVertexShaderLoadDefPtr()
{
	return (GfxVertexShaderLoadDef**)DB_AllocStreamPos(3);
}

Glyph* AllocLoad_Glyph()
{
	return (Glyph*)DB_AllocStreamPos(3);
}

Glyph** AllocLoad_GlyphPtr()
{
	return (Glyph**)DB_AllocStreamPos(3);
}

ItemFloatExpression* AllocLoad_ItemFloatExpression()
{
	return (ItemFloatExpression*)DB_AllocStreamPos(3);
}

ItemFloatExpression** AllocLoad_ItemFloatExpressionPtr()
{
	return (ItemFloatExpression**)DB_AllocStreamPos(3);
}

ItemKeyHandler* AllocLoad_ItemKeyHandler()
{
	return (ItemKeyHandler*)DB_AllocStreamPos(3);
}

ItemKeyHandler** AllocLoad_ItemKeyHandlerPtr()
{
	return (ItemKeyHandler**)DB_AllocStreamPos(3);
}

LbColumnDef* AllocLoad_LbColumnDef()
{
	return (LbColumnDef*)DB_AllocStreamPos(3);
}

LbColumnDef** AllocLoad_LbColumnDefPtr()
{
	return (LbColumnDef**)DB_AllocStreamPos(3);
}

LeaderboardDef* AllocLoad_LeaderboardDef()
{
	return (LeaderboardDef*)DB_AllocStreamPos(3);
}

LeaderboardDef** AllocLoad_LeaderboardDefPtr()
{
	return (LeaderboardDef**)DB_AllocStreamPos(3);
}

LoadedSound* AllocLoad_LoadedSound()
{
	return (LoadedSound*)DB_AllocStreamPos(3);
}

LoadedSound** AllocLoad_LoadedSoundPtr()
{
	return (LoadedSound**)DB_AllocStreamPos(3);
}

LocalizeEntry* AllocLoad_LocalizeEntry()
{
	return (LocalizeEntry*)DB_AllocStreamPos(3);
}

LocalizeEntry** AllocLoad_LocalizeEntryPtr()
{
	return (LocalizeEntry**)DB_AllocStreamPos(3);
}

MSSChannelMap* AllocLoad_MSSChannelMap()
{
	return (MSSChannelMap*)DB_AllocStreamPos(3);
}

MSSChannelMap** AllocLoad_MSSChannelMapPtr()
{
	return (MSSChannelMap**)DB_AllocStreamPos(3);
}

MSSSpeakerLevels* AllocLoad_MSSSpeakerLevels()
{
	return (MSSSpeakerLevels*)DB_AllocStreamPos(3);
}

MSSSpeakerLevels** AllocLoad_MSSSpeakerLevelsPtr()
{
	return (MSSSpeakerLevels**)DB_AllocStreamPos(3);
}

MapEnts* AllocLoad_MapEnts()
{
	return (MapEnts*)DB_AllocStreamPos(3);
}

MapEnts** AllocLoad_MapEntsPtr()
{
	return (MapEnts**)DB_AllocStreamPos(3);
}

MapTriggers* AllocLoad_MapTriggers()
{
	return (MapTriggers*)DB_AllocStreamPos(3);
}

MapTriggers** AllocLoad_MapTriggersPtr()
{
	return (MapTriggers**)DB_AllocStreamPos(3);
}

Material* AllocLoad_Material()
{
	return (Material*)DB_AllocStreamPos(3);
}

Material** AllocLoad_MaterialPtr()
{
	return (Material**)DB_AllocStreamPos(3);
}

MaterialArgumentCodeConst* AllocLoad_MaterialArgumentCodeConst()
{
	return (MaterialArgumentCodeConst*)DB_AllocStreamPos(3);
}

MaterialArgumentCodeConst** AllocLoad_MaterialArgumentCodeConstPtr()
{
	return (MaterialArgumentCodeConst**)DB_AllocStreamPos(3);
}

MaterialArgumentDef* AllocLoad_MaterialArgumentDef()
{
	return (MaterialArgumentDef*)DB_AllocStreamPos(3);
}

MaterialArgumentDef** AllocLoad_MaterialArgumentDefPtr()
{
	return (MaterialArgumentDef**)DB_AllocStreamPos(3);
}

MaterialConstantDef* AllocLoad_MaterialConstantDef()
{
	return (MaterialConstantDef*)DB_AllocStreamPos(15);
}

MaterialConstantDef** AllocLoad_MaterialConstantDefPtr()
{
	return (MaterialConstantDef**)DB_AllocStreamPos(15);
}

MaterialInfo* AllocLoad_MaterialInfo()
{
	return (MaterialInfo*)DB_AllocStreamPos(3);
}

MaterialInfo** AllocLoad_MaterialInfoPtr()
{
	return (MaterialInfo**)DB_AllocStreamPos(3);
}

MaterialPass* AllocLoad_MaterialPass()
{
	return (MaterialPass*)DB_AllocStreamPos(3);
}

MaterialPass** AllocLoad_MaterialPassPtr()
{
	return (MaterialPass**)DB_AllocStreamPos(3);
}

MaterialPixelShader* AllocLoad_MaterialPixelShader()
{
	return (MaterialPixelShader*)DB_AllocStreamPos(3);
}

MaterialPixelShader** AllocLoad_MaterialPixelShaderPtr()
{
	return (MaterialPixelShader**)DB_AllocStreamPos(3);
}

MaterialPixelShaderProgram* AllocLoad_MaterialPixelShaderProgram()
{
	return (MaterialPixelShaderProgram*)DB_AllocStreamPos(3);
}

MaterialPixelShaderProgram** AllocLoad_MaterialPixelShaderProgramPtr()
{
	return (MaterialPixelShaderProgram**)DB_AllocStreamPos(3);
}

MaterialShaderArgument* AllocLoad_MaterialShaderArgument()
{
	return (MaterialShaderArgument*)DB_AllocStreamPos(3);
}

MaterialShaderArgument** AllocLoad_MaterialShaderArgumentPtr()
{
	return (MaterialShaderArgument**)DB_AllocStreamPos(3);
}

MaterialStreamRouting* AllocLoad_MaterialStreamRouting()
{
	return (MaterialStreamRouting*)DB_AllocStreamPos(1);
}

MaterialStreamRouting** AllocLoad_MaterialStreamRoutingPtr()
{
	return (MaterialStreamRouting**)DB_AllocStreamPos(1);
}

MaterialTechnique* AllocLoad_MaterialTechnique()
{
	return (MaterialTechnique*)DB_AllocStreamPos(3);
}

MaterialTechnique** AllocLoad_MaterialTechniquePtr()
{
	return (MaterialTechnique**)DB_AllocStreamPos(3);
}

MaterialTechniqueSet* AllocLoad_MaterialTechniqueSet()
{
	return (MaterialTechniqueSet*)DB_AllocStreamPos(3);
}

MaterialTechniqueSet** AllocLoad_MaterialTechniqueSetPtr()
{
	return (MaterialTechniqueSet**)DB_AllocStreamPos(3);
}

MaterialTextureDef* AllocLoad_MaterialTextureDef()
{
	return (MaterialTextureDef*)DB_AllocStreamPos(3);
}

MaterialTextureDef** AllocLoad_MaterialTextureDefPtr()
{
	return (MaterialTextureDef**)DB_AllocStreamPos(3);
}

MaterialTextureDefInfo* AllocLoad_MaterialTextureDefInfo()
{
	return (MaterialTextureDefInfo*)DB_AllocStreamPos(3);
}

MaterialTextureDefInfo** AllocLoad_MaterialTextureDefInfoPtr()
{
	return (MaterialTextureDefInfo**)DB_AllocStreamPos(3);
}

MaterialVertexDeclaration* AllocLoad_MaterialVertexDeclaration()
{
	return (MaterialVertexDeclaration*)DB_AllocStreamPos(3);
}

MaterialVertexDeclaration** AllocLoad_MaterialVertexDeclarationPtr()
{
	return (MaterialVertexDeclaration**)DB_AllocStreamPos(3);
}

MaterialVertexShader* AllocLoad_MaterialVertexShader()
{
	return (MaterialVertexShader*)DB_AllocStreamPos(3);
}

MaterialVertexShader** AllocLoad_MaterialVertexShaderPtr()
{
	return (MaterialVertexShader**)DB_AllocStreamPos(3);
}

MaterialVertexShaderProgram* AllocLoad_MaterialVertexShaderProgram()
{
	return (MaterialVertexShaderProgram*)DB_AllocStreamPos(3);
}

MaterialVertexShaderProgram** AllocLoad_MaterialVertexShaderProgramPtr()
{
	return (MaterialVertexShaderProgram**)DB_AllocStreamPos(3);
}

MaterialVertexStreamRouting* AllocLoad_MaterialVertexStreamRouting()
{
	return (MaterialVertexStreamRouting*)DB_AllocStreamPos(3);
}

MaterialVertexStreamRouting** AllocLoad_MaterialVertexStreamRoutingPtr()
{
	return (MaterialVertexStreamRouting**)DB_AllocStreamPos(3);
}

MenuEventHandler* AllocLoad_MenuEventHandler()
{
	return (MenuEventHandler*)DB_AllocStreamPos(3);
}

MenuEventHandler** AllocLoad_MenuEventHandlerPtr()
{
	return (MenuEventHandler**)DB_AllocStreamPos(3);
}

MenuEventHandlerSet* AllocLoad_MenuEventHandlerSet()
{
	return (MenuEventHandlerSet*)DB_AllocStreamPos(3);
}

MenuEventHandlerSet** AllocLoad_MenuEventHandlerSetPtr()
{
	return (MenuEventHandlerSet**)DB_AllocStreamPos(3);
}

MenuList* AllocLoad_MenuList()
{
	return (MenuList*)DB_AllocStreamPos(3);
}

MenuList** AllocLoad_MenuListPtr()
{
	return (MenuList**)DB_AllocStreamPos(3);
}

MssSound* AllocLoad_MssSound()
{
	return (MssSound*)DB_AllocStreamPos(3);
}

MssSound** AllocLoad_MssSoundPtr()
{
	return (MssSound**)DB_AllocStreamPos(3);
}

Operand* AllocLoad_Operand()
{
	return (Operand*)DB_AllocStreamPos(3);
}

Operand** AllocLoad_OperandPtr()
{
	return (Operand**)DB_AllocStreamPos(3);
}

PackedTexCoords* AllocLoad_PackedTexCoords()
{
	return (PackedTexCoords*)DB_AllocStreamPos(3);
}

PackedTexCoords** AllocLoad_PackedTexCoordsPtr()
{
	return (PackedTexCoords**)DB_AllocStreamPos(3);
}

PackedUnitVec* AllocLoad_PackedUnitVec()
{
	return (PackedUnitVec*)DB_AllocStreamPos(3);
}

PackedUnitVec** AllocLoad_PackedUnitVecPtr()
{
	return (PackedUnitVec**)DB_AllocStreamPos(3);
}

PhysCollmap* AllocLoad_PhysCollmap()
{
	return (PhysCollmap*)DB_AllocStreamPos(3);
}

PhysCollmap** AllocLoad_PhysCollmapPtr()
{
	return (PhysCollmap**)DB_AllocStreamPos(3);
}

PhysGeomInfo* AllocLoad_PhysGeomInfo()
{
	return (PhysGeomInfo*)DB_AllocStreamPos(3);
}

PhysGeomInfo** AllocLoad_PhysGeomInfoPtr()
{
	return (PhysGeomInfo**)DB_AllocStreamPos(3);
}

PhysMass* AllocLoad_PhysMass()
{
	return (PhysMass*)DB_AllocStreamPos(3);
}

PhysMass** AllocLoad_PhysMassPtr()
{
	return (PhysMass**)DB_AllocStreamPos(3);
}

PhysPreset* AllocLoad_PhysPreset()
{
	return (PhysPreset*)DB_AllocStreamPos(3);
}

PhysPreset** AllocLoad_PhysPresetPtr()
{
	return (PhysPreset**)DB_AllocStreamPos(3);
}

Picmip* AllocLoad_Picmip()
{
	return (Picmip*)DB_AllocStreamPos(3);
}

Picmip** AllocLoad_PicmipPtr()
{
	return (Picmip**)DB_AllocStreamPos(3);
}

RawFile* AllocLoad_RawFile()
{
	return (RawFile*)DB_AllocStreamPos(3);
}

RawFile** AllocLoad_RawFilePtr()
{
	return (RawFile**)DB_AllocStreamPos(3);
}

SModelAabbNode* AllocLoad_SModelAabbNode()
{
	return (SModelAabbNode*)DB_AllocStreamPos(3);
}

SModelAabbNode** AllocLoad_SModelAabbNodePtr()
{
	return (SModelAabbNode**)DB_AllocStreamPos(3);
}

ScriptStringList* AllocLoad_ScriptStringList()
{
	return (ScriptStringList*)DB_AllocStreamPos(3);
}

ScriptStringList** AllocLoad_ScriptStringListPtr()
{
	return (ScriptStringList**)DB_AllocStreamPos(3);
}

SetLocalVarData* AllocLoad_SetLocalVarData()
{
	return (SetLocalVarData*)DB_AllocStreamPos(3);
}

SetLocalVarData** AllocLoad_SetLocalVarDataPtr()
{
	return (SetLocalVarData**)DB_AllocStreamPos(3);
}

SndCurve* AllocLoad_SndCurve()
{
	return (SndCurve*)DB_AllocStreamPos(3);
}

SndCurve** AllocLoad_SndCurvePtr()
{
	return (SndCurve**)DB_AllocStreamPos(3);
}

SndDriverGlobals* AllocLoad_SndDriverGlobals()
{
	return (SndDriverGlobals*)DB_AllocStreamPos(3);
}

SndDriverGlobals** AllocLoad_SndDriverGlobalsPtr()
{
	return (SndDriverGlobals**)DB_AllocStreamPos(3);
}

SoundFile* AllocLoad_SoundFile()
{
	return (SoundFile*)DB_AllocStreamPos(3);
}

SoundFile** AllocLoad_SoundFilePtr()
{
	return (SoundFile**)DB_AllocStreamPos(3);
}

SoundFileRef* AllocLoad_SoundFileRef()
{
	return (SoundFileRef*)DB_AllocStreamPos(3);
}

SoundFileRef** AllocLoad_SoundFileRefPtr()
{
	return (SoundFileRef**)DB_AllocStreamPos(3);
}

SpeakerMap* AllocLoad_SpeakerMap()
{
	return (SpeakerMap*)DB_AllocStreamPos(3);
}

SpeakerMap** AllocLoad_SpeakerMapPtr()
{
	return (SpeakerMap**)DB_AllocStreamPos(3);
}

Stage* AllocLoad_Stage()
{
	return (Stage*)DB_AllocStreamPos(1);
}

Stage** AllocLoad_StagePtr()
{
	return (Stage**)DB_AllocStreamPos(1);
}

Statement_s* AllocLoad_Statement_s()
{
	return (Statement_s*)DB_AllocStreamPos(3);
}

Statement_s** AllocLoad_Statement_sPtr()
{
	return (Statement_s**)DB_AllocStreamPos(3);
}

StaticDvar* AllocLoad_StaticDvar()
{
	return (StaticDvar*)DB_AllocStreamPos(3);
}

StaticDvar** AllocLoad_StaticDvarPtr()
{
	return (StaticDvar**)DB_AllocStreamPos(3);
}

StaticDvarList* AllocLoad_StaticDvarList()
{
	return (StaticDvarList*)DB_AllocStreamPos(3);
}

StaticDvarList** AllocLoad_StaticDvarListPtr()
{
	return (StaticDvarList**)DB_AllocStreamPos(3);
}

StreamFileInfo* AllocLoad_StreamFileInfo()
{
	return (StreamFileInfo*)DB_AllocStreamPos(3);
}

StreamFileInfo** AllocLoad_StreamFileInfoPtr()
{
	return (StreamFileInfo**)DB_AllocStreamPos(3);
}

StreamFileName* AllocLoad_StreamFileName()
{
	return (StreamFileName*)DB_AllocStreamPos(3);
}

StreamFileName** AllocLoad_StreamFileNamePtr()
{
	return (StreamFileName**)DB_AllocStreamPos(3);
}

StreamFileNameRaw* AllocLoad_StreamFileNameRaw()
{
	return (StreamFileNameRaw*)DB_AllocStreamPos(3);
}

StreamFileNameRaw** AllocLoad_StreamFileNameRawPtr()
{
	return (StreamFileNameRaw**)DB_AllocStreamPos(3);
}

StreamedSound* AllocLoad_StreamedSound()
{
	return (StreamedSound*)DB_AllocStreamPos(3);
}

StreamedSound** AllocLoad_StreamedSoundPtr()
{
	return (StreamedSound**)DB_AllocStreamPos(3);
}

StringList* AllocLoad_StringList()
{
	return (StringList*)DB_AllocStreamPos(3);
}

StringList** AllocLoad_StringListPtr()
{
	return (StringList**)DB_AllocStreamPos(3);
}

StringTable* AllocLoad_StringTable()
{
	return (StringTable*)DB_AllocStreamPos(3);
}

StringTable** AllocLoad_StringTablePtr()
{
	return (StringTable**)DB_AllocStreamPos(3);
}

StringTableCell* AllocLoad_StringTableCell()
{
	return (StringTableCell*)DB_AllocStreamPos(3);
}

StringTableCell** AllocLoad_StringTableCellPtr()
{
	return (StringTableCell**)DB_AllocStreamPos(3);
}

StructuredDataDef* AllocLoad_StructuredDataDef()
{
	return (StructuredDataDef*)DB_AllocStreamPos(3);
}

StructuredDataDef** AllocLoad_StructuredDataDefPtr()
{
	return (StructuredDataDef**)DB_AllocStreamPos(3);
}

StructuredDataDefSet* AllocLoad_StructuredDataDefSet()
{
	return (StructuredDataDefSet*)DB_AllocStreamPos(3);
}

StructuredDataDefSet** AllocLoad_StructuredDataDefSetPtr()
{
	return (StructuredDataDefSet**)DB_AllocStreamPos(3);
}

StructuredDataEnum* AllocLoad_StructuredDataEnum()
{
	return (StructuredDataEnum*)DB_AllocStreamPos(3);
}

StructuredDataEnum** AllocLoad_StructuredDataEnumPtr()
{
	return (StructuredDataEnum**)DB_AllocStreamPos(3);
}

StructuredDataEnumEntry* AllocLoad_StructuredDataEnumEntry()
{
	return (StructuredDataEnumEntry*)DB_AllocStreamPos(3);
}

StructuredDataEnumEntry** AllocLoad_StructuredDataEnumEntryPtr()
{
	return (StructuredDataEnumEntry**)DB_AllocStreamPos(3);
}

StructuredDataEnumedArray* AllocLoad_StructuredDataEnumedArray()
{
	return (StructuredDataEnumedArray*)DB_AllocStreamPos(3);
}

StructuredDataEnumedArray** AllocLoad_StructuredDataEnumedArrayPtr()
{
	return (StructuredDataEnumedArray**)DB_AllocStreamPos(3);
}

StructuredDataIndexedArray* AllocLoad_StructuredDataIndexedArray()
{
	return (StructuredDataIndexedArray*)DB_AllocStreamPos(3);
}

StructuredDataIndexedArray** AllocLoad_StructuredDataIndexedArrayPtr()
{
	return (StructuredDataIndexedArray**)DB_AllocStreamPos(3);
}

StructuredDataStruct* AllocLoad_StructuredDataStruct()
{
	return (StructuredDataStruct*)DB_AllocStreamPos(3);
}

StructuredDataStruct** AllocLoad_StructuredDataStructPtr()
{
	return (StructuredDataStruct**)DB_AllocStreamPos(3);
}

StructuredDataStructProperty* AllocLoad_StructuredDataStructProperty()
{
	return (StructuredDataStructProperty*)DB_AllocStreamPos(3);
}

StructuredDataStructProperty** AllocLoad_StructuredDataStructPropertyPtr()
{
	return (StructuredDataStructProperty**)DB_AllocStreamPos(3);
}

StructuredDataType* AllocLoad_StructuredDataType()
{
	return (StructuredDataType*)DB_AllocStreamPos(3);
}

StructuredDataType** AllocLoad_StructuredDataTypePtr()
{
	return (StructuredDataType**)DB_AllocStreamPos(3);
}

StructuredDataTypeUnion* AllocLoad_StructuredDataTypeUnion()
{
	return (StructuredDataTypeUnion*)DB_AllocStreamPos(3);
}

StructuredDataTypeUnion** AllocLoad_StructuredDataTypeUnionPtr()
{
	return (StructuredDataTypeUnion**)DB_AllocStreamPos(3);
}

TempString* AllocLoad_TempString()
{
	return (TempString*)DB_AllocStreamPos(0);
}

TempString** AllocLoad_TempStringPtr()
{
	return (TempString**)DB_AllocStreamPos(0);
}

TracerDef* AllocLoad_TracerDef()
{
	return (TracerDef*)DB_AllocStreamPos(3);
}

TracerDef** AllocLoad_TracerDefPtr()
{
	return (TracerDef**)DB_AllocStreamPos(3);
}

TriIndice* AllocLoad_TriIndice()
{
	return (TriIndice*)DB_AllocStreamPos(15);
}

TriIndice** AllocLoad_TriIndicePtr()
{
	return (TriIndice**)DB_AllocStreamPos(15);
}

TriggerHull* AllocLoad_TriggerHull()
{
	return (TriggerHull*)DB_AllocStreamPos(3);
}

TriggerHull** AllocLoad_TriggerHullPtr()
{
	return (TriggerHull**)DB_AllocStreamPos(3);
}

TriggerModel* AllocLoad_TriggerModel()
{
	return (TriggerModel*)DB_AllocStreamPos(3);
}

TriggerModel** AllocLoad_TriggerModelPtr()
{
	return (TriggerModel**)DB_AllocStreamPos(3);
}

TriggerSlab* AllocLoad_TriggerSlab()
{
	return (TriggerSlab*)DB_AllocStreamPos(3);
}

TriggerSlab** AllocLoad_TriggerSlabPtr()
{
	return (TriggerSlab**)DB_AllocStreamPos(3);
}

UIFunctionList* AllocLoad_UIFunctionList()
{
	return (UIFunctionList*)DB_AllocStreamPos(3);
}

UIFunctionList** AllocLoad_UIFunctionListPtr()
{
	return (UIFunctionList**)DB_AllocStreamPos(3);
}

WaterWritable* AllocLoad_WaterWritable()
{
	return (WaterWritable*)DB_AllocStreamPos(3);
}

WaterWritable** AllocLoad_WaterWritablePtr()
{
	return (WaterWritable**)DB_AllocStreamPos(3);
}

XAnimDeltaPart* AllocLoad_XAnimDeltaPart()
{
	return (XAnimDeltaPart*)DB_AllocStreamPos(3);
}

XAnimDeltaPart** AllocLoad_XAnimDeltaPartPtr()
{
	return (XAnimDeltaPart**)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuat* AllocLoad_XAnimDeltaPartQuat()
{
	return (XAnimDeltaPartQuat*)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuat** AllocLoad_XAnimDeltaPartQuatPtr()
{
	return (XAnimDeltaPartQuat**)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuat2* AllocLoad_XAnimDeltaPartQuat2()
{
	return (XAnimDeltaPartQuat2*)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuat2** AllocLoad_XAnimDeltaPartQuat2Ptr()
{
	return (XAnimDeltaPartQuat2**)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatData* AllocLoad_XAnimDeltaPartQuatData()
{
	return (XAnimDeltaPartQuatData*)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatData** AllocLoad_XAnimDeltaPartQuatDataPtr()
{
	return (XAnimDeltaPartQuatData**)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatData2* AllocLoad_XAnimDeltaPartQuatData2()
{
	return (XAnimDeltaPartQuatData2*)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatData2** AllocLoad_XAnimDeltaPartQuatData2Ptr()
{
	return (XAnimDeltaPartQuatData2**)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatDataFrames* AllocLoad_XAnimDeltaPartQuatDataFrames()
{
	return (XAnimDeltaPartQuatDataFrames*)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatDataFrames** AllocLoad_XAnimDeltaPartQuatDataFramesPtr()
{
	return (XAnimDeltaPartQuatDataFrames**)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatDataFrames2* AllocLoad_XAnimDeltaPartQuatDataFrames2()
{
	return (XAnimDeltaPartQuatDataFrames2*)DB_AllocStreamPos(3);
}

XAnimDeltaPartQuatDataFrames2** AllocLoad_XAnimDeltaPartQuatDataFrames2Ptr()
{
	return (XAnimDeltaPartQuatDataFrames2**)DB_AllocStreamPos(3);
}

XAnimDynamicFrames* AllocLoad_XAnimDynamicFrames()
{
	return (XAnimDynamicFrames*)DB_AllocStreamPos(3);
}

XAnimDynamicFrames** AllocLoad_XAnimDynamicFramesPtr()
{
	return (XAnimDynamicFrames**)DB_AllocStreamPos(3);
}

XAnimDynamicIndices* AllocLoad_XAnimDynamicIndices()
{
	return (XAnimDynamicIndices*)DB_AllocStreamPos(3);
}

XAnimDynamicIndices** AllocLoad_XAnimDynamicIndicesPtr()
{
	return (XAnimDynamicIndices**)DB_AllocStreamPos(3);
}

XAnimIndices* AllocLoad_XAnimIndices()
{
	return (XAnimIndices*)DB_AllocStreamPos(3);
}

XAnimIndices** AllocLoad_XAnimIndicesPtr()
{
	return (XAnimIndices**)DB_AllocStreamPos(3);
}

XAnimNotifyInfo* AllocLoad_XAnimNotifyInfo()
{
	return (XAnimNotifyInfo*)DB_AllocStreamPos(3);
}

XAnimNotifyInfo** AllocLoad_XAnimNotifyInfoPtr()
{
	return (XAnimNotifyInfo**)DB_AllocStreamPos(3);
}

XAnimPartTrans* AllocLoad_XAnimPartTrans()
{
	return (XAnimPartTrans*)DB_AllocStreamPos(3);
}

XAnimPartTrans** AllocLoad_XAnimPartTransPtr()
{
	return (XAnimPartTrans**)DB_AllocStreamPos(3);
}

XAnimPartTransData* AllocLoad_XAnimPartTransData()
{
	return (XAnimPartTransData*)DB_AllocStreamPos(3);
}

XAnimPartTransData** AllocLoad_XAnimPartTransDataPtr()
{
	return (XAnimPartTransData**)DB_AllocStreamPos(3);
}

XAnimPartTransFrames* AllocLoad_XAnimPartTransFrames()
{
	return (XAnimPartTransFrames*)DB_AllocStreamPos(3);
}

XAnimPartTransFrames** AllocLoad_XAnimPartTransFramesPtr()
{
	return (XAnimPartTransFrames**)DB_AllocStreamPos(3);
}

XAnimParts* AllocLoad_XAnimParts()
{
	return (XAnimParts*)DB_AllocStreamPos(3);
}

XAnimParts** AllocLoad_XAnimPartsPtr()
{
	return (XAnimParts**)DB_AllocStreamPos(3);
}

XAsset* AllocLoad_XAsset()
{
	return (XAsset*)DB_AllocStreamPos(3);
}

XAsset** AllocLoad_XAssetPtr()
{
	return (XAsset**)DB_AllocStreamPos(3);
}

XAssetHeader* AllocLoad_XAssetHeader()
{
	return (XAssetHeader*)DB_AllocStreamPos(3);
}

XAssetHeader** AllocLoad_XAssetHeaderPtr()
{
	return (XAssetHeader**)DB_AllocStreamPos(3);
}

XAssetList* AllocLoad_XAssetList()
{
	return (XAssetList*)DB_AllocStreamPos(3);
}

XAssetList** AllocLoad_XAssetListPtr()
{
	return (XAssetList**)DB_AllocStreamPos(3);
}

XBoneInfo* AllocLoad_XBoneInfo()
{
	return (XBoneInfo*)DB_AllocStreamPos(3);
}

XBoneInfo** AllocLoad_XBoneInfoPtr()
{
	return (XBoneInfo**)DB_AllocStreamPos(3);
}

XModel* AllocLoad_XModel()
{
	return (XModel*)DB_AllocStreamPos(3);
}

XModel** AllocLoad_XModelPtr()
{
	return (XModel**)DB_AllocStreamPos(3);
}

XModelCollSurf_s* AllocLoad_XModelCollSurf_s()
{
	return (XModelCollSurf_s*)DB_AllocStreamPos(3);
}

XModelCollSurf_s** AllocLoad_XModelCollSurf_sPtr()
{
	return (XModelCollSurf_s**)DB_AllocStreamPos(3);
}

XModelCollTri_s* AllocLoad_XModelCollTri_s()
{
	return (XModelCollTri_s*)DB_AllocStreamPos(3);
}

XModelCollTri_s** AllocLoad_XModelCollTri_sPtr()
{
	return (XModelCollTri_s**)DB_AllocStreamPos(3);
}

XModelLodInfo* AllocLoad_XModelLodInfo()
{
	return (XModelLodInfo*)DB_AllocStreamPos(3);
}

XModelLodInfo** AllocLoad_XModelLodInfoPtr()
{
	return (XModelLodInfo**)DB_AllocStreamPos(3);
}

XModelSurfs* AllocLoad_XModelSurfs()
{
	return (XModelSurfs*)DB_AllocStreamPos(3);
}

XModelSurfs** AllocLoad_XModelSurfsPtr()
{
	return (XModelSurfs**)DB_AllocStreamPos(3);
}

XRigidVertList* AllocLoad_XRigidVertList()
{
	return (XRigidVertList*)DB_AllocStreamPos(3);
}

XRigidVertList** AllocLoad_XRigidVertListPtr()
{
	return (XRigidVertList**)DB_AllocStreamPos(3);
}

XString* AllocLoad_XString()
{
	return (XString*)DB_AllocStreamPos(0);
}

XString** AllocLoad_XStringPtr()
{
	return (XString**)DB_AllocStreamPos(0);
}

XSurface* AllocLoad_XSurface()
{
	return (XSurface*)DB_AllocStreamPos(3);
}

XSurface** AllocLoad_XSurfacePtr()
{
	return (XSurface**)DB_AllocStreamPos(3);
}

XSurfaceCollisionAabb* AllocLoad_XSurfaceCollisionAabb()
{
	return (XSurfaceCollisionAabb*)DB_AllocStreamPos(3);
}

XSurfaceCollisionAabb** AllocLoad_XSurfaceCollisionAabbPtr()
{
	return (XSurfaceCollisionAabb**)DB_AllocStreamPos(3);
}

XSurfaceCollisionLeaf* AllocLoad_XSurfaceCollisionLeaf()
{
	return (XSurfaceCollisionLeaf*)DB_AllocStreamPos(1);
}

XSurfaceCollisionLeaf** AllocLoad_XSurfaceCollisionLeafPtr()
{
	return (XSurfaceCollisionLeaf**)DB_AllocStreamPos(1);
}

XSurfaceCollisionNode* AllocLoad_XSurfaceCollisionNode()
{
	return (XSurfaceCollisionNode*)DB_AllocStreamPos(15);
}

XSurfaceCollisionNode** AllocLoad_XSurfaceCollisionNodePtr()
{
	return (XSurfaceCollisionNode**)DB_AllocStreamPos(15);
}

XSurfaceCollisionTree* AllocLoad_XSurfaceCollisionTree()
{
	return (XSurfaceCollisionTree*)DB_AllocStreamPos(3);
}

XSurfaceCollisionTree** AllocLoad_XSurfaceCollisionTreePtr()
{
	return (XSurfaceCollisionTree**)DB_AllocStreamPos(3);
}

XSurfaceVertexInfo* AllocLoad_XSurfaceVertexInfo()
{
	return (XSurfaceVertexInfo*)DB_AllocStreamPos(3);
}

XSurfaceVertexInfo** AllocLoad_XSurfaceVertexInfoPtr()
{
	return (XSurfaceVertexInfo**)DB_AllocStreamPos(3);
}

_AILSOUNDINFO* AllocLoad__AILSOUNDINFO()
{
	return (_AILSOUNDINFO*)DB_AllocStreamPos(3);
}

_AILSOUNDINFO** AllocLoad__AILSOUNDINFOPtr()
{
	return (_AILSOUNDINFO**)DB_AllocStreamPos(3);
}

bool* AllocLoad_bool()
{
	return (bool*)DB_AllocStreamPos(0);
}

bool** AllocLoad_boolPtr()
{
	return (bool**)DB_AllocStreamPos(0);
}

cLeafBrushNodeChildren_t* AllocLoad_cLeafBrushNodeChildren_t()
{
	return (cLeafBrushNodeChildren_t*)DB_AllocStreamPos(3);
}

cLeafBrushNodeChildren_t** AllocLoad_cLeafBrushNodeChildren_tPtr()
{
	return (cLeafBrushNodeChildren_t**)DB_AllocStreamPos(3);
}

cLeafBrushNodeData_t* AllocLoad_cLeafBrushNodeData_t()
{
	return (cLeafBrushNodeData_t*)DB_AllocStreamPos(3);
}

cLeafBrushNodeData_t** AllocLoad_cLeafBrushNodeData_tPtr()
{
	return (cLeafBrushNodeData_t**)DB_AllocStreamPos(3);
}

cLeafBrushNodeLeaf_t* AllocLoad_cLeafBrushNodeLeaf_t()
{
	return (cLeafBrushNodeLeaf_t*)DB_AllocStreamPos(3);
}

cLeafBrushNodeLeaf_t** AllocLoad_cLeafBrushNodeLeaf_tPtr()
{
	return (cLeafBrushNodeLeaf_t**)DB_AllocStreamPos(3);
}

cLeafBrushNode_s* AllocLoad_cLeafBrushNode_s()
{
	return (cLeafBrushNode_s*)DB_AllocStreamPos(3);
}

cLeafBrushNode_s** AllocLoad_cLeafBrushNode_sPtr()
{
	return (cLeafBrushNode_s**)DB_AllocStreamPos(3);
}

cLeaf_t* AllocLoad_cLeaf_t()
{
	return (cLeaf_t*)DB_AllocStreamPos(3);
}

cLeaf_t** AllocLoad_cLeaf_tPtr()
{
	return (cLeaf_t**)DB_AllocStreamPos(3);
}

cNode_t* AllocLoad_cNode_t()
{
	return (cNode_t*)DB_AllocStreamPos(3);
}

cNode_t** AllocLoad_cNode_tPtr()
{
	return (cNode_t**)DB_AllocStreamPos(3);
}

cStaticModel_s* AllocLoad_cStaticModel_s()
{
	return (cStaticModel_s*)DB_AllocStreamPos(3);
}

cStaticModel_s** AllocLoad_cStaticModel_sPtr()
{
	return (cStaticModel_s**)DB_AllocStreamPos(3);
}

cbrush_t* AllocLoad_cbrush_t()
{
	return (cbrush_t*)DB_AllocStreamPos(3);
}

cbrush_t** AllocLoad_cbrush_tPtr()
{
	return (cbrush_t**)DB_AllocStreamPos(3);
}

cbrushside_t* AllocLoad_cbrushside_t()
{
	return (cbrushside_t*)DB_AllocStreamPos(3);
}

cbrushside_t** AllocLoad_cbrushside_tPtr()
{
	return (cbrushside_t**)DB_AllocStreamPos(3);
}

char* AllocLoad_char()
{
	return (char*)DB_AllocStreamPos(0);
}

char** AllocLoad_charPtr()
{
	return (char**)DB_AllocStreamPos(0);
}

char16* AllocLoad_char16()
{
	return (char16*)DB_AllocStreamPos(15);
}

char16** AllocLoad_char16Ptr()
{
	return (char16**)DB_AllocStreamPos(15);
}

clipMap_t* AllocLoad_clipMap_t()
{
	return (clipMap_t*)DB_AllocStreamPos(63);
}

clipMap_t** AllocLoad_clipMap_tPtr()
{
	return (clipMap_t**)DB_AllocStreamPos(63);
}

cmodel_t* AllocLoad_cmodel_t()
{
	return (cmodel_t*)DB_AllocStreamPos(3);
}

cmodel_t** AllocLoad_cmodel_tPtr()
{
	return (cmodel_t**)DB_AllocStreamPos(3);
}

columnInfo_s* AllocLoad_columnInfo_s()
{
	return (columnInfo_s*)DB_AllocStreamPos(3);
}

columnInfo_s** AllocLoad_columnInfo_sPtr()
{
	return (columnInfo_s**)DB_AllocStreamPos(3);
}

complex_s* AllocLoad_complex_s()
{
	return (complex_s*)DB_AllocStreamPos(3);
}

complex_s** AllocLoad_complex_sPtr()
{
	return (complex_s**)DB_AllocStreamPos(3);
}

const char *DB_ComWorldGetName(XAssetHeader* header)
{
	return (*(ComWorld**)header)->name;
}

const char *DB_Font_sGetName(XAssetHeader* header)
{
	return (*(Font_s**)header)->fontName;
}

const char *DB_FxEffectDefGetName(XAssetHeader* header)
{
	return (*(FxEffectDef**)header)->name;
}

const char *DB_FxWorldGetName(XAssetHeader* header)
{
	return (*(FxWorld**)header)->name;
}

const char *DB_GameWorldMpGetName(XAssetHeader* header)
{
	return (*(GameWorldMp**)header)->name;
}

const char *DB_GfxImageGetName(XAssetHeader* header)
{
	return (*(GfxImage**)header)->name;
}

const char *DB_GfxLightDefGetName(XAssetHeader* header)
{
	return (*(GfxLightDef**)header)->name;
}

const char *DB_LeaderboardDefGetName(XAssetHeader* header)
{
	return (*(LeaderboardDef**)header)->name;
}

const char *DB_LocalizeEntryGetName(XAssetHeader* header)
{
	return (*(LocalizeEntry**)header)->name;
}

const char *DB_MapEntsGetName(XAssetHeader* header)
{
	return (*(MapEnts**)header)->name;
}

const char *DB_MaterialGetName(XAssetHeader* header)
{
	return (*(Material**)header)->info.name;
}

const char *DB_MaterialPixelShaderGetName(XAssetHeader* header)
{
	return (*(MaterialPixelShader**)header)->name;
}

const char *DB_MaterialTechniqueSetGetName(XAssetHeader* header)
{
	return (*(MaterialTechniqueSet**)header)->name;
}

const char *DB_MaterialVertexDeclarationGetName(XAssetHeader* header)
{
	return (*(MaterialVertexDeclaration**)header)->name;
}

const char *DB_MaterialVertexShaderGetName(XAssetHeader* header)
{
	return (*(MaterialVertexShader**)header)->name;
}

const char *DB_MenuListGetName(XAssetHeader* header)
{
	return (*(MenuList**)header)->name;
}

const char *DB_PhysCollmapGetName(XAssetHeader* header)
{
	return (*(PhysCollmap**)header)->name;
}

const char *DB_PhysPresetGetName(XAssetHeader* header)
{
	return (*(PhysPreset**)header)->name;
}

const char *DB_RawFileGetName(XAssetHeader* header)
{
	return (*(RawFile**)header)->name;
}

const char *DB_SndCurveGetName(XAssetHeader* header)
{
	return (*(SndCurve**)header)->filename;
}

const char *DB_StringTableGetName(XAssetHeader* header)
{
	return (*(StringTable**)header)->name;
}

const char *DB_StructuredDataDefSetGetName(XAssetHeader* header)
{
	return (*(StructuredDataDefSet**)header)->name;
}

const char *DB_TracerDefGetName(XAssetHeader* header)
{
	return (*(TracerDef**)header)->name;
}

const char *DB_XAnimPartsGetName(XAssetHeader* header)
{
	return (*(XAnimParts**)header)->name;
}

const char *DB_XModelGetName(XAssetHeader* header)
{
	return (*(XModel**)header)->name;
}

const char *DB_XModelSurfsGetName(XAssetHeader* header)
{
	return (*(XModelSurfs**)header)->name;
}

const char *DB_clipMap_tGetName(XAssetHeader* header)
{
	return (*(clipMap_t**)header)->name;
}

const char *DB_menuDef_tGetName(XAssetHeader* header)
{
	return (*(menuDef_t**)header)->window.name;
}

const char *DB_snd_alias_list_tGetName(XAssetHeader* header)
{
	return (*(snd_alias_list_t**)header)->aliasName;
}

cplane_s* AllocLoad_cplane_s()
{
	return (cplane_s*)DB_AllocStreamPos(3);
}

cplane_s** AllocLoad_cplane_sPtr()
{
	return (cplane_s**)DB_AllocStreamPos(3);
}

double* AllocLoad_double()
{
	return (double*)DB_AllocStreamPos(3);
}

double** AllocLoad_doublePtr()
{
	return (double**)DB_AllocStreamPos(3);
}

editFieldDef_s* AllocLoad_editFieldDef_s()
{
	return (editFieldDef_s*)DB_AllocStreamPos(3);
}

editFieldDef_s** AllocLoad_editFieldDef_sPtr()
{
	return (editFieldDef_s**)DB_AllocStreamPos(3);
}

entryInternalData* AllocLoad_entryInternalData()
{
	return (entryInternalData*)DB_AllocStreamPos(3);
}

entryInternalData** AllocLoad_entryInternalDataPtr()
{
	return (entryInternalData**)DB_AllocStreamPos(3);
}

expressionEntry* AllocLoad_expressionEntry()
{
	return (expressionEntry*)DB_AllocStreamPos(3);
}

expressionEntry** AllocLoad_expressionEntryPtr()
{
	return (expressionEntry**)DB_AllocStreamPos(3);
}

float* AllocLoad_float()
{
	return (float*)DB_AllocStreamPos(3);
}

float** AllocLoad_floatPtr()
{
	return (float**)DB_AllocStreamPos(3);
}

float16* AllocLoad_float16()
{
	return (float16*)DB_AllocStreamPos(15);
}

float16** AllocLoad_float16Ptr()
{
	return (float16**)DB_AllocStreamPos(15);
}

int16* AllocLoad_int16()
{
	return (int16*)DB_AllocStreamPos(1);
}

int16** AllocLoad_int16Ptr()
{
	return (int16**)DB_AllocStreamPos(1);
}

int32* AllocLoad_int32()
{
	return (int32*)DB_AllocStreamPos(3);
}

int32** AllocLoad_int32Ptr()
{
	return (int32**)DB_AllocStreamPos(3);
}

int64* AllocLoad_int64()
{
	return (int64*)DB_AllocStreamPos(3);
}

int64** AllocLoad_int64Ptr()
{
	return (int64**)DB_AllocStreamPos(3);
}

int8* AllocLoad_int8()
{
	return (int8*)DB_AllocStreamPos(0);
}

int8** AllocLoad_int8Ptr()
{
	return (int8**)DB_AllocStreamPos(0);
}

itemDefData_t* AllocLoad_itemDefData_t()
{
	return (itemDefData_t*)DB_AllocStreamPos(3);
}

itemDefData_t** AllocLoad_itemDefData_tPtr()
{
	return (itemDefData_t**)DB_AllocStreamPos(3);
}

itemDef_s* AllocLoad_itemDef_s()
{
	return (itemDef_s*)DB_AllocStreamPos(3);
}

itemDef_s** AllocLoad_itemDef_sPtr()
{
	return (itemDef_s**)DB_AllocStreamPos(3);
}

listBoxDef_s* AllocLoad_listBoxDef_s()
{
	return (listBoxDef_s*)DB_AllocStreamPos(3);
}

listBoxDef_s** AllocLoad_listBoxDef_sPtr()
{
	return (listBoxDef_s**)DB_AllocStreamPos(3);
}

menuDef_t* AllocLoad_menuDef_t()
{
	return (menuDef_t*)DB_AllocStreamPos(3);
}

menuDef_t** AllocLoad_menuDef_tPtr()
{
	return (menuDef_t**)DB_AllocStreamPos(3);
}

menuTransition* AllocLoad_menuTransition()
{
	return (menuTransition*)DB_AllocStreamPos(3);
}

menuTransition** AllocLoad_menuTransitionPtr()
{
	return (menuTransition**)DB_AllocStreamPos(3);
}

multiDef_s* AllocLoad_multiDef_s()
{
	return (multiDef_s*)DB_AllocStreamPos(3);
}

multiDef_s** AllocLoad_multiDef_sPtr()
{
	return (multiDef_s**)DB_AllocStreamPos(3);
}

newsTickerDef_s* AllocLoad_newsTickerDef_s()
{
	return (newsTickerDef_s*)DB_AllocStreamPos(3);
}

newsTickerDef_s** AllocLoad_newsTickerDef_sPtr()
{
	return (newsTickerDef_s**)DB_AllocStreamPos(3);
}

operandInternalDataUnion* AllocLoad_operandInternalDataUnion()
{
	return (operandInternalDataUnion*)DB_AllocStreamPos(3);
}

operandInternalDataUnion** AllocLoad_operandInternalDataUnionPtr()
{
	return (operandInternalDataUnion**)DB_AllocStreamPos(3);
}

rectDef_s* AllocLoad_rectDef_s()
{
	return (rectDef_s*)DB_AllocStreamPos(3);
}

rectDef_s** AllocLoad_rectDef_sPtr()
{
	return (rectDef_s**)DB_AllocStreamPos(3);
}

snd_alias_list_t* AllocLoad_snd_alias_list_t()
{
	return (snd_alias_list_t*)DB_AllocStreamPos(3);
}

snd_alias_list_t** AllocLoad_snd_alias_list_tPtr()
{
	return (snd_alias_list_t**)DB_AllocStreamPos(3);
}

snd_alias_t* AllocLoad_snd_alias_t()
{
	return (snd_alias_t*)DB_AllocStreamPos(3);
}

snd_alias_t** AllocLoad_snd_alias_tPtr()
{
	return (snd_alias_t**)DB_AllocStreamPos(3);
}

textScrollDef_s* AllocLoad_textScrollDef_s()
{
	return (textScrollDef_s*)DB_AllocStreamPos(3);
}

textScrollDef_s** AllocLoad_textScrollDef_sPtr()
{
	return (textScrollDef_s**)DB_AllocStreamPos(3);
}

uint16* AllocLoad_uint16()
{
	return (uint16*)DB_AllocStreamPos(1);
}

uint16** AllocLoad_uint16Ptr()
{
	return (uint16**)DB_AllocStreamPos(1);
}

uint32* AllocLoad_uint32()
{
	return (uint32*)DB_AllocStreamPos(3);
}

uint32** AllocLoad_uint32Ptr()
{
	return (uint32**)DB_AllocStreamPos(3);
}

uint64* AllocLoad_uint64()
{
	return (uint64*)DB_AllocStreamPos(3);
}

uint64** AllocLoad_uint64Ptr()
{
	return (uint64**)DB_AllocStreamPos(3);
}

uint8* AllocLoad_uint8()
{
	return (uint8*)DB_AllocStreamPos(0);
}

uint8** AllocLoad_uint8Ptr()
{
	return (uint8**)DB_AllocStreamPos(0);
}

vec1_t* AllocLoad_vec1_t()
{
	return (vec1_t*)DB_AllocStreamPos(3);
}

vec1_t** AllocLoad_vec1_tPtr()
{
	return (vec1_t**)DB_AllocStreamPos(3);
}

vec2_t* AllocLoad_vec2_t()
{
	return (vec2_t*)DB_AllocStreamPos(3);
}

vec2_t** AllocLoad_vec2_tPtr()
{
	return (vec2_t**)DB_AllocStreamPos(3);
}

vec3_t* AllocLoad_vec3_t()
{
	return (vec3_t*)DB_AllocStreamPos(3);
}

vec3_t** AllocLoad_vec3_tPtr()
{
	return (vec3_t**)DB_AllocStreamPos(3);
}

vec4_t* AllocLoad_vec4_t()
{
	return (vec4_t*)DB_AllocStreamPos(3);
}

vec4_t** AllocLoad_vec4_tPtr()
{
	return (vec4_t**)DB_AllocStreamPos(3);
}

void Load_$C8D87EB0090687D323381DFB7A82089C(bool atStreamStart)
{
	Load_Stream(atStreamStart, var$C8D87EB0090687D323381DFB7A82089C, sizeof($C8D87EB0090687D323381DFB7A82089C));

}

void Load_$C8D87EB0090687D323381DFB7A82089CArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, var$C8D87EB0090687D323381DFB7A82089C, sizeof($C8D87EB0090687D323381DFB7A82089C) * count);
	$C8D87EB0090687D323381DFB7A82089C* pointer = var$C8D87EB0090687D323381DFB7A82089C;
	for (int i = 0; i < count; i++)
	{
		var$C8D87EB0090687D323381DFB7A82089C = pointer;
		Load_$C8D87EB0090687D323381DFB7A82089C(false);
		pointer++;
	}
}

void Load_$C8D87EB0090687D323381DFB7A82089CPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, var$C8D87EB0090687D323381DFB7A82089C, sizeof($C8D87EB0090687D323381DFB7A82089C));
	if (*var$C8D87EB0090687D323381DFB7A82089CPtr != nullptr)
	{
		if (*var$C8D87EB0090687D323381DFB7A82089CPtr == ($C8D87EB0090687D323381DFB7A82089C*)0xFFFFFFFF)
		{
			*var$C8D87EB0090687D323381DFB7A82089CPtr = AllocLoad_$C8D87EB0090687D323381DFB7A82089C();
			var$C8D87EB0090687D323381DFB7A82089C = *var$C8D87EB0090687D323381DFB7A82089CPtr;
			Load_$C8D87EB0090687D323381DFB7A82089C(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)var$C8D87EB0090687D323381DFB7A82089CPtr);
		}
	}
}

void Load_$C8D87EB0090687D323381DFB7A82089CPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, var$C8D87EB0090687D323381DFB7A82089CPtr, sizeof($C8D87EB0090687D323381DFB7A82089C*) * count);
	$C8D87EB0090687D323381DFB7A82089C** pointer = var$C8D87EB0090687D323381DFB7A82089CPtr;
	for (int i = 0; i < count; i++)
	{
		var$C8D87EB0090687D323381DFB7A82089CPtr = pointer;
		Load_$C8D87EB0090687D323381DFB7A82089CPtr(false);
		pointer++;
	}
}

void Load_$E43DBA5037697D705289B74D87E76C70(bool atStreamStart)
{
	Load_Stream(atStreamStart, var$E43DBA5037697D705289B74D87E76C70, sizeof($E43DBA5037697D705289B74D87E76C70));

	varFxSpatialFrame = &var$E43DBA5037697D705289B74D87E76C70->frame;
	Load_FxSpatialFrame(false);

}

void Load_$E43DBA5037697D705289B74D87E76C70Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, var$E43DBA5037697D705289B74D87E76C70, sizeof($E43DBA5037697D705289B74D87E76C70) * count);
	$E43DBA5037697D705289B74D87E76C70* pointer = var$E43DBA5037697D705289B74D87E76C70;
	for (int i = 0; i < count; i++)
	{
		var$E43DBA5037697D705289B74D87E76C70 = pointer;
		Load_$E43DBA5037697D705289B74D87E76C70(false);
		pointer++;
	}
}

void Load_$E43DBA5037697D705289B74D87E76C70Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, var$E43DBA5037697D705289B74D87E76C70, sizeof($E43DBA5037697D705289B74D87E76C70));
	if (*var$E43DBA5037697D705289B74D87E76C70Ptr != nullptr)
	{
		if (*var$E43DBA5037697D705289B74D87E76C70Ptr == ($E43DBA5037697D705289B74D87E76C70*)0xFFFFFFFF)
		{
			*var$E43DBA5037697D705289B74D87E76C70Ptr = AllocLoad_$E43DBA5037697D705289B74D87E76C70();
			var$E43DBA5037697D705289B74D87E76C70 = *var$E43DBA5037697D705289B74D87E76C70Ptr;
			Load_$E43DBA5037697D705289B74D87E76C70(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)var$E43DBA5037697D705289B74D87E76C70Ptr);
		}
	}
}

void Load_$E43DBA5037697D705289B74D87E76C70PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, var$E43DBA5037697D705289B74D87E76C70Ptr, sizeof($E43DBA5037697D705289B74D87E76C70*) * count);
	$E43DBA5037697D705289B74D87E76C70** pointer = var$E43DBA5037697D705289B74D87E76C70Ptr;
	for (int i = 0; i < count; i++)
	{
		var$E43DBA5037697D705289B74D87E76C70Ptr = pointer;
		Load_$E43DBA5037697D705289B74D87E76C70Ptr(false);
		pointer++;
	}
}

void Load_Bounds(bool atStreamStart)
{
	Load_Stream(atStreamStart, varBounds, sizeof(Bounds));

}

void Load_BoundsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varBounds, sizeof(Bounds) * count);
	Bounds* pointer = varBounds;
	for (int i = 0; i < count; i++)
	{
		varBounds = pointer;
		Load_Bounds(false);
		pointer++;
	}
}

void Load_BoundsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varBounds, sizeof(Bounds));
	if (*varBoundsPtr != nullptr)
	{
		if (*varBoundsPtr == (Bounds*)0xFFFFFFFF)
		{
			*varBoundsPtr = AllocLoad_Bounds();
			varBounds = *varBoundsPtr;
			Load_Bounds(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varBoundsPtr);
		}
	}
}

void Load_BoundsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varBoundsPtr, sizeof(Bounds*) * count);
	Bounds** pointer = varBoundsPtr;
	for (int i = 0; i < count; i++)
	{
		varBoundsPtr = pointer;
		Load_BoundsPtr(false);
		pointer++;
	}
}

void Load_BrushWrapper(bool atStreamStart)
{
	Load_Stream(atStreamStart, varBrushWrapper, sizeof(BrushWrapper));

	varBounds = &varBrushWrapper->bounds;
	Load_Bounds(false);

	varcbrush_t = &varBrushWrapper->brush;
	Load_cbrush_t(false);

	if (varBrushWrapper->planes)
	{
		varcplane_sPtr = &varBrushWrapper->planes;
		Load_cplane_sPtr(false);
	}

}

void Load_BrushWrapperArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varBrushWrapper, sizeof(BrushWrapper) * count);
	BrushWrapper* pointer = varBrushWrapper;
	for (int i = 0; i < count; i++)
	{
		varBrushWrapper = pointer;
		Load_BrushWrapper(false);
		pointer++;
	}
}

void Load_BrushWrapperPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varBrushWrapper, sizeof(BrushWrapper));
	if (*varBrushWrapperPtr != nullptr)
	{
		if (*varBrushWrapperPtr == (BrushWrapper*)0xFFFFFFFF)
		{
			*varBrushWrapperPtr = AllocLoad_BrushWrapper();
			varBrushWrapper = *varBrushWrapperPtr;
			Load_BrushWrapper(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varBrushWrapperPtr);
		}
	}
}

void Load_BrushWrapperPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varBrushWrapperPtr, sizeof(BrushWrapper*) * count);
	BrushWrapper** pointer = varBrushWrapperPtr;
	for (int i = 0; i < count; i++)
	{
		varBrushWrapperPtr = pointer;
		Load_BrushWrapperPtr(false);
		pointer++;
	}
}

void Load_CardMemory(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCardMemory, sizeof(CardMemory));

}

void Load_CardMemoryArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCardMemory, sizeof(CardMemory) * count);
	CardMemory* pointer = varCardMemory;
	for (int i = 0; i < count; i++)
	{
		varCardMemory = pointer;
		Load_CardMemory(false);
		pointer++;
	}
}

void Load_CardMemoryPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCardMemory, sizeof(CardMemory));
	if (*varCardMemoryPtr != nullptr)
	{
		*varCardMemoryPtr = AllocLoad_CardMemory();
		varCardMemory = *varCardMemoryPtr;
		Load_CardMemory(true);
	}
}

void Load_CardMemoryPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCardMemoryPtr, sizeof(CardMemory*) * count);
	CardMemory** pointer = varCardMemoryPtr;
	for (int i = 0; i < count; i++)
	{
		varCardMemoryPtr = pointer;
		Load_CardMemoryPtr(false);
		pointer++;
	}
}

void Load_ClipMaterial(bool atStreamStart)
{
	Load_Stream(atStreamStart, varClipMaterial, sizeof(ClipMaterial));

	varXString = &varClipMaterial->name;
	Load_XString(false);

}

void Load_ClipMaterialArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varClipMaterial, sizeof(ClipMaterial) * count);
	ClipMaterial* pointer = varClipMaterial;
	for (int i = 0; i < count; i++)
	{
		varClipMaterial = pointer;
		Load_ClipMaterial(false);
		pointer++;
	}
}

void Load_ClipMaterialPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varClipMaterial, sizeof(ClipMaterial));
	if (*varClipMaterialPtr != nullptr)
	{
		if (*varClipMaterialPtr == (ClipMaterial*)0xFFFFFFFF)
		{
			*varClipMaterialPtr = AllocLoad_ClipMaterial();
			varClipMaterial = *varClipMaterialPtr;
			Load_ClipMaterial(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varClipMaterialPtr);
		}
	}
}

void Load_ClipMaterialPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varClipMaterialPtr, sizeof(ClipMaterial*) * count);
	ClipMaterial** pointer = varClipMaterialPtr;
	for (int i = 0; i < count; i++)
	{
		varClipMaterialPtr = pointer;
		Load_ClipMaterialPtr(false);
		pointer++;
	}
}

void Load_CollisionAabbTree(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionAabbTree, sizeof(CollisionAabbTree));

	varCollisionAabbTreeIndex = &varCollisionAabbTree->u;
	Load_CollisionAabbTreeIndex(false);

}

void Load_CollisionAabbTreeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionAabbTree, sizeof(CollisionAabbTree) * count);
	CollisionAabbTree* pointer = varCollisionAabbTree;
	for (int i = 0; i < count; i++)
	{
		varCollisionAabbTree = pointer;
		Load_CollisionAabbTree(false);
		pointer++;
	}
}

void Load_CollisionAabbTreeIndex(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionAabbTreeIndex, sizeof(CollisionAabbTreeIndex));

}

void Load_CollisionAabbTreeIndexArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionAabbTreeIndex, sizeof(CollisionAabbTreeIndex) * count);
	CollisionAabbTreeIndex* pointer = varCollisionAabbTreeIndex;
	for (int i = 0; i < count; i++)
	{
		varCollisionAabbTreeIndex = pointer;
		Load_CollisionAabbTreeIndex(false);
		pointer++;
	}
}

void Load_CollisionAabbTreeIndexPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionAabbTreeIndex, sizeof(CollisionAabbTreeIndex));
	if (*varCollisionAabbTreeIndexPtr != nullptr)
	{
		if (*varCollisionAabbTreeIndexPtr == (CollisionAabbTreeIndex*)0xFFFFFFFF)
		{
			*varCollisionAabbTreeIndexPtr = AllocLoad_CollisionAabbTreeIndex();
			varCollisionAabbTreeIndex = *varCollisionAabbTreeIndexPtr;
			Load_CollisionAabbTreeIndex(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varCollisionAabbTreeIndexPtr);
		}
	}
}

void Load_CollisionAabbTreeIndexPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionAabbTreeIndexPtr, sizeof(CollisionAabbTreeIndex*) * count);
	CollisionAabbTreeIndex** pointer = varCollisionAabbTreeIndexPtr;
	for (int i = 0; i < count; i++)
	{
		varCollisionAabbTreeIndexPtr = pointer;
		Load_CollisionAabbTreeIndexPtr(false);
		pointer++;
	}
}

void Load_CollisionAabbTreePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionAabbTree, sizeof(CollisionAabbTree));
	if (*varCollisionAabbTreePtr != nullptr)
	{
		if (*varCollisionAabbTreePtr == (CollisionAabbTree*)0xFFFFFFFF)
		{
			*varCollisionAabbTreePtr = AllocLoad_CollisionAabbTree();
			varCollisionAabbTree = *varCollisionAabbTreePtr;
			Load_CollisionAabbTree(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varCollisionAabbTreePtr);
		}
	}
}

void Load_CollisionAabbTreePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionAabbTreePtr, sizeof(CollisionAabbTree*) * count);
	CollisionAabbTree** pointer = varCollisionAabbTreePtr;
	for (int i = 0; i < count; i++)
	{
		varCollisionAabbTreePtr = pointer;
		Load_CollisionAabbTreePtr(false);
		pointer++;
	}
}

void Load_CollisionBorder(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionBorder, sizeof(CollisionBorder));

}

void Load_CollisionBorderArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionBorder, sizeof(CollisionBorder) * count);
	CollisionBorder* pointer = varCollisionBorder;
	for (int i = 0; i < count; i++)
	{
		varCollisionBorder = pointer;
		Load_CollisionBorder(false);
		pointer++;
	}
}

void Load_CollisionBorderPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionBorder, sizeof(CollisionBorder));
	if (*varCollisionBorderPtr != nullptr)
	{
		if (*varCollisionBorderPtr == (CollisionBorder*)0xFFFFFFFF)
		{
			*varCollisionBorderPtr = AllocLoad_CollisionBorder();
			varCollisionBorder = *varCollisionBorderPtr;
			Load_CollisionBorder(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varCollisionBorderPtr);
		}
	}
}

void Load_CollisionBorderPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionBorderPtr, sizeof(CollisionBorder*) * count);
	CollisionBorder** pointer = varCollisionBorderPtr;
	for (int i = 0; i < count; i++)
	{
		varCollisionBorderPtr = pointer;
		Load_CollisionBorderPtr(false);
		pointer++;
	}
}

void Load_CollisionPartition(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionPartition, sizeof(CollisionPartition));

	if (varCollisionPartition->borders)
	{
		if (varCollisionPartition->borders == (CollisionBorder*)0xFFFFFFFF)
		{
			varCollisionPartition->borders = AllocLoad_CollisionBorder();
			varCollisionBorder = varCollisionPartition->borders;
			Load_CollisionBorderArray(true, (varCollisionPartition->borderCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varCollisionPartition->borders);
		}
	}

}

void Load_CollisionPartitionArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionPartition, sizeof(CollisionPartition) * count);
	CollisionPartition* pointer = varCollisionPartition;
	for (int i = 0; i < count; i++)
	{
		varCollisionPartition = pointer;
		Load_CollisionPartition(false);
		pointer++;
	}
}

void Load_CollisionPartitionPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varCollisionPartition, sizeof(CollisionPartition));
	if (*varCollisionPartitionPtr != nullptr)
	{
		if (*varCollisionPartitionPtr == (CollisionPartition*)0xFFFFFFFF)
		{
			*varCollisionPartitionPtr = AllocLoad_CollisionPartition();
			varCollisionPartition = *varCollisionPartitionPtr;
			Load_CollisionPartition(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varCollisionPartitionPtr);
		}
	}
}

void Load_CollisionPartitionPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varCollisionPartitionPtr, sizeof(CollisionPartition*) * count);
	CollisionPartition** pointer = varCollisionPartitionPtr;
	for (int i = 0; i < count; i++)
	{
		varCollisionPartitionPtr = pointer;
		Load_CollisionPartitionPtr(false);
		pointer++;
	}
}

void Load_ComPrimaryLight(bool atStreamStart)
{
	Load_Stream(atStreamStart, varComPrimaryLight, sizeof(ComPrimaryLight));

	varXString = &varComPrimaryLight->defName;
	Load_XString(false);

}

void Load_ComPrimaryLightArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varComPrimaryLight, sizeof(ComPrimaryLight) * count);
	ComPrimaryLight* pointer = varComPrimaryLight;
	for (int i = 0; i < count; i++)
	{
		varComPrimaryLight = pointer;
		Load_ComPrimaryLight(false);
		pointer++;
	}
}

void Load_ComPrimaryLightPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varComPrimaryLight, sizeof(ComPrimaryLight));
	if (*varComPrimaryLightPtr != nullptr)
	{
		if (*varComPrimaryLightPtr == (ComPrimaryLight*)0xFFFFFFFF)
		{
			*varComPrimaryLightPtr = AllocLoad_ComPrimaryLight();
			varComPrimaryLight = *varComPrimaryLightPtr;
			Load_ComPrimaryLight(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varComPrimaryLightPtr);
		}
	}
}

void Load_ComPrimaryLightPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varComPrimaryLightPtr, sizeof(ComPrimaryLight*) * count);
	ComPrimaryLight** pointer = varComPrimaryLightPtr;
	for (int i = 0; i < count; i++)
	{
		varComPrimaryLightPtr = pointer;
		Load_ComPrimaryLightPtr(false);
		pointer++;
	}
}

void Load_ComWorld(bool atStreamStart)
{
	Load_Stream(atStreamStart, varComWorld, sizeof(ComWorld));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varComWorld->name;
	Load_XString(false);

	if (varComWorld->primaryLights)
	{
		if (varComWorld->primaryLights == (ComPrimaryLight*)0xFFFFFFFF)
		{
			varComWorld->primaryLights = AllocLoad_ComPrimaryLight();
			varComPrimaryLight = varComWorld->primaryLights;
			Load_ComPrimaryLightArray(true, (varComWorld->primaryLightCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varComWorld->primaryLights);
		}
	}

	DB_PopStreamPos();
}

void Load_ComWorldArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varComWorld, sizeof(ComWorld) * count);
	ComWorld* pointer = varComWorld;
	for (int i = 0; i < count; i++)
	{
		varComWorld = pointer;
		Load_ComWorld(false);
		pointer++;
	}
}

void Load_ComWorldAsset(ComWorld** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_COMWORLD, (void**)varComWorldPtr);
}

void Load_ComWorldPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varComWorld, sizeof(ComWorld*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	ComWorld* pointer = *varComWorldPtr;
	if (*varComWorldPtr != nullptr)
	{
		if (*varComWorldPtr == (ComWorld*)0xFFFFFFFF || *varComWorldPtr == (ComWorld*)0xFFFFFFFE)
		{
			*varComWorldPtr = AllocLoad_ComWorld();
			varComWorld = *varComWorldPtr;
			ComWorld** insertedPointer = nullptr;
			if (pointer == (ComWorld*)0xFFFFFFFE)
			{
				insertedPointer = (ComWorld**)DB_InsertPointer();
			}
			Load_ComWorld(true);
			Load_ComWorldAsset(varComWorldPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varComWorldPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varComWorldPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_ComWorldPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varComWorldPtr, sizeof(ComWorld*) * count);
	ComWorld** pointer = varComWorldPtr;
	for (int i = 0; i < count; i++)
	{
		varComWorldPtr = pointer;
		Load_ComWorldPtr(false);
		pointer++;
	}
}

void Load_ConditionalScript(bool atStreamStart)
{
	Load_Stream(atStreamStart, varConditionalScript, sizeof(ConditionalScript));

	if (varConditionalScript->eventExpression)
	{
		varStatement_sPtr = &varConditionalScript->eventExpression;
		Load_Statement_sPtr(false);
	}

	if (varConditionalScript->eventHandlerSet)
	{
		varMenuEventHandlerSetPtr = &varConditionalScript->eventHandlerSet;
		Load_MenuEventHandlerSetPtr(false);
	}

}

void Load_ConditionalScriptArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varConditionalScript, sizeof(ConditionalScript) * count);
	ConditionalScript* pointer = varConditionalScript;
	for (int i = 0; i < count; i++)
	{
		varConditionalScript = pointer;
		Load_ConditionalScript(false);
		pointer++;
	}
}

void Load_ConditionalScriptPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varConditionalScript, sizeof(ConditionalScript));
	if (*varConditionalScriptPtr != nullptr)
	{
		if (*varConditionalScriptPtr == (ConditionalScript*)0xFFFFFFFF)
		{
			*varConditionalScriptPtr = AllocLoad_ConditionalScript();
			varConditionalScript = *varConditionalScriptPtr;
			Load_ConditionalScript(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varConditionalScriptPtr);
		}
	}
}

void Load_ConditionalScriptPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varConditionalScriptPtr, sizeof(ConditionalScript*) * count);
	ConditionalScript** pointer = varConditionalScriptPtr;
	for (int i = 0; i < count; i++)
	{
		varConditionalScriptPtr = pointer;
		Load_ConditionalScriptPtr(false);
		pointer++;
	}
}

void Load_DObjAnimMat(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDObjAnimMat, sizeof(DObjAnimMat));

}

void Load_DObjAnimMatArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDObjAnimMat, sizeof(DObjAnimMat) * count);
	DObjAnimMat* pointer = varDObjAnimMat;
	for (int i = 0; i < count; i++)
	{
		varDObjAnimMat = pointer;
		Load_DObjAnimMat(false);
		pointer++;
	}
}

void Load_DObjAnimMatPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDObjAnimMat, sizeof(DObjAnimMat));
	if (*varDObjAnimMatPtr != nullptr)
	{
		if (*varDObjAnimMatPtr == (DObjAnimMat*)0xFFFFFFFF)
		{
			*varDObjAnimMatPtr = AllocLoad_DObjAnimMat();
			varDObjAnimMat = *varDObjAnimMatPtr;
			Load_DObjAnimMat(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varDObjAnimMatPtr);
		}
	}
}

void Load_DObjAnimMatPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDObjAnimMatPtr, sizeof(DObjAnimMat*) * count);
	DObjAnimMat** pointer = varDObjAnimMatPtr;
	for (int i = 0; i < count; i++)
	{
		varDObjAnimMatPtr = pointer;
		Load_DObjAnimMatPtr(false);
		pointer++;
	}
}

void Load_DynEntityClient(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityClient, sizeof(DynEntityClient));

}

void Load_DynEntityClientArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityClient, sizeof(DynEntityClient) * count);
	DynEntityClient* pointer = varDynEntityClient;
	for (int i = 0; i < count; i++)
	{
		varDynEntityClient = pointer;
		Load_DynEntityClient(false);
		pointer++;
	}
}

void Load_DynEntityClientPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityClient, sizeof(DynEntityClient));
	if (*varDynEntityClientPtr != nullptr)
	{
		if (*varDynEntityClientPtr == (DynEntityClient*)0xFFFFFFFF)
		{
			*varDynEntityClientPtr = AllocLoad_DynEntityClient();
			varDynEntityClient = *varDynEntityClientPtr;
			Load_DynEntityClient(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varDynEntityClientPtr);
		}
	}
}

void Load_DynEntityClientPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityClientPtr, sizeof(DynEntityClient*) * count);
	DynEntityClient** pointer = varDynEntityClientPtr;
	for (int i = 0; i < count; i++)
	{
		varDynEntityClientPtr = pointer;
		Load_DynEntityClientPtr(false);
		pointer++;
	}
}

void Load_DynEntityColl(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityColl, sizeof(DynEntityColl));

}

void Load_DynEntityCollArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityColl, sizeof(DynEntityColl) * count);
	DynEntityColl* pointer = varDynEntityColl;
	for (int i = 0; i < count; i++)
	{
		varDynEntityColl = pointer;
		Load_DynEntityColl(false);
		pointer++;
	}
}

void Load_DynEntityCollPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityColl, sizeof(DynEntityColl));
	if (*varDynEntityCollPtr != nullptr)
	{
		if (*varDynEntityCollPtr == (DynEntityColl*)0xFFFFFFFF)
		{
			*varDynEntityCollPtr = AllocLoad_DynEntityColl();
			varDynEntityColl = *varDynEntityCollPtr;
			Load_DynEntityColl(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varDynEntityCollPtr);
		}
	}
}

void Load_DynEntityCollPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityCollPtr, sizeof(DynEntityColl*) * count);
	DynEntityColl** pointer = varDynEntityCollPtr;
	for (int i = 0; i < count; i++)
	{
		varDynEntityCollPtr = pointer;
		Load_DynEntityCollPtr(false);
		pointer++;
	}
}

void Load_DynEntityDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityDef, sizeof(DynEntityDef));

	varGfxPlacement = &varDynEntityDef->pose;
	Load_GfxPlacement(false);

	varXModelPtr = &varDynEntityDef->xModel;
	Load_XModelPtr(false);

	varFxEffectDefPtr = &varDynEntityDef->destroyFx;
	Load_FxEffectDefPtr(false);

	varPhysPresetPtr = &varDynEntityDef->physPreset;
	Load_PhysPresetPtr(false);

	varPhysMass = &varDynEntityDef->mass;
	Load_PhysMass(false);

}

void Load_DynEntityDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityDef, sizeof(DynEntityDef) * count);
	DynEntityDef* pointer = varDynEntityDef;
	for (int i = 0; i < count; i++)
	{
		varDynEntityDef = pointer;
		Load_DynEntityDef(false);
		pointer++;
	}
}

void Load_DynEntityDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityDef, sizeof(DynEntityDef));
	if (*varDynEntityDefPtr != nullptr)
	{
		if (*varDynEntityDefPtr == (DynEntityDef*)0xFFFFFFFF)
		{
			*varDynEntityDefPtr = AllocLoad_DynEntityDef();
			varDynEntityDef = *varDynEntityDefPtr;
			Load_DynEntityDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varDynEntityDefPtr);
		}
	}
}

void Load_DynEntityDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityDefPtr, sizeof(DynEntityDef*) * count);
	DynEntityDef** pointer = varDynEntityDefPtr;
	for (int i = 0; i < count; i++)
	{
		varDynEntityDefPtr = pointer;
		Load_DynEntityDefPtr(false);
		pointer++;
	}
}

void Load_DynEntityPose(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityPose, sizeof(DynEntityPose));

	varGfxPlacement = &varDynEntityPose->pose;
	Load_GfxPlacement(false);

}

void Load_DynEntityPoseArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityPose, sizeof(DynEntityPose) * count);
	DynEntityPose* pointer = varDynEntityPose;
	for (int i = 0; i < count; i++)
	{
		varDynEntityPose = pointer;
		Load_DynEntityPose(false);
		pointer++;
	}
}

void Load_DynEntityPosePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varDynEntityPose, sizeof(DynEntityPose));
	if (*varDynEntityPosePtr != nullptr)
	{
		if (*varDynEntityPosePtr == (DynEntityPose*)0xFFFFFFFF)
		{
			*varDynEntityPosePtr = AllocLoad_DynEntityPose();
			varDynEntityPose = *varDynEntityPosePtr;
			Load_DynEntityPose(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varDynEntityPosePtr);
		}
	}
}

void Load_DynEntityPosePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varDynEntityPosePtr, sizeof(DynEntityPose*) * count);
	DynEntityPose** pointer = varDynEntityPosePtr;
	for (int i = 0; i < count; i++)
	{
		varDynEntityPosePtr = pointer;
		Load_DynEntityPosePtr(false);
		pointer++;
	}
}

void Load_EventData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varEventData, sizeof(EventData));

	switch (varMenuEventHandler->eventType)
	{
	case 0:
		varXString = &varEventData->unconditionalScript;
		Load_XString(atStreamStart);
		break;
	case 1:
		varConditionalScriptPtr = &varEventData->conditionalScript;
		Load_ConditionalScriptPtr(false);
		break;
	case 2:
		varMenuEventHandlerSetPtr = &varEventData->elseScript;
		Load_MenuEventHandlerSetPtr(false);
		break;
	case 3:
	case 4:
	case 5:
	case 6:
		varSetLocalVarDataPtr = &varEventData->setLocalVarData;
		Load_SetLocalVarDataPtr(false);
		break;
	}
}

void Load_EventDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varEventData, sizeof(EventData) * count);
	EventData* pointer = varEventData;
	for (int i = 0; i < count; i++)
	{
		varEventData = pointer;
		Load_EventData(false);
		pointer++;
	}
}

void Load_EventDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varEventData, sizeof(EventData));
	if (*varEventDataPtr != nullptr)
	{
		if (*varEventDataPtr == (EventData*)0xFFFFFFFF)
		{
			*varEventDataPtr = AllocLoad_EventData();
			varEventData = *varEventDataPtr;
			Load_EventData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varEventDataPtr);
		}
	}
}

void Load_EventDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varEventDataPtr, sizeof(EventData*) * count);
	EventData** pointer = varEventDataPtr;
	for (int i = 0; i < count; i++)
	{
		varEventDataPtr = pointer;
		Load_EventDataPtr(false);
		pointer++;
	}
}

void Load_ExpressionString(bool atStreamStart)
{
	Load_Stream(atStreamStart, varExpressionString, sizeof(ExpressionString));

	varXString = &varExpressionString->string;
	Load_XString(false);

}

void Load_ExpressionStringArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varExpressionString, sizeof(ExpressionString) * count);
	ExpressionString* pointer = varExpressionString;
	for (int i = 0; i < count; i++)
	{
		varExpressionString = pointer;
		Load_ExpressionString(false);
		pointer++;
	}
}

void Load_ExpressionStringPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varExpressionString, sizeof(ExpressionString));
	if (*varExpressionStringPtr != nullptr)
	{
		*varExpressionStringPtr = AllocLoad_ExpressionString();
		varExpressionString = *varExpressionStringPtr;
		Load_ExpressionString(true);
	}
}

void Load_ExpressionStringPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varExpressionStringPtr, sizeof(ExpressionString*) * count);
	ExpressionString** pointer = varExpressionStringPtr;
	for (int i = 0; i < count; i++)
	{
		varExpressionStringPtr = pointer;
		Load_ExpressionStringPtr(false);
		pointer++;
	}
}

void Load_ExpressionSupportingData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varExpressionSupportingData, sizeof(ExpressionSupportingData));

	varUIFunctionList = &varExpressionSupportingData->uifunctions;
	Load_UIFunctionList(false);

	varStaticDvarList = &varExpressionSupportingData->staticDvarList;
	Load_StaticDvarList(false);

	varStringList = &varExpressionSupportingData->uiStrings;
	Load_StringList(false);

}

void Load_ExpressionSupportingDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varExpressionSupportingData, sizeof(ExpressionSupportingData) * count);
	ExpressionSupportingData* pointer = varExpressionSupportingData;
	for (int i = 0; i < count; i++)
	{
		varExpressionSupportingData = pointer;
		Load_ExpressionSupportingData(false);
		pointer++;
	}
}

void Load_ExpressionSupportingDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varExpressionSupportingData, sizeof(ExpressionSupportingData));
	if (*varExpressionSupportingDataPtr != nullptr)
	{
		if (*varExpressionSupportingDataPtr == (ExpressionSupportingData*)0xFFFFFFFF)
		{
			*varExpressionSupportingDataPtr = AllocLoad_ExpressionSupportingData();
			varExpressionSupportingData = *varExpressionSupportingDataPtr;
			Load_ExpressionSupportingData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varExpressionSupportingDataPtr);
		}
	}
}

void Load_ExpressionSupportingDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varExpressionSupportingDataPtr, sizeof(ExpressionSupportingData*) * count);
	ExpressionSupportingData** pointer = varExpressionSupportingDataPtr;
	for (int i = 0; i < count; i++)
	{
		varExpressionSupportingDataPtr = pointer;
		Load_ExpressionSupportingDataPtr(false);
		pointer++;
	}
}

void Load_Font_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFont_s, sizeof(Font_s));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varFont_s->fontName;
	Load_XString(false);

	varMaterialPtr = &varFont_s->material;
	Load_MaterialPtr(false);

	varMaterialPtr = &varFont_s->glowMaterial;
	Load_MaterialPtr(false);

	if (varFont_s->glyphs)
	{
		if (varFont_s->glyphs == (Glyph*)0xFFFFFFFF)
		{
			varFont_s->glyphs = AllocLoad_Glyph();
			varGlyph = varFont_s->glyphs;
			Load_GlyphArray(true, (varFont_s->glyphCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFont_s->glyphs);
		}
	}

	DB_PopStreamPos();
}

void Load_Font_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFont_s, sizeof(Font_s) * count);
	Font_s* pointer = varFont_s;
	for (int i = 0; i < count; i++)
	{
		varFont_s = pointer;
		Load_Font_s(false);
		pointer++;
	}
}

void Load_Font_sAsset(Font_s** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_FONT, (void**)varFont_sPtr);
}

void Load_Font_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFont_s, sizeof(Font_s*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	Font_s* pointer = *varFont_sPtr;
	if (*varFont_sPtr != nullptr)
	{
		if (*varFont_sPtr == (Font_s*)0xFFFFFFFF || *varFont_sPtr == (Font_s*)0xFFFFFFFE)
		{
			*varFont_sPtr = AllocLoad_Font_s();
			varFont_s = *varFont_sPtr;
			Font_s** insertedPointer = nullptr;
			if (pointer == (Font_s*)0xFFFFFFFE)
			{
				insertedPointer = (Font_s**)DB_InsertPointer();
			}
			Load_Font_s(true);
			Load_Font_sAsset(varFont_sPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varFont_sPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varFont_sPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_Font_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFont_sPtr, sizeof(Font_s*) * count);
	Font_s** pointer = varFont_sPtr;
	for (int i = 0; i < count; i++)
	{
		varFont_sPtr = pointer;
		Load_Font_sPtr(false);
		pointer++;
	}
}

void Load_FxEffectDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxEffectDef, sizeof(FxEffectDef));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varFxEffectDef->name;
	Load_XString(false);

	if (varFxEffectDef->elemDefs)
	{
		if (varFxEffectDef->elemDefs == (FxElemDef*)0xFFFFFFFF)
		{
			varFxEffectDef->elemDefs = AllocLoad_FxElemDef();
			varFxElemDef = varFxEffectDef->elemDefs;
			Load_FxElemDefArray(true, (varFxEffectDef->elemDefCountLooping + varFxEffectDef->elemDefCountOneShot + varFxEffectDef->elemDefCountEmission));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxEffectDef->elemDefs);
		}
	}

	DB_PopStreamPos();
}

void Load_FxEffectDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxEffectDef, sizeof(FxEffectDef) * count);
	FxEffectDef* pointer = varFxEffectDef;
	for (int i = 0; i < count; i++)
	{
		varFxEffectDef = pointer;
		Load_FxEffectDef(false);
		pointer++;
	}
}

void Load_FxEffectDefAsset(FxEffectDef** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_FX, (void**)varFxEffectDefPtr);
}

void Load_FxEffectDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxEffectDef, sizeof(FxEffectDef*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	FxEffectDef* pointer = *varFxEffectDefPtr;
	if (*varFxEffectDefPtr != nullptr)
	{
		if (*varFxEffectDefPtr == (FxEffectDef*)0xFFFFFFFF || *varFxEffectDefPtr == (FxEffectDef*)0xFFFFFFFE)
		{
			*varFxEffectDefPtr = AllocLoad_FxEffectDef();
			varFxEffectDef = *varFxEffectDefPtr;
			FxEffectDef** insertedPointer = nullptr;
			if (pointer == (FxEffectDef*)0xFFFFFFFE)
			{
				insertedPointer = (FxEffectDef**)DB_InsertPointer();
			}
			Load_FxEffectDef(true);
			Load_FxEffectDefAsset(varFxEffectDefPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varFxEffectDefPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varFxEffectDefPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_FxEffectDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxEffectDefPtr, sizeof(FxEffectDef*) * count);
	FxEffectDef** pointer = varFxEffectDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxEffectDefPtr = pointer;
		Load_FxEffectDefPtr(false);
		pointer++;
	}
}

void Load_FxEffectDefRef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxEffectDefRef, sizeof(FxEffectDefRef));

	varXString = &varFxEffectDefRef->name;
	Load_XString(false);

}

void Load_FxEffectDefRefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxEffectDefRef, sizeof(FxEffectDefRef) * count);
	FxEffectDefRef* pointer = varFxEffectDefRef;
	for (int i = 0; i < count; i++)
	{
		varFxEffectDefRef = pointer;
		Load_FxEffectDefRef(false);
		pointer++;
	}
}

void Load_FxEffectDefRefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxEffectDefRef, sizeof(FxEffectDefRef));
	if (*varFxEffectDefRefPtr != nullptr)
	{
		*varFxEffectDefRefPtr = AllocLoad_FxEffectDefRef();
		varFxEffectDefRef = *varFxEffectDefRefPtr;
		Load_FxEffectDefRef(true);
	}
}

void Load_FxEffectDefRefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxEffectDefRefPtr, sizeof(FxEffectDefRef*) * count);
	FxEffectDefRef** pointer = varFxEffectDefRefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxEffectDefRefPtr = pointer;
		Load_FxEffectDefRefPtr(false);
		pointer++;
	}
}

void Load_FxElemAtlas(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemAtlas, sizeof(FxElemAtlas));

}

void Load_FxElemAtlasArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemAtlas, sizeof(FxElemAtlas) * count);
	FxElemAtlas* pointer = varFxElemAtlas;
	for (int i = 0; i < count; i++)
	{
		varFxElemAtlas = pointer;
		Load_FxElemAtlas(false);
		pointer++;
	}
}

void Load_FxElemAtlasPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemAtlas, sizeof(FxElemAtlas));
	if (*varFxElemAtlasPtr != nullptr)
	{
		if (*varFxElemAtlasPtr == (FxElemAtlas*)0xFFFFFFFF)
		{
			*varFxElemAtlasPtr = AllocLoad_FxElemAtlas();
			varFxElemAtlas = *varFxElemAtlasPtr;
			Load_FxElemAtlas(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemAtlasPtr);
		}
	}
}

void Load_FxElemAtlasPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemAtlasPtr, sizeof(FxElemAtlas*) * count);
	FxElemAtlas** pointer = varFxElemAtlasPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemAtlasPtr = pointer;
		Load_FxElemAtlasPtr(false);
		pointer++;
	}
}

void Load_FxElemDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemDef, sizeof(FxElemDef));

	varFxSpawnDef = &varFxElemDef->spawn;
	Load_FxSpawnDef(false);

	varFxFloatRange = &varFxElemDef->spawnRange;
	Load_FxFloatRange(false);

	varFxFloatRange = &varFxElemDef->fadeInRange;
	Load_FxFloatRange(false);

	varFxFloatRange = &varFxElemDef->fadeOutRange;
	Load_FxFloatRange(false);

	varFxIntRange = &varFxElemDef->spawnDelayMsec;
	Load_FxIntRange(false);

	varFxIntRange = &varFxElemDef->lifeSpanMsec;
	Load_FxIntRange(false);

	varFxFloatRange = varFxElemDef->spawnOrigin;
	Load_FxFloatRangeArray(false, 3);

	varFxFloatRange = &varFxElemDef->spawnOffsetRadius;
	Load_FxFloatRange(false);

	varFxFloatRange = &varFxElemDef->spawnOffsetHeight;
	Load_FxFloatRange(false);

	varFxFloatRange = varFxElemDef->spawnAngles;
	Load_FxFloatRangeArray(false, 3);

	varFxFloatRange = varFxElemDef->angularVelocity;
	Load_FxFloatRangeArray(false, 3);

	varFxFloatRange = &varFxElemDef->initialRotation;
	Load_FxFloatRange(false);

	varFxFloatRange = &varFxElemDef->gravity;
	Load_FxFloatRange(false);

	varFxFloatRange = &varFxElemDef->reflectionFactor;
	Load_FxFloatRange(false);

	varFxElemAtlas = &varFxElemDef->atlas;
	Load_FxElemAtlas(false);

	if (varFxElemDef->velSamples)
	{
		if (varFxElemDef->velSamples == (FxElemVelStateSample*)0xFFFFFFFF)
		{
			varFxElemDef->velSamples = AllocLoad_FxElemVelStateSample();
			varFxElemVelStateSample = varFxElemDef->velSamples;
			Load_FxElemVelStateSampleArray(true, (varFxElemDef->velIntervalCount + 1));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxElemDef->velSamples);
		}
	}

	if (varFxElemDef->visSamples)
	{
		if (varFxElemDef->visSamples == (FxElemVisStateSample*)0xFFFFFFFF)
		{
			varFxElemDef->visSamples = AllocLoad_FxElemVisStateSample();
			varFxElemVisStateSample = varFxElemDef->visSamples;
			Load_FxElemVisStateSampleArray(true, (varFxElemDef->visStateIntervalCount + 1));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxElemDef->visSamples);
		}
	}

	varFxElemDefVisuals = &varFxElemDef->visuals;
	Load_FxElemDefVisuals(false);

	varBounds = &varFxElemDef->collBounds;
	Load_Bounds(false);

	varFxEffectDefRef = &varFxElemDef->effectOnImpact;
	Load_FxEffectDefRef(false);

	varFxEffectDefRef = &varFxElemDef->effectOnDeath;
	Load_FxEffectDefRef(false);

	varFxEffectDefRef = &varFxElemDef->effectEmitted;
	Load_FxEffectDefRef(false);

	varFxFloatRange = &varFxElemDef->emitDist;
	Load_FxFloatRange(false);

	varFxFloatRange = &varFxElemDef->emitDistVariance;
	Load_FxFloatRange(false);

	varFxElemExtendedDefPtr = &varFxElemDef->extended;
	Load_FxElemExtendedDefPtr(false);

}

void Load_FxElemDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemDef, sizeof(FxElemDef) * count);
	FxElemDef* pointer = varFxElemDef;
	for (int i = 0; i < count; i++)
	{
		varFxElemDef = pointer;
		Load_FxElemDef(false);
		pointer++;
	}
}

void Load_FxElemDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemDef, sizeof(FxElemDef));
	if (*varFxElemDefPtr != nullptr)
	{
		if (*varFxElemDefPtr == (FxElemDef*)0xFFFFFFFF)
		{
			*varFxElemDefPtr = AllocLoad_FxElemDef();
			varFxElemDef = *varFxElemDefPtr;
			Load_FxElemDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemDefPtr);
		}
	}
}

void Load_FxElemDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemDefPtr, sizeof(FxElemDef*) * count);
	FxElemDef** pointer = varFxElemDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemDefPtr = pointer;
		Load_FxElemDefPtr(false);
		pointer++;
	}
}

void Load_FxElemDefVisuals(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemDefVisuals, sizeof(FxElemDefVisuals));

	if (varFxElemDef->elemType == 11)
	{
		varFxElemMarkVisualsPtr = &varFxElemDefVisuals->markArray;
		Load_FxElemMarkVisualsPtr(false);
	}
	else if (varFxElemDef->visualCount > 1)
	{
		varFxElemVisualsPtr = &varFxElemDefVisuals->array;
		Load_FxElemVisualsPtr(false);
	}
	else
	{
		varFxElemVisuals = &varFxElemDefVisuals->instance;
		Load_FxElemVisuals(atStreamStart);
	}
}

void Load_FxElemDefVisualsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemDefVisuals, sizeof(FxElemDefVisuals) * count);
	FxElemDefVisuals* pointer = varFxElemDefVisuals;
	for (int i = 0; i < count; i++)
	{
		varFxElemDefVisuals = pointer;
		Load_FxElemDefVisuals(false);
		pointer++;
	}
}

void Load_FxElemDefVisualsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemDefVisuals, sizeof(FxElemDefVisuals));
	if (*varFxElemDefVisualsPtr != nullptr)
	{
		if (*varFxElemDefVisualsPtr == (FxElemDefVisuals*)0xFFFFFFFF)
		{
			*varFxElemDefVisualsPtr = AllocLoad_FxElemDefVisuals();
			varFxElemDefVisuals = *varFxElemDefVisualsPtr;
			Load_FxElemDefVisuals(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemDefVisualsPtr);
		}
	}
}

void Load_FxElemDefVisualsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemDefVisualsPtr, sizeof(FxElemDefVisuals*) * count);
	FxElemDefVisuals** pointer = varFxElemDefVisualsPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemDefVisualsPtr = pointer;
		Load_FxElemDefVisualsPtr(false);
		pointer++;
	}
}

void Load_FxElemExtendedDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemExtendedDefPtr, sizeof(FxElemExtendedDefPtr));

	switch (varFxElemDef->elemType)
	{
	case 3:
		varFxTrailDefPtr = &varFxElemExtendedDefPtr->trailDef;
		Load_FxTrailDefPtr(false);
		break;
	case 6:
		varFxSparkFountainDefPtr = &varFxElemExtendedDefPtr->sparkFountainDef;
		Load_FxSparkFountainDefPtr(false);
		break;
	}
}

void Load_FxElemExtendedDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemExtendedDefPtr, sizeof(FxElemExtendedDefPtr) * count);
	FxElemExtendedDefPtr* pointer = varFxElemExtendedDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemExtendedDefPtr = pointer;
		Load_FxElemExtendedDefPtr(false);
		pointer++;
	}
}

void Load_FxElemExtendedDefPtrPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemExtendedDefPtr, sizeof(FxElemExtendedDefPtr));
	if (*varFxElemExtendedDefPtrPtr != nullptr)
	{
		if (*varFxElemExtendedDefPtrPtr == (FxElemExtendedDefPtr*)0xFFFFFFFF)
		{
			*varFxElemExtendedDefPtrPtr = AllocLoad_FxElemExtendedDefPtr();
			varFxElemExtendedDefPtr = *varFxElemExtendedDefPtrPtr;
			Load_FxElemExtendedDefPtr(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemExtendedDefPtrPtr);
		}
	}
}

void Load_FxElemExtendedDefPtrPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemExtendedDefPtrPtr, sizeof(FxElemExtendedDefPtr*) * count);
	FxElemExtendedDefPtr** pointer = varFxElemExtendedDefPtrPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemExtendedDefPtrPtr = pointer;
		Load_FxElemExtendedDefPtrPtr(false);
		pointer++;
	}
}

void Load_FxElemMarkVisuals(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemMarkVisuals, sizeof(FxElemMarkVisuals));

	if (varFxElemMarkVisuals->materials)
	{
		varMaterialPtr = varFxElemMarkVisuals->materials;
		Load_MaterialPtrArray(false, 2);
	}

}

void Load_FxElemMarkVisualsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemMarkVisuals, sizeof(FxElemMarkVisuals) * count);
	FxElemMarkVisuals* pointer = varFxElemMarkVisuals;
	for (int i = 0; i < count; i++)
	{
		varFxElemMarkVisuals = pointer;
		Load_FxElemMarkVisuals(false);
		pointer++;
	}
}

void Load_FxElemMarkVisualsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemMarkVisuals, sizeof(FxElemMarkVisuals));
	if (*varFxElemMarkVisualsPtr != nullptr)
	{
		*varFxElemMarkVisualsPtr = AllocLoad_FxElemMarkVisuals();
		varFxElemMarkVisuals = *varFxElemMarkVisualsPtr;
		Load_FxElemMarkVisuals(true);
	}
}

void Load_FxElemMarkVisualsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemMarkVisualsPtr, sizeof(FxElemMarkVisuals*) * count);
	FxElemMarkVisuals** pointer = varFxElemMarkVisualsPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemMarkVisualsPtr = pointer;
		Load_FxElemMarkVisualsPtr(false);
		pointer++;
	}
}

void Load_FxElemVec3Range(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVec3Range, sizeof(FxElemVec3Range));

}

void Load_FxElemVec3RangeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVec3Range, sizeof(FxElemVec3Range) * count);
	FxElemVec3Range* pointer = varFxElemVec3Range;
	for (int i = 0; i < count; i++)
	{
		varFxElemVec3Range = pointer;
		Load_FxElemVec3Range(false);
		pointer++;
	}
}

void Load_FxElemVec3RangePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVec3Range, sizeof(FxElemVec3Range));
	if (*varFxElemVec3RangePtr != nullptr)
	{
		if (*varFxElemVec3RangePtr == (FxElemVec3Range*)0xFFFFFFFF)
		{
			*varFxElemVec3RangePtr = AllocLoad_FxElemVec3Range();
			varFxElemVec3Range = *varFxElemVec3RangePtr;
			Load_FxElemVec3Range(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemVec3RangePtr);
		}
	}
}

void Load_FxElemVec3RangePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVec3RangePtr, sizeof(FxElemVec3Range*) * count);
	FxElemVec3Range** pointer = varFxElemVec3RangePtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemVec3RangePtr = pointer;
		Load_FxElemVec3RangePtr(false);
		pointer++;
	}
}

void Load_FxElemVelStateInFrame(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVelStateInFrame, sizeof(FxElemVelStateInFrame));

	varFxElemVec3Range = &varFxElemVelStateInFrame->velocity;
	Load_FxElemVec3Range(false);

	varFxElemVec3Range = &varFxElemVelStateInFrame->totalDelta;
	Load_FxElemVec3Range(false);

}

void Load_FxElemVelStateInFrameArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVelStateInFrame, sizeof(FxElemVelStateInFrame) * count);
	FxElemVelStateInFrame* pointer = varFxElemVelStateInFrame;
	for (int i = 0; i < count; i++)
	{
		varFxElemVelStateInFrame = pointer;
		Load_FxElemVelStateInFrame(false);
		pointer++;
	}
}

void Load_FxElemVelStateInFramePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVelStateInFrame, sizeof(FxElemVelStateInFrame));
	if (*varFxElemVelStateInFramePtr != nullptr)
	{
		if (*varFxElemVelStateInFramePtr == (FxElemVelStateInFrame*)0xFFFFFFFF)
		{
			*varFxElemVelStateInFramePtr = AllocLoad_FxElemVelStateInFrame();
			varFxElemVelStateInFrame = *varFxElemVelStateInFramePtr;
			Load_FxElemVelStateInFrame(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemVelStateInFramePtr);
		}
	}
}

void Load_FxElemVelStateInFramePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVelStateInFramePtr, sizeof(FxElemVelStateInFrame*) * count);
	FxElemVelStateInFrame** pointer = varFxElemVelStateInFramePtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemVelStateInFramePtr = pointer;
		Load_FxElemVelStateInFramePtr(false);
		pointer++;
	}
}

void Load_FxElemVelStateSample(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVelStateSample, sizeof(FxElemVelStateSample));

	varFxElemVelStateInFrame = &varFxElemVelStateSample->local;
	Load_FxElemVelStateInFrame(false);

	varFxElemVelStateInFrame = &varFxElemVelStateSample->world;
	Load_FxElemVelStateInFrame(false);

}

void Load_FxElemVelStateSampleArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVelStateSample, sizeof(FxElemVelStateSample) * count);
	FxElemVelStateSample* pointer = varFxElemVelStateSample;
	for (int i = 0; i < count; i++)
	{
		varFxElemVelStateSample = pointer;
		Load_FxElemVelStateSample(false);
		pointer++;
	}
}

void Load_FxElemVelStateSamplePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVelStateSample, sizeof(FxElemVelStateSample));
	if (*varFxElemVelStateSamplePtr != nullptr)
	{
		if (*varFxElemVelStateSamplePtr == (FxElemVelStateSample*)0xFFFFFFFF)
		{
			*varFxElemVelStateSamplePtr = AllocLoad_FxElemVelStateSample();
			varFxElemVelStateSample = *varFxElemVelStateSamplePtr;
			Load_FxElemVelStateSample(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemVelStateSamplePtr);
		}
	}
}

void Load_FxElemVelStateSamplePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVelStateSamplePtr, sizeof(FxElemVelStateSample*) * count);
	FxElemVelStateSample** pointer = varFxElemVelStateSamplePtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemVelStateSamplePtr = pointer;
		Load_FxElemVelStateSamplePtr(false);
		pointer++;
	}
}

void Load_FxElemVisStateSample(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVisStateSample, sizeof(FxElemVisStateSample));

	varFxElemVisualState = &varFxElemVisStateSample->base;
	Load_FxElemVisualState(false);

	varFxElemVisualState = &varFxElemVisStateSample->amplitude;
	Load_FxElemVisualState(false);

}

void Load_FxElemVisStateSampleArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVisStateSample, sizeof(FxElemVisStateSample) * count);
	FxElemVisStateSample* pointer = varFxElemVisStateSample;
	for (int i = 0; i < count; i++)
	{
		varFxElemVisStateSample = pointer;
		Load_FxElemVisStateSample(false);
		pointer++;
	}
}

void Load_FxElemVisStateSamplePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVisStateSample, sizeof(FxElemVisStateSample));
	if (*varFxElemVisStateSamplePtr != nullptr)
	{
		if (*varFxElemVisStateSamplePtr == (FxElemVisStateSample*)0xFFFFFFFF)
		{
			*varFxElemVisStateSamplePtr = AllocLoad_FxElemVisStateSample();
			varFxElemVisStateSample = *varFxElemVisStateSamplePtr;
			Load_FxElemVisStateSample(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemVisStateSamplePtr);
		}
	}
}

void Load_FxElemVisStateSamplePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVisStateSamplePtr, sizeof(FxElemVisStateSample*) * count);
	FxElemVisStateSample** pointer = varFxElemVisStateSamplePtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemVisStateSamplePtr = pointer;
		Load_FxElemVisStateSamplePtr(false);
		pointer++;
	}
}

void Load_FxElemVisualState(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVisualState, sizeof(FxElemVisualState));

}

void Load_FxElemVisualStateArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVisualState, sizeof(FxElemVisualState) * count);
	FxElemVisualState* pointer = varFxElemVisualState;
	for (int i = 0; i < count; i++)
	{
		varFxElemVisualState = pointer;
		Load_FxElemVisualState(false);
		pointer++;
	}
}

void Load_FxElemVisualStatePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVisualState, sizeof(FxElemVisualState));
	if (*varFxElemVisualStatePtr != nullptr)
	{
		if (*varFxElemVisualStatePtr == (FxElemVisualState*)0xFFFFFFFF)
		{
			*varFxElemVisualStatePtr = AllocLoad_FxElemVisualState();
			varFxElemVisualState = *varFxElemVisualStatePtr;
			Load_FxElemVisualState(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemVisualStatePtr);
		}
	}
}

void Load_FxElemVisualStatePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVisualStatePtr, sizeof(FxElemVisualState*) * count);
	FxElemVisualState** pointer = varFxElemVisualStatePtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemVisualStatePtr = pointer;
		Load_FxElemVisualStatePtr(false);
		pointer++;
	}
}

void Load_FxElemVisuals(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVisuals, sizeof(FxElemVisuals));

	switch (varFxElemDef->elemType)
	{
	case 0:
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
	case 6:
	case 11:
		varMaterialPtr = &varFxElemVisuals->material;
		Load_MaterialPtr(false);
		break;
	case 7:
		varXModelPtr = &varFxElemVisuals->model;
		Load_XModelPtr(false);
		break;
	case 12:
		varFxEffectDefRef = &varFxElemVisuals->effectDef;
		Load_FxEffectDefRef(atStreamStart);
		break;
	case 10:
		varXString = &varFxElemVisuals->soundName;
		Load_XString(atStreamStart);
		break;
	}
}

void Load_FxElemVisualsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVisuals, sizeof(FxElemVisuals) * count);
	FxElemVisuals* pointer = varFxElemVisuals;
	for (int i = 0; i < count; i++)
	{
		varFxElemVisuals = pointer;
		Load_FxElemVisuals(false);
		pointer++;
	}
}

void Load_FxElemVisualsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxElemVisuals, sizeof(FxElemVisuals));
	if (*varFxElemVisualsPtr != nullptr)
	{
		if (*varFxElemVisualsPtr == (FxElemVisuals*)0xFFFFFFFF)
		{
			*varFxElemVisualsPtr = AllocLoad_FxElemVisuals();
			varFxElemVisuals = *varFxElemVisualsPtr;
			Load_FxElemVisuals(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxElemVisualsPtr);
		}
	}
}

void Load_FxElemVisualsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxElemVisualsPtr, sizeof(FxElemVisuals*) * count);
	FxElemVisuals** pointer = varFxElemVisualsPtr;
	for (int i = 0; i < count; i++)
	{
		varFxElemVisualsPtr = pointer;
		Load_FxElemVisualsPtr(false);
		pointer++;
	}
}

void Load_FxFloatRange(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxFloatRange, sizeof(FxFloatRange));

}

void Load_FxFloatRangeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxFloatRange, sizeof(FxFloatRange) * count);
	FxFloatRange* pointer = varFxFloatRange;
	for (int i = 0; i < count; i++)
	{
		varFxFloatRange = pointer;
		Load_FxFloatRange(false);
		pointer++;
	}
}

void Load_FxFloatRangePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxFloatRange, sizeof(FxFloatRange));
	if (*varFxFloatRangePtr != nullptr)
	{
		if (*varFxFloatRangePtr == (FxFloatRange*)0xFFFFFFFF)
		{
			*varFxFloatRangePtr = AllocLoad_FxFloatRange();
			varFxFloatRange = *varFxFloatRangePtr;
			Load_FxFloatRange(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxFloatRangePtr);
		}
	}
}

void Load_FxFloatRangePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxFloatRangePtr, sizeof(FxFloatRange*) * count);
	FxFloatRange** pointer = varFxFloatRangePtr;
	for (int i = 0; i < count; i++)
	{
		varFxFloatRangePtr = pointer;
		Load_FxFloatRangePtr(false);
		pointer++;
	}
}

void Load_FxGlassCrackHeader(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassCrackHeader, sizeof(FxGlassCrackHeader));

}

void Load_FxGlassCrackHeaderArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassCrackHeader, sizeof(FxGlassCrackHeader) * count);
	FxGlassCrackHeader* pointer = varFxGlassCrackHeader;
	for (int i = 0; i < count; i++)
	{
		varFxGlassCrackHeader = pointer;
		Load_FxGlassCrackHeader(false);
		pointer++;
	}
}

void Load_FxGlassCrackHeaderPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassCrackHeader, sizeof(FxGlassCrackHeader));
	if (*varFxGlassCrackHeaderPtr != nullptr)
	{
		if (*varFxGlassCrackHeaderPtr == (FxGlassCrackHeader*)0xFFFFFFFF)
		{
			*varFxGlassCrackHeaderPtr = AllocLoad_FxGlassCrackHeader();
			varFxGlassCrackHeader = *varFxGlassCrackHeaderPtr;
			Load_FxGlassCrackHeader(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassCrackHeaderPtr);
		}
	}
}

void Load_FxGlassCrackHeaderPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassCrackHeaderPtr, sizeof(FxGlassCrackHeader*) * count);
	FxGlassCrackHeader** pointer = varFxGlassCrackHeaderPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassCrackHeaderPtr = pointer;
		Load_FxGlassCrackHeaderPtr(false);
		pointer++;
	}
}

void Load_FxGlassDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassDef, sizeof(FxGlassDef));

	varGfxColor = &varFxGlassDef->color;
	Load_GfxColor(false);

	varMaterialPtr = &varFxGlassDef->material;
	Load_MaterialPtr(false);

	varMaterialPtr = &varFxGlassDef->materialShattered;
	Load_MaterialPtr(false);

	varPhysPresetPtr = &varFxGlassDef->physPreset;
	Load_PhysPresetPtr(false);

}

void Load_FxGlassDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassDef, sizeof(FxGlassDef) * count);
	FxGlassDef* pointer = varFxGlassDef;
	for (int i = 0; i < count; i++)
	{
		varFxGlassDef = pointer;
		Load_FxGlassDef(false);
		pointer++;
	}
}

void Load_FxGlassDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassDef, sizeof(FxGlassDef));
	if (*varFxGlassDefPtr != nullptr)
	{
		if (*varFxGlassDefPtr == (FxGlassDef*)0xFFFFFFFF)
		{
			*varFxGlassDefPtr = AllocLoad_FxGlassDef();
			varFxGlassDef = *varFxGlassDefPtr;
			Load_FxGlassDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassDefPtr);
		}
	}
}

void Load_FxGlassDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassDefPtr, sizeof(FxGlassDef*) * count);
	FxGlassDef** pointer = varFxGlassDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassDefPtr = pointer;
		Load_FxGlassDefPtr(false);
		pointer++;
	}
}

void Load_FxGlassGeometryData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassGeometryData, sizeof(FxGlassGeometryData));

}

void Load_FxGlassGeometryDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassGeometryData, sizeof(FxGlassGeometryData) * count);
	FxGlassGeometryData* pointer = varFxGlassGeometryData;
	for (int i = 0; i < count; i++)
	{
		varFxGlassGeometryData = pointer;
		Load_FxGlassGeometryData(false);
		pointer++;
	}
}

void Load_FxGlassGeometryDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassGeometryData, sizeof(FxGlassGeometryData));
	if (*varFxGlassGeometryDataPtr != nullptr)
	{
		if (*varFxGlassGeometryDataPtr == (FxGlassGeometryData*)0xFFFFFFFF)
		{
			*varFxGlassGeometryDataPtr = AllocLoad_FxGlassGeometryData();
			varFxGlassGeometryData = *varFxGlassGeometryDataPtr;
			Load_FxGlassGeometryData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassGeometryDataPtr);
		}
	}
}

void Load_FxGlassGeometryDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassGeometryDataPtr, sizeof(FxGlassGeometryData*) * count);
	FxGlassGeometryData** pointer = varFxGlassGeometryDataPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassGeometryDataPtr = pointer;
		Load_FxGlassGeometryDataPtr(false);
		pointer++;
	}
}

void Load_FxGlassHoleHeader(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassHoleHeader, sizeof(FxGlassHoleHeader));

}

void Load_FxGlassHoleHeaderArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassHoleHeader, sizeof(FxGlassHoleHeader) * count);
	FxGlassHoleHeader* pointer = varFxGlassHoleHeader;
	for (int i = 0; i < count; i++)
	{
		varFxGlassHoleHeader = pointer;
		Load_FxGlassHoleHeader(false);
		pointer++;
	}
}

void Load_FxGlassHoleHeaderPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassHoleHeader, sizeof(FxGlassHoleHeader));
	if (*varFxGlassHoleHeaderPtr != nullptr)
	{
		if (*varFxGlassHoleHeaderPtr == (FxGlassHoleHeader*)0xFFFFFFFF)
		{
			*varFxGlassHoleHeaderPtr = AllocLoad_FxGlassHoleHeader();
			varFxGlassHoleHeader = *varFxGlassHoleHeaderPtr;
			Load_FxGlassHoleHeader(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassHoleHeaderPtr);
		}
	}
}

void Load_FxGlassHoleHeaderPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassHoleHeaderPtr, sizeof(FxGlassHoleHeader*) * count);
	FxGlassHoleHeader** pointer = varFxGlassHoleHeaderPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassHoleHeaderPtr = pointer;
		Load_FxGlassHoleHeaderPtr(false);
		pointer++;
	}
}

void Load_FxGlassInitPieceState(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassInitPieceState, sizeof(FxGlassInitPieceState));

	varFxSpatialFrame = &varFxGlassInitPieceState->frame;
	Load_FxSpatialFrame(false);

}

void Load_FxGlassInitPieceStateArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassInitPieceState, sizeof(FxGlassInitPieceState) * count);
	FxGlassInitPieceState* pointer = varFxGlassInitPieceState;
	for (int i = 0; i < count; i++)
	{
		varFxGlassInitPieceState = pointer;
		Load_FxGlassInitPieceState(false);
		pointer++;
	}
}

void Load_FxGlassInitPieceStatePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassInitPieceState, sizeof(FxGlassInitPieceState));
	if (*varFxGlassInitPieceStatePtr != nullptr)
	{
		if (*varFxGlassInitPieceStatePtr == (FxGlassInitPieceState*)0xFFFFFFFF)
		{
			*varFxGlassInitPieceStatePtr = AllocLoad_FxGlassInitPieceState();
			varFxGlassInitPieceState = *varFxGlassInitPieceStatePtr;
			Load_FxGlassInitPieceState(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassInitPieceStatePtr);
		}
	}
}

void Load_FxGlassInitPieceStatePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassInitPieceStatePtr, sizeof(FxGlassInitPieceState*) * count);
	FxGlassInitPieceState** pointer = varFxGlassInitPieceStatePtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassInitPieceStatePtr = pointer;
		Load_FxGlassInitPieceStatePtr(false);
		pointer++;
	}
}

void Load_FxGlassPieceDynamics(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassPieceDynamics, sizeof(FxGlassPieceDynamics));

}

void Load_FxGlassPieceDynamicsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassPieceDynamics, sizeof(FxGlassPieceDynamics) * count);
	FxGlassPieceDynamics* pointer = varFxGlassPieceDynamics;
	for (int i = 0; i < count; i++)
	{
		varFxGlassPieceDynamics = pointer;
		Load_FxGlassPieceDynamics(false);
		pointer++;
	}
}

void Load_FxGlassPieceDynamicsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassPieceDynamics, sizeof(FxGlassPieceDynamics));
	if (*varFxGlassPieceDynamicsPtr != nullptr)
	{
		if (*varFxGlassPieceDynamicsPtr == (FxGlassPieceDynamics*)0xFFFFFFFF)
		{
			*varFxGlassPieceDynamicsPtr = AllocLoad_FxGlassPieceDynamics();
			varFxGlassPieceDynamics = *varFxGlassPieceDynamicsPtr;
			Load_FxGlassPieceDynamics(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassPieceDynamicsPtr);
		}
	}
}

void Load_FxGlassPieceDynamicsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassPieceDynamicsPtr, sizeof(FxGlassPieceDynamics*) * count);
	FxGlassPieceDynamics** pointer = varFxGlassPieceDynamicsPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassPieceDynamicsPtr = pointer;
		Load_FxGlassPieceDynamicsPtr(false);
		pointer++;
	}
}

void Load_FxGlassPiecePlace(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassPiecePlace, sizeof(FxGlassPiecePlace));

}

void Load_FxGlassPiecePlaceArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassPiecePlace, sizeof(FxGlassPiecePlace) * count);
	FxGlassPiecePlace* pointer = varFxGlassPiecePlace;
	for (int i = 0; i < count; i++)
	{
		varFxGlassPiecePlace = pointer;
		Load_FxGlassPiecePlace(false);
		pointer++;
	}
}

void Load_FxGlassPiecePlacePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassPiecePlace, sizeof(FxGlassPiecePlace));
	if (*varFxGlassPiecePlacePtr != nullptr)
	{
		if (*varFxGlassPiecePlacePtr == (FxGlassPiecePlace*)0xFFFFFFFF)
		{
			*varFxGlassPiecePlacePtr = AllocLoad_FxGlassPiecePlace();
			varFxGlassPiecePlace = *varFxGlassPiecePlacePtr;
			Load_FxGlassPiecePlace(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassPiecePlacePtr);
		}
	}
}

void Load_FxGlassPiecePlacePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassPiecePlacePtr, sizeof(FxGlassPiecePlace*) * count);
	FxGlassPiecePlace** pointer = varFxGlassPiecePlacePtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassPiecePlacePtr = pointer;
		Load_FxGlassPiecePlacePtr(false);
		pointer++;
	}
}

void Load_FxGlassPieceState(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassPieceState, sizeof(FxGlassPieceState));

}

void Load_FxGlassPieceStateArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassPieceState, sizeof(FxGlassPieceState) * count);
	FxGlassPieceState* pointer = varFxGlassPieceState;
	for (int i = 0; i < count; i++)
	{
		varFxGlassPieceState = pointer;
		Load_FxGlassPieceState(false);
		pointer++;
	}
}

void Load_FxGlassPieceStatePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassPieceState, sizeof(FxGlassPieceState));
	if (*varFxGlassPieceStatePtr != nullptr)
	{
		if (*varFxGlassPieceStatePtr == (FxGlassPieceState*)0xFFFFFFFF)
		{
			*varFxGlassPieceStatePtr = AllocLoad_FxGlassPieceState();
			varFxGlassPieceState = *varFxGlassPieceStatePtr;
			Load_FxGlassPieceState(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassPieceStatePtr);
		}
	}
}

void Load_FxGlassPieceStatePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassPieceStatePtr, sizeof(FxGlassPieceState*) * count);
	FxGlassPieceState** pointer = varFxGlassPieceStatePtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassPieceStatePtr = pointer;
		Load_FxGlassPieceStatePtr(false);
		pointer++;
	}
}

void Load_FxGlassSystem(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassSystem, sizeof(FxGlassSystem));

	if (varFxGlassSystem->defs)
	{
		if (varFxGlassSystem->defs == (FxGlassDef*)0xFFFFFFFF)
		{
			varFxGlassSystem->defs = AllocLoad_FxGlassDef();
			varFxGlassDef = varFxGlassSystem->defs;
			Load_FxGlassDefArray(true, (varFxGlassSystem->defCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->defs);
		}
	}

	if (varFxGlassSystem->piecePlaces)
	{
		if (varFxGlassSystem->piecePlaces == (FxGlassPiecePlace*)0xFFFFFFFF)
		{
			varFxGlassSystem->piecePlaces = AllocLoad_FxGlassPiecePlace();
			varFxGlassPiecePlace = varFxGlassSystem->piecePlaces;
			Load_FxGlassPiecePlaceArray(true, (varFxGlassSystem->pieceLimit));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->piecePlaces);
		}
	}

	if (varFxGlassSystem->pieceStates)
	{
		if (varFxGlassSystem->pieceStates == (FxGlassPieceState*)0xFFFFFFFF)
		{
			varFxGlassSystem->pieceStates = AllocLoad_FxGlassPieceState();
			varFxGlassPieceState = varFxGlassSystem->pieceStates;
			Load_FxGlassPieceStateArray(true, (varFxGlassSystem->pieceLimit));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->pieceStates);
		}
	}

	if (varFxGlassSystem->pieceDynamics)
	{
		if (varFxGlassSystem->pieceDynamics == (FxGlassPieceDynamics*)0xFFFFFFFF)
		{
			varFxGlassSystem->pieceDynamics = AllocLoad_FxGlassPieceDynamics();
			varFxGlassPieceDynamics = varFxGlassSystem->pieceDynamics;
			Load_FxGlassPieceDynamicsArray(true, (varFxGlassSystem->pieceLimit));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->pieceDynamics);
		}
	}

	if (varFxGlassSystem->geoData)
	{
		if (varFxGlassSystem->geoData == (FxGlassGeometryData*)0xFFFFFFFF)
		{
			varFxGlassSystem->geoData = AllocLoad_FxGlassGeometryData();
			varFxGlassGeometryData = varFxGlassSystem->geoData;
			Load_FxGlassGeometryDataArray(true, (varFxGlassSystem->geoDataLimit));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->geoData);
		}
	}

	varuint32 = varFxGlassSystem->isInUse;
	Load_uint32Array(true, varFxGlassSystem->pieceWordCount);

	varuint32 = varFxGlassSystem->cellBits;
	Load_uint32Array(true, varFxGlassSystem->pieceWordCount * varFxGlassSystem->cellCount);

	if (varFxGlassSystem->visData)
	{
		if (varFxGlassSystem->visData == (char16*)0xFFFFFFFF)
		{
			varFxGlassSystem->visData = AllocLoad_char16();
			varchar16 = varFxGlassSystem->visData;
			Load_char16Array(true, ((varFxGlassSystem->pieceLimit + 15) & 0xFFFFFFF0));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->visData);
		}
	}

	if (varFxGlassSystem->linkOrg)
	{
		if (varFxGlassSystem->linkOrg == (vec3_t*)0xFFFFFFFF)
		{
			varFxGlassSystem->linkOrg = AllocLoad_vec3_t();
			varvec3_t = varFxGlassSystem->linkOrg;
			Load_vec3_tArray(true, (varFxGlassSystem->pieceLimit));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->linkOrg);
		}
	}

	if (varFxGlassSystem->halfThickness)
	{
		if (varFxGlassSystem->halfThickness == (float16*)0xFFFFFFFF)
		{
			varFxGlassSystem->halfThickness = AllocLoad_float16();
			varfloat16 = varFxGlassSystem->halfThickness;
			Load_float16Array(true, ((varFxGlassSystem->pieceLimit + 3) & 0xFFFFFFFC));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->halfThickness);
		}
	}

	if (varFxGlassSystem->lightingHandles)
	{
		if (varFxGlassSystem->lightingHandles == (uint16*)0xFFFFFFFF)
		{
			varFxGlassSystem->lightingHandles = AllocLoad_uint16();
			varuint16 = varFxGlassSystem->lightingHandles;
			Load_uint16Array(true, (varFxGlassSystem->initPieceCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->lightingHandles);
		}
	}

	if (varFxGlassSystem->initPieceStates)
	{
		if (varFxGlassSystem->initPieceStates == (FxGlassInitPieceState*)0xFFFFFFFF)
		{
			varFxGlassSystem->initPieceStates = AllocLoad_FxGlassInitPieceState();
			varFxGlassInitPieceState = varFxGlassSystem->initPieceStates;
			Load_FxGlassInitPieceStateArray(true, (varFxGlassSystem->initPieceCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->initPieceStates);
		}
	}

	if (varFxGlassSystem->initGeoData)
	{
		if (varFxGlassSystem->initGeoData == (FxGlassGeometryData*)0xFFFFFFFF)
		{
			varFxGlassSystem->initGeoData = AllocLoad_FxGlassGeometryData();
			varFxGlassGeometryData = varFxGlassSystem->initGeoData;
			Load_FxGlassGeometryDataArray(true, (varFxGlassSystem->initGeoDataCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxGlassSystem->initGeoData);
		}
	}

}

void Load_FxGlassSystemArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassSystem, sizeof(FxGlassSystem) * count);
	FxGlassSystem* pointer = varFxGlassSystem;
	for (int i = 0; i < count; i++)
	{
		varFxGlassSystem = pointer;
		Load_FxGlassSystem(false);
		pointer++;
	}
}

void Load_FxGlassSystemPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassSystem, sizeof(FxGlassSystem));
	if (*varFxGlassSystemPtr != nullptr)
	{
		if (*varFxGlassSystemPtr == (FxGlassSystem*)0xFFFFFFFF)
		{
			*varFxGlassSystemPtr = AllocLoad_FxGlassSystem();
			varFxGlassSystem = *varFxGlassSystemPtr;
			Load_FxGlassSystem(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassSystemPtr);
		}
	}
}

void Load_FxGlassSystemPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassSystemPtr, sizeof(FxGlassSystem*) * count);
	FxGlassSystem** pointer = varFxGlassSystemPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassSystemPtr = pointer;
		Load_FxGlassSystemPtr(false);
		pointer++;
	}
}

void Load_FxGlassVertex(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassVertex, sizeof(FxGlassVertex));

}

void Load_FxGlassVertexArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassVertex, sizeof(FxGlassVertex) * count);
	FxGlassVertex* pointer = varFxGlassVertex;
	for (int i = 0; i < count; i++)
	{
		varFxGlassVertex = pointer;
		Load_FxGlassVertex(false);
		pointer++;
	}
}

void Load_FxGlassVertexPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxGlassVertex, sizeof(FxGlassVertex));
	if (*varFxGlassVertexPtr != nullptr)
	{
		if (*varFxGlassVertexPtr == (FxGlassVertex*)0xFFFFFFFF)
		{
			*varFxGlassVertexPtr = AllocLoad_FxGlassVertex();
			varFxGlassVertex = *varFxGlassVertexPtr;
			Load_FxGlassVertex(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxGlassVertexPtr);
		}
	}
}

void Load_FxGlassVertexPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxGlassVertexPtr, sizeof(FxGlassVertex*) * count);
	FxGlassVertex** pointer = varFxGlassVertexPtr;
	for (int i = 0; i < count; i++)
	{
		varFxGlassVertexPtr = pointer;
		Load_FxGlassVertexPtr(false);
		pointer++;
	}
}

void Load_FxIntRange(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxIntRange, sizeof(FxIntRange));

}

void Load_FxIntRangeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxIntRange, sizeof(FxIntRange) * count);
	FxIntRange* pointer = varFxIntRange;
	for (int i = 0; i < count; i++)
	{
		varFxIntRange = pointer;
		Load_FxIntRange(false);
		pointer++;
	}
}

void Load_FxIntRangePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxIntRange, sizeof(FxIntRange));
	if (*varFxIntRangePtr != nullptr)
	{
		if (*varFxIntRangePtr == (FxIntRange*)0xFFFFFFFF)
		{
			*varFxIntRangePtr = AllocLoad_FxIntRange();
			varFxIntRange = *varFxIntRangePtr;
			Load_FxIntRange(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxIntRangePtr);
		}
	}
}

void Load_FxIntRangePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxIntRangePtr, sizeof(FxIntRange*) * count);
	FxIntRange** pointer = varFxIntRangePtr;
	for (int i = 0; i < count; i++)
	{
		varFxIntRangePtr = pointer;
		Load_FxIntRangePtr(false);
		pointer++;
	}
}

void Load_FxSparkFountainDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSparkFountainDef, sizeof(FxSparkFountainDef));

}

void Load_FxSparkFountainDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSparkFountainDef, sizeof(FxSparkFountainDef) * count);
	FxSparkFountainDef* pointer = varFxSparkFountainDef;
	for (int i = 0; i < count; i++)
	{
		varFxSparkFountainDef = pointer;
		Load_FxSparkFountainDef(false);
		pointer++;
	}
}

void Load_FxSparkFountainDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSparkFountainDef, sizeof(FxSparkFountainDef));
	if (*varFxSparkFountainDefPtr != nullptr)
	{
		if (*varFxSparkFountainDefPtr == (FxSparkFountainDef*)0xFFFFFFFF)
		{
			*varFxSparkFountainDefPtr = AllocLoad_FxSparkFountainDef();
			varFxSparkFountainDef = *varFxSparkFountainDefPtr;
			Load_FxSparkFountainDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxSparkFountainDefPtr);
		}
	}
}

void Load_FxSparkFountainDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSparkFountainDefPtr, sizeof(FxSparkFountainDef*) * count);
	FxSparkFountainDef** pointer = varFxSparkFountainDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxSparkFountainDefPtr = pointer;
		Load_FxSparkFountainDefPtr(false);
		pointer++;
	}
}

void Load_FxSpatialFrame(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpatialFrame, sizeof(FxSpatialFrame));

}

void Load_FxSpatialFrameArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpatialFrame, sizeof(FxSpatialFrame) * count);
	FxSpatialFrame* pointer = varFxSpatialFrame;
	for (int i = 0; i < count; i++)
	{
		varFxSpatialFrame = pointer;
		Load_FxSpatialFrame(false);
		pointer++;
	}
}

void Load_FxSpatialFramePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpatialFrame, sizeof(FxSpatialFrame));
	if (*varFxSpatialFramePtr != nullptr)
	{
		if (*varFxSpatialFramePtr == (FxSpatialFrame*)0xFFFFFFFF)
		{
			*varFxSpatialFramePtr = AllocLoad_FxSpatialFrame();
			varFxSpatialFrame = *varFxSpatialFramePtr;
			Load_FxSpatialFrame(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxSpatialFramePtr);
		}
	}
}

void Load_FxSpatialFramePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpatialFramePtr, sizeof(FxSpatialFrame*) * count);
	FxSpatialFrame** pointer = varFxSpatialFramePtr;
	for (int i = 0; i < count; i++)
	{
		varFxSpatialFramePtr = pointer;
		Load_FxSpatialFramePtr(false);
		pointer++;
	}
}

void Load_FxSpawnDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpawnDef, sizeof(FxSpawnDef));

}

void Load_FxSpawnDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpawnDef, sizeof(FxSpawnDef) * count);
	FxSpawnDef* pointer = varFxSpawnDef;
	for (int i = 0; i < count; i++)
	{
		varFxSpawnDef = pointer;
		Load_FxSpawnDef(false);
		pointer++;
	}
}

void Load_FxSpawnDefLooping(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpawnDefLooping, sizeof(FxSpawnDefLooping));

}

void Load_FxSpawnDefLoopingArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpawnDefLooping, sizeof(FxSpawnDefLooping) * count);
	FxSpawnDefLooping* pointer = varFxSpawnDefLooping;
	for (int i = 0; i < count; i++)
	{
		varFxSpawnDefLooping = pointer;
		Load_FxSpawnDefLooping(false);
		pointer++;
	}
}

void Load_FxSpawnDefLoopingPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpawnDefLooping, sizeof(FxSpawnDefLooping));
	if (*varFxSpawnDefLoopingPtr != nullptr)
	{
		if (*varFxSpawnDefLoopingPtr == (FxSpawnDefLooping*)0xFFFFFFFF)
		{
			*varFxSpawnDefLoopingPtr = AllocLoad_FxSpawnDefLooping();
			varFxSpawnDefLooping = *varFxSpawnDefLoopingPtr;
			Load_FxSpawnDefLooping(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxSpawnDefLoopingPtr);
		}
	}
}

void Load_FxSpawnDefLoopingPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpawnDefLoopingPtr, sizeof(FxSpawnDefLooping*) * count);
	FxSpawnDefLooping** pointer = varFxSpawnDefLoopingPtr;
	for (int i = 0; i < count; i++)
	{
		varFxSpawnDefLoopingPtr = pointer;
		Load_FxSpawnDefLoopingPtr(false);
		pointer++;
	}
}

void Load_FxSpawnDefOneShot(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpawnDefOneShot, sizeof(FxSpawnDefOneShot));

	varFxIntRange = &varFxSpawnDefOneShot->count;
	Load_FxIntRange(false);

}

void Load_FxSpawnDefOneShotArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpawnDefOneShot, sizeof(FxSpawnDefOneShot) * count);
	FxSpawnDefOneShot* pointer = varFxSpawnDefOneShot;
	for (int i = 0; i < count; i++)
	{
		varFxSpawnDefOneShot = pointer;
		Load_FxSpawnDefOneShot(false);
		pointer++;
	}
}

void Load_FxSpawnDefOneShotPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpawnDefOneShot, sizeof(FxSpawnDefOneShot));
	if (*varFxSpawnDefOneShotPtr != nullptr)
	{
		*varFxSpawnDefOneShotPtr = AllocLoad_FxSpawnDefOneShot();
		varFxSpawnDefOneShot = *varFxSpawnDefOneShotPtr;
		Load_FxSpawnDefOneShot(true);
	}
}

void Load_FxSpawnDefOneShotPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpawnDefOneShotPtr, sizeof(FxSpawnDefOneShot*) * count);
	FxSpawnDefOneShot** pointer = varFxSpawnDefOneShotPtr;
	for (int i = 0; i < count; i++)
	{
		varFxSpawnDefOneShotPtr = pointer;
		Load_FxSpawnDefOneShotPtr(false);
		pointer++;
	}
}

void Load_FxSpawnDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxSpawnDef, sizeof(FxSpawnDef));
	if (*varFxSpawnDefPtr != nullptr)
	{
		if (*varFxSpawnDefPtr == (FxSpawnDef*)0xFFFFFFFF)
		{
			*varFxSpawnDefPtr = AllocLoad_FxSpawnDef();
			varFxSpawnDef = *varFxSpawnDefPtr;
			Load_FxSpawnDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxSpawnDefPtr);
		}
	}
}

void Load_FxSpawnDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxSpawnDefPtr, sizeof(FxSpawnDef*) * count);
	FxSpawnDef** pointer = varFxSpawnDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxSpawnDefPtr = pointer;
		Load_FxSpawnDefPtr(false);
		pointer++;
	}
}

void Load_FxTrailDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxTrailDef, sizeof(FxTrailDef));

	if (varFxTrailDef->verts)
	{
		if (varFxTrailDef->verts == (FxTrailVertex*)0xFFFFFFFF)
		{
			varFxTrailDef->verts = AllocLoad_FxTrailVertex();
			varFxTrailVertex = varFxTrailDef->verts;
			Load_FxTrailVertexArray(true, (varFxTrailDef->vertCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxTrailDef->verts);
		}
	}

	if (varFxTrailDef->inds)
	{
		if (varFxTrailDef->inds == (uint16*)0xFFFFFFFF)
		{
			varFxTrailDef->inds = AllocLoad_uint16();
			varuint16 = varFxTrailDef->inds;
			Load_uint16Array(true, (varFxTrailDef->indCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varFxTrailDef->inds);
		}
	}

}

void Load_FxTrailDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxTrailDef, sizeof(FxTrailDef) * count);
	FxTrailDef* pointer = varFxTrailDef;
	for (int i = 0; i < count; i++)
	{
		varFxTrailDef = pointer;
		Load_FxTrailDef(false);
		pointer++;
	}
}

void Load_FxTrailDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxTrailDef, sizeof(FxTrailDef));
	if (*varFxTrailDefPtr != nullptr)
	{
		if (*varFxTrailDefPtr == (FxTrailDef*)0xFFFFFFFF)
		{
			*varFxTrailDefPtr = AllocLoad_FxTrailDef();
			varFxTrailDef = *varFxTrailDefPtr;
			Load_FxTrailDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxTrailDefPtr);
		}
	}
}

void Load_FxTrailDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxTrailDefPtr, sizeof(FxTrailDef*) * count);
	FxTrailDef** pointer = varFxTrailDefPtr;
	for (int i = 0; i < count; i++)
	{
		varFxTrailDefPtr = pointer;
		Load_FxTrailDefPtr(false);
		pointer++;
	}
}

void Load_FxTrailVertex(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxTrailVertex, sizeof(FxTrailVertex));

}

void Load_FxTrailVertexArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxTrailVertex, sizeof(FxTrailVertex) * count);
	FxTrailVertex* pointer = varFxTrailVertex;
	for (int i = 0; i < count; i++)
	{
		varFxTrailVertex = pointer;
		Load_FxTrailVertex(false);
		pointer++;
	}
}

void Load_FxTrailVertexPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxTrailVertex, sizeof(FxTrailVertex));
	if (*varFxTrailVertexPtr != nullptr)
	{
		if (*varFxTrailVertexPtr == (FxTrailVertex*)0xFFFFFFFF)
		{
			*varFxTrailVertexPtr = AllocLoad_FxTrailVertex();
			varFxTrailVertex = *varFxTrailVertexPtr;
			Load_FxTrailVertex(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varFxTrailVertexPtr);
		}
	}
}

void Load_FxTrailVertexPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxTrailVertexPtr, sizeof(FxTrailVertex*) * count);
	FxTrailVertex** pointer = varFxTrailVertexPtr;
	for (int i = 0; i < count; i++)
	{
		varFxTrailVertexPtr = pointer;
		Load_FxTrailVertexPtr(false);
		pointer++;
	}
}

void Load_FxWorld(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxWorld, sizeof(FxWorld));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varFxWorld->name;
	Load_XString(false);

	varFxGlassSystem = &varFxWorld->glassSys;
	Load_FxGlassSystem(false);

	DB_PopStreamPos();
}

void Load_FxWorldArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxWorld, sizeof(FxWorld) * count);
	FxWorld* pointer = varFxWorld;
	for (int i = 0; i < count; i++)
	{
		varFxWorld = pointer;
		Load_FxWorld(false);
		pointer++;
	}
}

void Load_FxWorldAsset(FxWorld** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_FXWORLD, (void**)varFxWorldPtr);
}

void Load_FxWorldPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varFxWorld, sizeof(FxWorld*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	FxWorld* pointer = *varFxWorldPtr;
	if (*varFxWorldPtr != nullptr)
	{
		if (*varFxWorldPtr == (FxWorld*)0xFFFFFFFF || *varFxWorldPtr == (FxWorld*)0xFFFFFFFE)
		{
			*varFxWorldPtr = AllocLoad_FxWorld();
			varFxWorld = *varFxWorldPtr;
			FxWorld** insertedPointer = nullptr;
			if (pointer == (FxWorld*)0xFFFFFFFE)
			{
				insertedPointer = (FxWorld**)DB_InsertPointer();
			}
			Load_FxWorld(true);
			Load_FxWorldAsset(varFxWorldPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varFxWorldPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varFxWorldPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_FxWorldPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varFxWorldPtr, sizeof(FxWorld*) * count);
	FxWorld** pointer = varFxWorldPtr;
	for (int i = 0; i < count; i++)
	{
		varFxWorldPtr = pointer;
		Load_FxWorldPtr(false);
		pointer++;
	}
}

void Load_G_GlassData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varG_GlassData, sizeof(G_GlassData));

	if (varG_GlassData->glassPieces)
	{
		if (varG_GlassData->glassPieces == (G_GlassPiece*)0xFFFFFFFF)
		{
			varG_GlassData->glassPieces = AllocLoad_G_GlassPiece();
			varG_GlassPiece = varG_GlassData->glassPieces;
			Load_G_GlassPieceArray(true, (varG_GlassData->pieceCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varG_GlassData->glassPieces);
		}
	}

	if (varG_GlassData->glassNames)
	{
		if (varG_GlassData->glassNames == (G_GlassName*)0xFFFFFFFF)
		{
			varG_GlassData->glassNames = AllocLoad_G_GlassName();
			varG_GlassName = varG_GlassData->glassNames;
			Load_G_GlassNameArray(true, (varG_GlassData->glassNameCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varG_GlassData->glassNames);
		}
	}

}

void Load_G_GlassDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varG_GlassData, sizeof(G_GlassData) * count);
	G_GlassData* pointer = varG_GlassData;
	for (int i = 0; i < count; i++)
	{
		varG_GlassData = pointer;
		Load_G_GlassData(false);
		pointer++;
	}
}

void Load_G_GlassDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varG_GlassData, sizeof(G_GlassData));
	if (*varG_GlassDataPtr != nullptr)
	{
		if (*varG_GlassDataPtr == (G_GlassData*)0xFFFFFFFF)
		{
			*varG_GlassDataPtr = AllocLoad_G_GlassData();
			varG_GlassData = *varG_GlassDataPtr;
			Load_G_GlassData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varG_GlassDataPtr);
		}
	}
}

void Load_G_GlassDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varG_GlassDataPtr, sizeof(G_GlassData*) * count);
	G_GlassData** pointer = varG_GlassDataPtr;
	for (int i = 0; i < count; i++)
	{
		varG_GlassDataPtr = pointer;
		Load_G_GlassDataPtr(false);
		pointer++;
	}
}

void Load_G_GlassName(bool atStreamStart)
{
	Load_Stream(atStreamStart, varG_GlassName, sizeof(G_GlassName));

	varXString = &varG_GlassName->nameStr;
	Load_XString(false);

	if (varG_GlassName->pieceIndices)
	{
		if (varG_GlassName->pieceIndices == (uint16*)0xFFFFFFFF)
		{
			varG_GlassName->pieceIndices = AllocLoad_uint16();
			varuint16 = varG_GlassName->pieceIndices;
			Load_uint16Array(true, (varG_GlassName->pieceCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varG_GlassName->pieceIndices);
		}
	}

}

void Load_G_GlassNameArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varG_GlassName, sizeof(G_GlassName) * count);
	G_GlassName* pointer = varG_GlassName;
	for (int i = 0; i < count; i++)
	{
		varG_GlassName = pointer;
		Load_G_GlassName(false);
		pointer++;
	}
}

void Load_G_GlassNamePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varG_GlassName, sizeof(G_GlassName));
	if (*varG_GlassNamePtr != nullptr)
	{
		if (*varG_GlassNamePtr == (G_GlassName*)0xFFFFFFFF)
		{
			*varG_GlassNamePtr = AllocLoad_G_GlassName();
			varG_GlassName = *varG_GlassNamePtr;
			Load_G_GlassName(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varG_GlassNamePtr);
		}
	}
}

void Load_G_GlassNamePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varG_GlassNamePtr, sizeof(G_GlassName*) * count);
	G_GlassName** pointer = varG_GlassNamePtr;
	for (int i = 0; i < count; i++)
	{
		varG_GlassNamePtr = pointer;
		Load_G_GlassNamePtr(false);
		pointer++;
	}
}

void Load_G_GlassPiece(bool atStreamStart)
{
	Load_Stream(atStreamStart, varG_GlassPiece, sizeof(G_GlassPiece));

}

void Load_G_GlassPieceArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varG_GlassPiece, sizeof(G_GlassPiece) * count);
	G_GlassPiece* pointer = varG_GlassPiece;
	for (int i = 0; i < count; i++)
	{
		varG_GlassPiece = pointer;
		Load_G_GlassPiece(false);
		pointer++;
	}
}

void Load_G_GlassPiecePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varG_GlassPiece, sizeof(G_GlassPiece));
	if (*varG_GlassPiecePtr != nullptr)
	{
		if (*varG_GlassPiecePtr == (G_GlassPiece*)0xFFFFFFFF)
		{
			*varG_GlassPiecePtr = AllocLoad_G_GlassPiece();
			varG_GlassPiece = *varG_GlassPiecePtr;
			Load_G_GlassPiece(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varG_GlassPiecePtr);
		}
	}
}

void Load_G_GlassPiecePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varG_GlassPiecePtr, sizeof(G_GlassPiece*) * count);
	G_GlassPiece** pointer = varG_GlassPiecePtr;
	for (int i = 0; i < count; i++)
	{
		varG_GlassPiecePtr = pointer;
		Load_G_GlassPiecePtr(false);
		pointer++;
	}
}

void Load_GameWorldMp(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGameWorldMp, sizeof(GameWorldMp));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varGameWorldMp->name;
	Load_XString(false);

	if (varGameWorldMp->g_glassData)
	{
		varG_GlassDataPtr = &varGameWorldMp->g_glassData;
		Load_G_GlassDataPtr(false);
	}

	DB_PopStreamPos();
}

void Load_GameWorldMpArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGameWorldMp, sizeof(GameWorldMp) * count);
	GameWorldMp* pointer = varGameWorldMp;
	for (int i = 0; i < count; i++)
	{
		varGameWorldMp = pointer;
		Load_GameWorldMp(false);
		pointer++;
	}
}

void Load_GameWorldMpAsset(GameWorldMp** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_GAMEWORLD_MP, (void**)varGameWorldMpPtr);
}

void Load_GameWorldMpPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGameWorldMp, sizeof(GameWorldMp*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	GameWorldMp* pointer = *varGameWorldMpPtr;
	if (*varGameWorldMpPtr != nullptr)
	{
		if (*varGameWorldMpPtr == (GameWorldMp*)0xFFFFFFFF || *varGameWorldMpPtr == (GameWorldMp*)0xFFFFFFFE)
		{
			*varGameWorldMpPtr = AllocLoad_GameWorldMp();
			varGameWorldMp = *varGameWorldMpPtr;
			GameWorldMp** insertedPointer = nullptr;
			if (pointer == (GameWorldMp*)0xFFFFFFFE)
			{
				insertedPointer = (GameWorldMp**)DB_InsertPointer();
			}
			Load_GameWorldMp(true);
			Load_GameWorldMpAsset(varGameWorldMpPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varGameWorldMpPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varGameWorldMpPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_GameWorldMpPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGameWorldMpPtr, sizeof(GameWorldMp*) * count);
	GameWorldMp** pointer = varGameWorldMpPtr;
	for (int i = 0; i < count; i++)
	{
		varGameWorldMpPtr = pointer;
		Load_GameWorldMpPtr(false);
		pointer++;
	}
}

void Load_GfxColor(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxColor, sizeof(GfxColor));

}

void Load_GfxColorArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxColor, sizeof(GfxColor) * count);
	GfxColor* pointer = varGfxColor;
	for (int i = 0; i < count; i++)
	{
		varGfxColor = pointer;
		Load_GfxColor(false);
		pointer++;
	}
}

void Load_GfxColorPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxColor, sizeof(GfxColor));
	if (*varGfxColorPtr != nullptr)
	{
		if (*varGfxColorPtr == (GfxColor*)0xFFFFFFFF)
		{
			*varGfxColorPtr = AllocLoad_GfxColor();
			varGfxColor = *varGfxColorPtr;
			Load_GfxColor(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGfxColorPtr);
		}
	}
}

void Load_GfxColorPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxColorPtr, sizeof(GfxColor*) * count);
	GfxColor** pointer = varGfxColorPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxColorPtr = pointer;
		Load_GfxColorPtr(false);
		pointer++;
	}
}

void Load_GfxDrawSurf(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxDrawSurf, sizeof(GfxDrawSurf));

}

void Load_GfxDrawSurfArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxDrawSurf, sizeof(GfxDrawSurf) * count);
	GfxDrawSurf* pointer = varGfxDrawSurf;
	for (int i = 0; i < count; i++)
	{
		varGfxDrawSurf = pointer;
		Load_GfxDrawSurf(false);
		pointer++;
	}
}

void Load_GfxDrawSurfPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxDrawSurf, sizeof(GfxDrawSurf));
	if (*varGfxDrawSurfPtr != nullptr)
	{
		*varGfxDrawSurfPtr = AllocLoad_GfxDrawSurf();
		varGfxDrawSurf = *varGfxDrawSurfPtr;
		Load_GfxDrawSurf(true);
	}
}

void Load_GfxDrawSurfPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxDrawSurfPtr, sizeof(GfxDrawSurf*) * count);
	GfxDrawSurf** pointer = varGfxDrawSurfPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxDrawSurfPtr = pointer;
		Load_GfxDrawSurfPtr(false);
		pointer++;
	}
}

void Load_GfxImage(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxImage, sizeof(GfxImage));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varGfxImage->name;
	Load_XString(false);

	varGfxTexture = &varGfxImage->texture;
	Load_GfxTexture(false);

	varPicmip = &varGfxImage->picmip;
	Load_Picmip(false);

	varCardMemory = &varGfxImage->cardMemory;
	Load_CardMemory(false);

	DB_PopStreamPos();
}

void Load_GfxImageArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxImage, sizeof(GfxImage) * count);
	GfxImage* pointer = varGfxImage;
	for (int i = 0; i < count; i++)
	{
		varGfxImage = pointer;
		Load_GfxImage(false);
		pointer++;
	}
}

void Load_GfxImageAsset(GfxImage** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_IMAGE, (void**)varGfxImagePtr);
}

void Load_GfxImageLoadDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxImageLoadDef, (sizeof(GfxImageLoadDef) - 4));

	varchar = varGfxImageLoadDef->data;
	Load_charArray(true, varGfxImageLoadDef->resourceSize);

}

void Load_GfxImageLoadDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxImageLoadDef, sizeof(GfxImageLoadDef) * count);
	GfxImageLoadDef* pointer = varGfxImageLoadDef;
	for (int i = 0; i < count; i++)
	{
		varGfxImageLoadDef = pointer;
		Load_GfxImageLoadDef(false);
		pointer++;
	}
}

void Load_GfxImageLoadDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxImageLoadDef, sizeof(GfxImageLoadDef*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	GfxImageLoadDef* pointer = *varGfxImageLoadDefPtr;
	if (*varGfxImageLoadDefPtr != nullptr)
	{
		if (*varGfxImageLoadDefPtr == (GfxImageLoadDef*)0xFFFFFFFF || *varGfxImageLoadDefPtr == (GfxImageLoadDef*)0xFFFFFFFE)
		{
			*varGfxImageLoadDefPtr = AllocLoad_GfxImageLoadDef();
			varGfxImageLoadDef = *varGfxImageLoadDefPtr;
			GfxImageLoadDef** insertedPointer = nullptr;
			if (pointer == (GfxImageLoadDef*)0xFFFFFFFE)
			{
				insertedPointer = (GfxImageLoadDef**)DB_InsertPointer();
			}
			Load_GfxImageLoadDef(true);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varGfxImageLoadDefPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varGfxImageLoadDefPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_GfxImageLoadDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxImageLoadDefPtr, sizeof(GfxImageLoadDef*) * count);
	GfxImageLoadDef** pointer = varGfxImageLoadDefPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxImageLoadDefPtr = pointer;
		Load_GfxImageLoadDefPtr(false);
		pointer++;
	}
}

void Load_GfxImagePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxImage, sizeof(GfxImage*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	GfxImage* pointer = *varGfxImagePtr;
	if (*varGfxImagePtr != nullptr)
	{
		if (*varGfxImagePtr == (GfxImage*)0xFFFFFFFF || *varGfxImagePtr == (GfxImage*)0xFFFFFFFE)
		{
			*varGfxImagePtr = AllocLoad_GfxImage();
			varGfxImage = *varGfxImagePtr;
			GfxImage** insertedPointer = nullptr;
			if (pointer == (GfxImage*)0xFFFFFFFE)
			{
				insertedPointer = (GfxImage**)DB_InsertPointer();
			}
			Load_GfxImage(true);
			Load_GfxImageAsset(varGfxImagePtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varGfxImagePtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varGfxImagePtr);
		}
	}
	DB_PopStreamPos();
}

void Load_GfxImagePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxImagePtr, sizeof(GfxImage*) * count);
	GfxImage** pointer = varGfxImagePtr;
	for (int i = 0; i < count; i++)
	{
		varGfxImagePtr = pointer;
		Load_GfxImagePtr(false);
		pointer++;
	}
}

void Load_GfxLightDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxLightDef, sizeof(GfxLightDef));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varGfxLightDef->name;
	Load_XString(false);

	varGfxLightImage = &varGfxLightDef->attenuation;
	Load_GfxLightImage(false);

	DB_PopStreamPos();
}

void Load_GfxLightDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxLightDef, sizeof(GfxLightDef) * count);
	GfxLightDef* pointer = varGfxLightDef;
	for (int i = 0; i < count; i++)
	{
		varGfxLightDef = pointer;
		Load_GfxLightDef(false);
		pointer++;
	}
}

void Load_GfxLightDefAsset(GfxLightDef** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_LIGHT_DEF, (void**)varGfxLightDefPtr);
}

void Load_GfxLightDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxLightDef, sizeof(GfxLightDef*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	GfxLightDef* pointer = *varGfxLightDefPtr;
	if (*varGfxLightDefPtr != nullptr)
	{
		if (*varGfxLightDefPtr == (GfxLightDef*)0xFFFFFFFF || *varGfxLightDefPtr == (GfxLightDef*)0xFFFFFFFE)
		{
			*varGfxLightDefPtr = AllocLoad_GfxLightDef();
			varGfxLightDef = *varGfxLightDefPtr;
			GfxLightDef** insertedPointer = nullptr;
			if (pointer == (GfxLightDef*)0xFFFFFFFE)
			{
				insertedPointer = (GfxLightDef**)DB_InsertPointer();
			}
			Load_GfxLightDef(true);
			Load_GfxLightDefAsset(varGfxLightDefPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varGfxLightDefPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varGfxLightDefPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_GfxLightDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxLightDefPtr, sizeof(GfxLightDef*) * count);
	GfxLightDef** pointer = varGfxLightDefPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxLightDefPtr = pointer;
		Load_GfxLightDefPtr(false);
		pointer++;
	}
}

void Load_GfxLightImage(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxLightImage, sizeof(GfxLightImage));

	varGfxImagePtr = &varGfxLightImage->image;
	Load_GfxImagePtr(false);

}

void Load_GfxLightImageArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxLightImage, sizeof(GfxLightImage) * count);
	GfxLightImage* pointer = varGfxLightImage;
	for (int i = 0; i < count; i++)
	{
		varGfxLightImage = pointer;
		Load_GfxLightImage(false);
		pointer++;
	}
}

void Load_GfxLightImagePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxLightImage, sizeof(GfxLightImage));
	if (*varGfxLightImagePtr != nullptr)
	{
		if (*varGfxLightImagePtr == (GfxLightImage*)0xFFFFFFFF)
		{
			*varGfxLightImagePtr = AllocLoad_GfxLightImage();
			varGfxLightImage = *varGfxLightImagePtr;
			Load_GfxLightImage(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGfxLightImagePtr);
		}
	}
}

void Load_GfxLightImagePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxLightImagePtr, sizeof(GfxLightImage*) * count);
	GfxLightImage** pointer = varGfxLightImagePtr;
	for (int i = 0; i < count; i++)
	{
		varGfxLightImagePtr = pointer;
		Load_GfxLightImagePtr(false);
		pointer++;
	}
}

void Load_GfxPackedVertex(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxPackedVertex, sizeof(GfxPackedVertex));

	varGfxColor = &varGfxPackedVertex->color;
	Load_GfxColor(false);

	varPackedTexCoords = &varGfxPackedVertex->texCoord;
	Load_PackedTexCoords(false);

	varPackedUnitVec = &varGfxPackedVertex->normal;
	Load_PackedUnitVec(false);

	varPackedUnitVec = &varGfxPackedVertex->tangent;
	Load_PackedUnitVec(false);

}

void Load_GfxPackedVertexArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxPackedVertex, sizeof(GfxPackedVertex) * count);
	GfxPackedVertex* pointer = varGfxPackedVertex;
	for (int i = 0; i < count; i++)
	{
		varGfxPackedVertex = pointer;
		Load_GfxPackedVertex(false);
		pointer++;
	}
}

void Load_GfxPackedVertexPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxPackedVertex, sizeof(GfxPackedVertex));
	if (*varGfxPackedVertexPtr != nullptr)
	{
		if (*varGfxPackedVertexPtr == (GfxPackedVertex*)0xFFFFFFFF)
		{
			*varGfxPackedVertexPtr = AllocLoad_GfxPackedVertex();
			varGfxPackedVertex = *varGfxPackedVertexPtr;
			Load_GfxPackedVertex(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGfxPackedVertexPtr);
		}
	}
}

void Load_GfxPackedVertexPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxPackedVertexPtr, sizeof(GfxPackedVertex*) * count);
	GfxPackedVertex** pointer = varGfxPackedVertexPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxPackedVertexPtr = pointer;
		Load_GfxPackedVertexPtr(false);
		pointer++;
	}
}

void Load_GfxPixelShaderLoadDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxPixelShaderLoadDef, sizeof(GfxPixelShaderLoadDef));

	varint32 = varGfxPixelShaderLoadDef->program;
	Load_int32Array(true, varGfxPixelShaderLoadDef->programSize);

}

void Load_GfxPixelShaderLoadDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxPixelShaderLoadDef, sizeof(GfxPixelShaderLoadDef) * count);
	GfxPixelShaderLoadDef* pointer = varGfxPixelShaderLoadDef;
	for (int i = 0; i < count; i++)
	{
		varGfxPixelShaderLoadDef = pointer;
		Load_GfxPixelShaderLoadDef(false);
		pointer++;
	}
}

void Load_GfxPixelShaderLoadDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxPixelShaderLoadDef, sizeof(GfxPixelShaderLoadDef));
	if (*varGfxPixelShaderLoadDefPtr != nullptr)
	{
		if (*varGfxPixelShaderLoadDefPtr == (GfxPixelShaderLoadDef*)0xFFFFFFFF)
		{
			*varGfxPixelShaderLoadDefPtr = AllocLoad_GfxPixelShaderLoadDef();
			varGfxPixelShaderLoadDef = *varGfxPixelShaderLoadDefPtr;
			Load_GfxPixelShaderLoadDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGfxPixelShaderLoadDefPtr);
		}
	}
}

void Load_GfxPixelShaderLoadDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxPixelShaderLoadDefPtr, sizeof(GfxPixelShaderLoadDef*) * count);
	GfxPixelShaderLoadDef** pointer = varGfxPixelShaderLoadDefPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxPixelShaderLoadDefPtr = pointer;
		Load_GfxPixelShaderLoadDefPtr(false);
		pointer++;
	}
}

void Load_GfxPlacement(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxPlacement, sizeof(GfxPlacement));

}

void Load_GfxPlacementArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxPlacement, sizeof(GfxPlacement) * count);
	GfxPlacement* pointer = varGfxPlacement;
	for (int i = 0; i < count; i++)
	{
		varGfxPlacement = pointer;
		Load_GfxPlacement(false);
		pointer++;
	}
}

void Load_GfxPlacementPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxPlacement, sizeof(GfxPlacement));
	if (*varGfxPlacementPtr != nullptr)
	{
		if (*varGfxPlacementPtr == (GfxPlacement*)0xFFFFFFFF)
		{
			*varGfxPlacementPtr = AllocLoad_GfxPlacement();
			varGfxPlacement = *varGfxPlacementPtr;
			Load_GfxPlacement(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGfxPlacementPtr);
		}
	}
}

void Load_GfxPlacementPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxPlacementPtr, sizeof(GfxPlacement*) * count);
	GfxPlacement** pointer = varGfxPlacementPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxPlacementPtr = pointer;
		Load_GfxPlacementPtr(false);
		pointer++;
	}
}

void Load_GfxStateBits(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxStateBits, sizeof(GfxStateBits));

}

void Load_GfxStateBitsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxStateBits, sizeof(GfxStateBits) * count);
	GfxStateBits* pointer = varGfxStateBits;
	for (int i = 0; i < count; i++)
	{
		varGfxStateBits = pointer;
		Load_GfxStateBits(false);
		pointer++;
	}
}

void Load_GfxStateBitsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxStateBits, sizeof(GfxStateBits));
	if (*varGfxStateBitsPtr != nullptr)
	{
		*varGfxStateBitsPtr = AllocLoad_GfxStateBits();
		varGfxStateBits = *varGfxStateBitsPtr;
		Load_GfxStateBits(true);
	}
}

void Load_GfxStateBitsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxStateBitsPtr, sizeof(GfxStateBits*) * count);
	GfxStateBits** pointer = varGfxStateBitsPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxStateBitsPtr = pointer;
		Load_GfxStateBitsPtr(false);
		pointer++;
	}
}

void Load_GfxTexture(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxTexture, sizeof(GfxTexture));

	switch (varGfxImage->mapType)
	{
	default:
		varGfxImageLoadDefPtr = &varGfxTexture->loadDef;
		Load_GfxImageLoadDefPtr(false);
		break;
	}
}

void Load_GfxTextureArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxTexture, sizeof(GfxTexture) * count);
	GfxTexture* pointer = varGfxTexture;
	for (int i = 0; i < count; i++)
	{
		varGfxTexture = pointer;
		Load_GfxTexture(false);
		pointer++;
	}
}

void Load_GfxTexturePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxTexture, sizeof(GfxTexture));
	if (*varGfxTexturePtr != nullptr)
	{
		*varGfxTexturePtr = AllocLoad_GfxTexture();
		varGfxTexture = *varGfxTexturePtr;
		Load_GfxTexture(true);
	}
}

void Load_GfxTexturePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxTexturePtr, sizeof(GfxTexture*) * count);
	GfxTexture** pointer = varGfxTexturePtr;
	for (int i = 0; i < count; i++)
	{
		varGfxTexturePtr = pointer;
		Load_GfxTexturePtr(false);
		pointer++;
	}
}

void Load_GfxVertexShaderLoadDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxVertexShaderLoadDef, sizeof(GfxVertexShaderLoadDef));

	varuint32 = varGfxVertexShaderLoadDef->program;
	Load_uint32Array(true, varGfxVertexShaderLoadDef->programSize);

}

void Load_GfxVertexShaderLoadDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxVertexShaderLoadDef, sizeof(GfxVertexShaderLoadDef) * count);
	GfxVertexShaderLoadDef* pointer = varGfxVertexShaderLoadDef;
	for (int i = 0; i < count; i++)
	{
		varGfxVertexShaderLoadDef = pointer;
		Load_GfxVertexShaderLoadDef(false);
		pointer++;
	}
}

void Load_GfxVertexShaderLoadDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGfxVertexShaderLoadDef, sizeof(GfxVertexShaderLoadDef));
	if (*varGfxVertexShaderLoadDefPtr != nullptr)
	{
		if (*varGfxVertexShaderLoadDefPtr == (GfxVertexShaderLoadDef*)0xFFFFFFFF)
		{
			*varGfxVertexShaderLoadDefPtr = AllocLoad_GfxVertexShaderLoadDef();
			varGfxVertexShaderLoadDef = *varGfxVertexShaderLoadDefPtr;
			Load_GfxVertexShaderLoadDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGfxVertexShaderLoadDefPtr);
		}
	}
}

void Load_GfxVertexShaderLoadDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGfxVertexShaderLoadDefPtr, sizeof(GfxVertexShaderLoadDef*) * count);
	GfxVertexShaderLoadDef** pointer = varGfxVertexShaderLoadDefPtr;
	for (int i = 0; i < count; i++)
	{
		varGfxVertexShaderLoadDefPtr = pointer;
		Load_GfxVertexShaderLoadDefPtr(false);
		pointer++;
	}
}

void Load_Glyph(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGlyph, sizeof(Glyph));

}

void Load_GlyphArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGlyph, sizeof(Glyph) * count);
	Glyph* pointer = varGlyph;
	for (int i = 0; i < count; i++)
	{
		varGlyph = pointer;
		Load_Glyph(false);
		pointer++;
	}
}

void Load_GlyphPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varGlyph, sizeof(Glyph));
	if (*varGlyphPtr != nullptr)
	{
		if (*varGlyphPtr == (Glyph*)0xFFFFFFFF)
		{
			*varGlyphPtr = AllocLoad_Glyph();
			varGlyph = *varGlyphPtr;
			Load_Glyph(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varGlyphPtr);
		}
	}
}

void Load_GlyphPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varGlyphPtr, sizeof(Glyph*) * count);
	Glyph** pointer = varGlyphPtr;
	for (int i = 0; i < count; i++)
	{
		varGlyphPtr = pointer;
		Load_GlyphPtr(false);
		pointer++;
	}
}

void Load_ItemFloatExpression(bool atStreamStart)
{
	Load_Stream(atStreamStart, varItemFloatExpression, sizeof(ItemFloatExpression));

	if (varItemFloatExpression->expression)
	{
		varStatement_sPtr = &varItemFloatExpression->expression;
		Load_Statement_sPtr(false);
	}

}

void Load_ItemFloatExpressionArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varItemFloatExpression, sizeof(ItemFloatExpression) * count);
	ItemFloatExpression* pointer = varItemFloatExpression;
	for (int i = 0; i < count; i++)
	{
		varItemFloatExpression = pointer;
		Load_ItemFloatExpression(false);
		pointer++;
	}
}

void Load_ItemFloatExpressionPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varItemFloatExpression, sizeof(ItemFloatExpression));
	if (*varItemFloatExpressionPtr != nullptr)
	{
		if (*varItemFloatExpressionPtr == (ItemFloatExpression*)0xFFFFFFFF)
		{
			*varItemFloatExpressionPtr = AllocLoad_ItemFloatExpression();
			varItemFloatExpression = *varItemFloatExpressionPtr;
			Load_ItemFloatExpression(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varItemFloatExpressionPtr);
		}
	}
}

void Load_ItemFloatExpressionPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varItemFloatExpressionPtr, sizeof(ItemFloatExpression*) * count);
	ItemFloatExpression** pointer = varItemFloatExpressionPtr;
	for (int i = 0; i < count; i++)
	{
		varItemFloatExpressionPtr = pointer;
		Load_ItemFloatExpressionPtr(false);
		pointer++;
	}
}

void Load_ItemKeyHandler(bool atStreamStart)
{
	Load_Stream(atStreamStart, varItemKeyHandler, sizeof(ItemKeyHandler));

	if (varItemKeyHandler->action)
	{
		varMenuEventHandlerSetPtr = &varItemKeyHandler->action;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varItemKeyHandler->next)
	{
		varItemKeyHandlerPtr = &varItemKeyHandler->next;
		Load_ItemKeyHandlerPtr(false);
	}

}

void Load_ItemKeyHandlerArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varItemKeyHandler, sizeof(ItemKeyHandler) * count);
	ItemKeyHandler* pointer = varItemKeyHandler;
	for (int i = 0; i < count; i++)
	{
		varItemKeyHandler = pointer;
		Load_ItemKeyHandler(false);
		pointer++;
	}
}

void Load_ItemKeyHandlerPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varItemKeyHandler, sizeof(ItemKeyHandler));
	if (*varItemKeyHandlerPtr != nullptr)
	{
		if (*varItemKeyHandlerPtr == (ItemKeyHandler*)0xFFFFFFFF)
		{
			*varItemKeyHandlerPtr = AllocLoad_ItemKeyHandler();
			varItemKeyHandler = *varItemKeyHandlerPtr;
			Load_ItemKeyHandler(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varItemKeyHandlerPtr);
		}
	}
}

void Load_ItemKeyHandlerPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varItemKeyHandlerPtr, sizeof(ItemKeyHandler*) * count);
	ItemKeyHandler** pointer = varItemKeyHandlerPtr;
	for (int i = 0; i < count; i++)
	{
		varItemKeyHandlerPtr = pointer;
		Load_ItemKeyHandlerPtr(false);
		pointer++;
	}
}

void Load_LbColumnDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLbColumnDef, sizeof(LbColumnDef));

	varXString = &varLbColumnDef->name;
	Load_XString(false);

	varXString = &varLbColumnDef->statName;
	Load_XString(false);

}

void Load_LbColumnDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLbColumnDef, sizeof(LbColumnDef) * count);
	LbColumnDef* pointer = varLbColumnDef;
	for (int i = 0; i < count; i++)
	{
		varLbColumnDef = pointer;
		Load_LbColumnDef(false);
		pointer++;
	}
}

void Load_LbColumnDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLbColumnDef, sizeof(LbColumnDef));
	if (*varLbColumnDefPtr != nullptr)
	{
		if (*varLbColumnDefPtr == (LbColumnDef*)0xFFFFFFFF)
		{
			*varLbColumnDefPtr = AllocLoad_LbColumnDef();
			varLbColumnDef = *varLbColumnDefPtr;
			Load_LbColumnDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varLbColumnDefPtr);
		}
	}
}

void Load_LbColumnDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLbColumnDefPtr, sizeof(LbColumnDef*) * count);
	LbColumnDef** pointer = varLbColumnDefPtr;
	for (int i = 0; i < count; i++)
	{
		varLbColumnDefPtr = pointer;
		Load_LbColumnDefPtr(false);
		pointer++;
	}
}

void Load_LeaderboardDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLeaderboardDef, sizeof(LeaderboardDef));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varLeaderboardDef->name;
	Load_XString(false);

	if (varLeaderboardDef->columns)
	{
		if (varLeaderboardDef->columns == (LbColumnDef*)0xFFFFFFFF)
		{
			varLeaderboardDef->columns = AllocLoad_LbColumnDef();
			varLbColumnDef = varLeaderboardDef->columns;
			Load_LbColumnDefArray(true, (varLeaderboardDef->columnCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varLeaderboardDef->columns);
		}
	}

	DB_PopStreamPos();
}

void Load_LeaderboardDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLeaderboardDef, sizeof(LeaderboardDef) * count);
	LeaderboardDef* pointer = varLeaderboardDef;
	for (int i = 0; i < count; i++)
	{
		varLeaderboardDef = pointer;
		Load_LeaderboardDef(false);
		pointer++;
	}
}

void Load_LeaderboardDefAsset(LeaderboardDef** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_LEADERBOARD, (void**)varLeaderboardDefPtr);
}

void Load_LeaderboardDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLeaderboardDef, sizeof(LeaderboardDef*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	LeaderboardDef* pointer = *varLeaderboardDefPtr;
	if (*varLeaderboardDefPtr != nullptr)
	{
		if (*varLeaderboardDefPtr == (LeaderboardDef*)0xFFFFFFFF || *varLeaderboardDefPtr == (LeaderboardDef*)0xFFFFFFFE)
		{
			*varLeaderboardDefPtr = AllocLoad_LeaderboardDef();
			varLeaderboardDef = *varLeaderboardDefPtr;
			LeaderboardDef** insertedPointer = nullptr;
			if (pointer == (LeaderboardDef*)0xFFFFFFFE)
			{
				insertedPointer = (LeaderboardDef**)DB_InsertPointer();
			}
			Load_LeaderboardDef(true);
			Load_LeaderboardDefAsset(varLeaderboardDefPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varLeaderboardDefPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varLeaderboardDefPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_LeaderboardDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLeaderboardDefPtr, sizeof(LeaderboardDef*) * count);
	LeaderboardDef** pointer = varLeaderboardDefPtr;
	for (int i = 0; i < count; i++)
	{
		varLeaderboardDefPtr = pointer;
		Load_LeaderboardDefPtr(false);
		pointer++;
	}
}

void Load_LoadedSound(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLoadedSound, sizeof(LoadedSound));

	varXString = &varLoadedSound->name;
	Load_XString(false);

	varMssSound = &varLoadedSound->sound;
	Load_MssSound(false);

}

void Load_LoadedSoundArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLoadedSound, sizeof(LoadedSound) * count);
	LoadedSound* pointer = varLoadedSound;
	for (int i = 0; i < count; i++)
	{
		varLoadedSound = pointer;
		Load_LoadedSound(false);
		pointer++;
	}
}

void Load_LoadedSoundPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLoadedSound, sizeof(LoadedSound));
	if (*varLoadedSoundPtr != nullptr)
	{
		if (*varLoadedSoundPtr == (LoadedSound*)0xFFFFFFFF)
		{
			*varLoadedSoundPtr = AllocLoad_LoadedSound();
			varLoadedSound = *varLoadedSoundPtr;
			Load_LoadedSound(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varLoadedSoundPtr);
		}
	}
}

void Load_LoadedSoundPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLoadedSoundPtr, sizeof(LoadedSound*) * count);
	LoadedSound** pointer = varLoadedSoundPtr;
	for (int i = 0; i < count; i++)
	{
		varLoadedSoundPtr = pointer;
		Load_LoadedSoundPtr(false);
		pointer++;
	}
}

void Load_LocalizeEntry(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLocalizeEntry, sizeof(LocalizeEntry));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varLocalizeEntry->name;
	Load_XString(false);

	varXString = &varLocalizeEntry->value;
	Load_XString(false);

	DB_PopStreamPos();
}

void Load_LocalizeEntryArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLocalizeEntry, sizeof(LocalizeEntry) * count);
	LocalizeEntry* pointer = varLocalizeEntry;
	for (int i = 0; i < count; i++)
	{
		varLocalizeEntry = pointer;
		Load_LocalizeEntry(false);
		pointer++;
	}
}

void Load_LocalizeEntryAsset(LocalizeEntry** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_LOCALIZE_ENTRY, (void**)varLocalizeEntryPtr);
}

void Load_LocalizeEntryPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varLocalizeEntry, sizeof(LocalizeEntry*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	LocalizeEntry* pointer = *varLocalizeEntryPtr;
	if (*varLocalizeEntryPtr != nullptr)
	{
		if (*varLocalizeEntryPtr == (LocalizeEntry*)0xFFFFFFFF || *varLocalizeEntryPtr == (LocalizeEntry*)0xFFFFFFFE)
		{
			*varLocalizeEntryPtr = AllocLoad_LocalizeEntry();
			varLocalizeEntry = *varLocalizeEntryPtr;
			LocalizeEntry** insertedPointer = nullptr;
			if (pointer == (LocalizeEntry*)0xFFFFFFFE)
			{
				insertedPointer = (LocalizeEntry**)DB_InsertPointer();
			}
			Load_LocalizeEntry(true);
			Load_LocalizeEntryAsset(varLocalizeEntryPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varLocalizeEntryPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varLocalizeEntryPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_LocalizeEntryPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varLocalizeEntryPtr, sizeof(LocalizeEntry*) * count);
	LocalizeEntry** pointer = varLocalizeEntryPtr;
	for (int i = 0; i < count; i++)
	{
		varLocalizeEntryPtr = pointer;
		Load_LocalizeEntryPtr(false);
		pointer++;
	}
}

void Load_MSSChannelMap(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMSSChannelMap, sizeof(MSSChannelMap));

	varMSSSpeakerLevels = varMSSChannelMap->speakers;
	Load_MSSSpeakerLevelsArray(true, varMSSChannelMap->speakerCount);

}

void Load_MSSChannelMapArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMSSChannelMap, sizeof(MSSChannelMap) * count);
	MSSChannelMap* pointer = varMSSChannelMap;
	for (int i = 0; i < count; i++)
	{
		varMSSChannelMap = pointer;
		Load_MSSChannelMap(false);
		pointer++;
	}
}

void Load_MSSChannelMapPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMSSChannelMap, sizeof(MSSChannelMap));
	if (*varMSSChannelMapPtr != nullptr)
	{
		if (*varMSSChannelMapPtr == (MSSChannelMap*)0xFFFFFFFF)
		{
			*varMSSChannelMapPtr = AllocLoad_MSSChannelMap();
			varMSSChannelMap = *varMSSChannelMapPtr;
			Load_MSSChannelMap(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMSSChannelMapPtr);
		}
	}
}

void Load_MSSChannelMapPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMSSChannelMapPtr, sizeof(MSSChannelMap*) * count);
	MSSChannelMap** pointer = varMSSChannelMapPtr;
	for (int i = 0; i < count; i++)
	{
		varMSSChannelMapPtr = pointer;
		Load_MSSChannelMapPtr(false);
		pointer++;
	}
}

void Load_MSSSpeakerLevels(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMSSSpeakerLevels, sizeof(MSSSpeakerLevels));

	varfloat = varMSSSpeakerLevels->levels;
	Load_floatArray(true, varMSSSpeakerLevels->numLevels);

}

void Load_MSSSpeakerLevelsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMSSSpeakerLevels, sizeof(MSSSpeakerLevels) * count);
	MSSSpeakerLevels* pointer = varMSSSpeakerLevels;
	for (int i = 0; i < count; i++)
	{
		varMSSSpeakerLevels = pointer;
		Load_MSSSpeakerLevels(false);
		pointer++;
	}
}

void Load_MSSSpeakerLevelsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMSSSpeakerLevels, sizeof(MSSSpeakerLevels));
	if (*varMSSSpeakerLevelsPtr != nullptr)
	{
		if (*varMSSSpeakerLevelsPtr == (MSSSpeakerLevels*)0xFFFFFFFF)
		{
			*varMSSSpeakerLevelsPtr = AllocLoad_MSSSpeakerLevels();
			varMSSSpeakerLevels = *varMSSSpeakerLevelsPtr;
			Load_MSSSpeakerLevels(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMSSSpeakerLevelsPtr);
		}
	}
}

void Load_MSSSpeakerLevelsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMSSSpeakerLevelsPtr, sizeof(MSSSpeakerLevels*) * count);
	MSSSpeakerLevels** pointer = varMSSSpeakerLevelsPtr;
	for (int i = 0; i < count; i++)
	{
		varMSSSpeakerLevelsPtr = pointer;
		Load_MSSSpeakerLevelsPtr(false);
		pointer++;
	}
}

void Load_MapEnts(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMapEnts, sizeof(MapEnts));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varMapEnts->name;
	Load_XString(false);

	if (varMapEnts->entityString)
	{
		if (varMapEnts->entityString == (char*)0xFFFFFFFF)
		{
			varMapEnts->entityString = AllocLoad_char();
			varchar = varMapEnts->entityString;
			Load_charArray(true, (varMapEnts->numEntityChars));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMapEnts->entityString);
		}
	}

	varMapTriggers = &varMapEnts->trigger;
	Load_MapTriggers(false);

	if (varMapEnts->stages)
	{
		if (varMapEnts->stages == (Stage*)0xFFFFFFFF)
		{
			varMapEnts->stages = AllocLoad_Stage();
			varStage = varMapEnts->stages;
			Load_StageArray(true, (varMapEnts->stageCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMapEnts->stages);
		}
	}

	DB_PopStreamPos();
}

void Load_MapEntsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMapEnts, sizeof(MapEnts) * count);
	MapEnts* pointer = varMapEnts;
	for (int i = 0; i < count; i++)
	{
		varMapEnts = pointer;
		Load_MapEnts(false);
		pointer++;
	}
}

void Load_MapEntsAsset(MapEnts** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_MAP_ENTS, (void**)varMapEntsPtr);
}

void Load_MapEntsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMapEnts, sizeof(MapEnts*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	MapEnts* pointer = *varMapEntsPtr;
	if (*varMapEntsPtr != nullptr)
	{
		if (*varMapEntsPtr == (MapEnts*)0xFFFFFFFF || *varMapEntsPtr == (MapEnts*)0xFFFFFFFE)
		{
			*varMapEntsPtr = AllocLoad_MapEnts();
			varMapEnts = *varMapEntsPtr;
			MapEnts** insertedPointer = nullptr;
			if (pointer == (MapEnts*)0xFFFFFFFE)
			{
				insertedPointer = (MapEnts**)DB_InsertPointer();
			}
			Load_MapEnts(true);
			Load_MapEntsAsset(varMapEntsPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMapEntsPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMapEntsPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MapEntsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMapEntsPtr, sizeof(MapEnts*) * count);
	MapEnts** pointer = varMapEntsPtr;
	for (int i = 0; i < count; i++)
	{
		varMapEntsPtr = pointer;
		Load_MapEntsPtr(false);
		pointer++;
	}
}

void Load_MapTriggers(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMapTriggers, sizeof(MapTriggers));

	if (varMapTriggers->models)
	{
		if (varMapTriggers->models == (TriggerModel*)0xFFFFFFFF)
		{
			varMapTriggers->models = AllocLoad_TriggerModel();
			varTriggerModel = varMapTriggers->models;
			Load_TriggerModelArray(true, (varMapTriggers->count));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMapTriggers->models);
		}
	}

	if (varMapTriggers->hulls)
	{
		if (varMapTriggers->hulls == (TriggerHull*)0xFFFFFFFF)
		{
			varMapTriggers->hulls = AllocLoad_TriggerHull();
			varTriggerHull = varMapTriggers->hulls;
			Load_TriggerHullArray(true, (varMapTriggers->hullCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMapTriggers->hulls);
		}
	}

	if (varMapTriggers->slabs)
	{
		if (varMapTriggers->slabs == (TriggerSlab*)0xFFFFFFFF)
		{
			varMapTriggers->slabs = AllocLoad_TriggerSlab();
			varTriggerSlab = varMapTriggers->slabs;
			Load_TriggerSlabArray(true, (varMapTriggers->slabCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMapTriggers->slabs);
		}
	}

}

void Load_MapTriggersArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMapTriggers, sizeof(MapTriggers) * count);
	MapTriggers* pointer = varMapTriggers;
	for (int i = 0; i < count; i++)
	{
		varMapTriggers = pointer;
		Load_MapTriggers(false);
		pointer++;
	}
}

void Load_MapTriggersPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMapTriggers, sizeof(MapTriggers));
	if (*varMapTriggersPtr != nullptr)
	{
		if (*varMapTriggersPtr == (MapTriggers*)0xFFFFFFFF)
		{
			*varMapTriggersPtr = AllocLoad_MapTriggers();
			varMapTriggers = *varMapTriggersPtr;
			Load_MapTriggers(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMapTriggersPtr);
		}
	}
}

void Load_MapTriggersPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMapTriggersPtr, sizeof(MapTriggers*) * count);
	MapTriggers** pointer = varMapTriggersPtr;
	for (int i = 0; i < count; i++)
	{
		varMapTriggersPtr = pointer;
		Load_MapTriggersPtr(false);
		pointer++;
	}
}

void Load_Material(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterial, sizeof(Material));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varMaterialInfo = &varMaterial->info;
	Load_MaterialInfo(false);

	varMaterialTechniqueSetPtr = &varMaterial->techniqueSet;
	Load_MaterialTechniqueSetPtr(false);

	if (varMaterial->textureTable)
	{
		if (varMaterial->textureTable == (MaterialTextureDef*)0xFFFFFFFF)
		{
			varMaterial->textureTable = AllocLoad_MaterialTextureDef();
			varMaterialTextureDef = varMaterial->textureTable;
			Load_MaterialTextureDefArray(true, (varMaterial->textureCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMaterial->textureTable);
		}
	}

	if (varMaterial->constantTable)
	{
		if (varMaterial->constantTable == (MaterialConstantDef*)0xFFFFFFFF)
		{
			varMaterial->constantTable = AllocLoad_MaterialConstantDef();
			varMaterialConstantDef = varMaterial->constantTable;
			Load_MaterialConstantDefArray(true, (varMaterial->constantCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMaterial->constantTable);
		}
	}

	if (varMaterial->stateBitsTable)
	{
		if (varMaterial->stateBitsTable == (GfxStateBits*)0xFFFFFFFF)
		{
			varMaterial->stateBitsTable = AllocLoad_GfxStateBits();
			varGfxStateBits = varMaterial->stateBitsTable;
			Load_GfxStateBitsArray(true, (varMaterial->stateBitsCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMaterial->stateBitsTable);
		}
	}

	DB_PopStreamPos();
}

void Load_MaterialArgumentCodeConst(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialArgumentCodeConst, sizeof(MaterialArgumentCodeConst));

}

void Load_MaterialArgumentCodeConstArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialArgumentCodeConst, sizeof(MaterialArgumentCodeConst) * count);
	MaterialArgumentCodeConst* pointer = varMaterialArgumentCodeConst;
	for (int i = 0; i < count; i++)
	{
		varMaterialArgumentCodeConst = pointer;
		Load_MaterialArgumentCodeConst(false);
		pointer++;
	}
}

void Load_MaterialArgumentCodeConstPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialArgumentCodeConst, sizeof(MaterialArgumentCodeConst));
	if (*varMaterialArgumentCodeConstPtr != nullptr)
	{
		if (*varMaterialArgumentCodeConstPtr == (MaterialArgumentCodeConst*)0xFFFFFFFF)
		{
			*varMaterialArgumentCodeConstPtr = AllocLoad_MaterialArgumentCodeConst();
			varMaterialArgumentCodeConst = *varMaterialArgumentCodeConstPtr;
			Load_MaterialArgumentCodeConst(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialArgumentCodeConstPtr);
		}
	}
}

void Load_MaterialArgumentCodeConstPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialArgumentCodeConstPtr, sizeof(MaterialArgumentCodeConst*) * count);
	MaterialArgumentCodeConst** pointer = varMaterialArgumentCodeConstPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialArgumentCodeConstPtr = pointer;
		Load_MaterialArgumentCodeConstPtr(false);
		pointer++;
	}
}

void Load_MaterialArgumentDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialArgumentDef, sizeof(MaterialArgumentDef));

	switch (varMaterialShaderArgument->type)
	{
	case 1:
	case 7:
		varfloat = varMaterialArgumentDef->literalConst;
		Load_floatArray(true, (4));
		break;
	}
}

void Load_MaterialArgumentDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialArgumentDef, sizeof(MaterialArgumentDef) * count);
	MaterialArgumentDef* pointer = varMaterialArgumentDef;
	for (int i = 0; i < count; i++)
	{
		varMaterialArgumentDef = pointer;
		Load_MaterialArgumentDef(false);
		pointer++;
	}
}

void Load_MaterialArgumentDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialArgumentDef, sizeof(MaterialArgumentDef));
	if (*varMaterialArgumentDefPtr != nullptr)
	{
		if (*varMaterialArgumentDefPtr == (MaterialArgumentDef*)0xFFFFFFFF)
		{
			*varMaterialArgumentDefPtr = AllocLoad_MaterialArgumentDef();
			varMaterialArgumentDef = *varMaterialArgumentDefPtr;
			Load_MaterialArgumentDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialArgumentDefPtr);
		}
	}
}

void Load_MaterialArgumentDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialArgumentDefPtr, sizeof(MaterialArgumentDef*) * count);
	MaterialArgumentDef** pointer = varMaterialArgumentDefPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialArgumentDefPtr = pointer;
		Load_MaterialArgumentDefPtr(false);
		pointer++;
	}
}

void Load_MaterialArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterial, sizeof(Material) * count);
	Material* pointer = varMaterial;
	for (int i = 0; i < count; i++)
	{
		varMaterial = pointer;
		Load_Material(false);
		pointer++;
	}
}

void Load_MaterialAsset(Material** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_MATERIAL, (void**)varMaterialPtr);
}

void Load_MaterialConstantDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialConstantDef, sizeof(MaterialConstantDef));

}

void Load_MaterialConstantDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialConstantDef, sizeof(MaterialConstantDef) * count);
	MaterialConstantDef* pointer = varMaterialConstantDef;
	for (int i = 0; i < count; i++)
	{
		varMaterialConstantDef = pointer;
		Load_MaterialConstantDef(false);
		pointer++;
	}
}

void Load_MaterialConstantDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialConstantDef, sizeof(MaterialConstantDef));
	if (*varMaterialConstantDefPtr != nullptr)
	{
		if (*varMaterialConstantDefPtr == (MaterialConstantDef*)0xFFFFFFFF)
		{
			*varMaterialConstantDefPtr = AllocLoad_MaterialConstantDef();
			varMaterialConstantDef = *varMaterialConstantDefPtr;
			Load_MaterialConstantDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialConstantDefPtr);
		}
	}
}

void Load_MaterialConstantDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialConstantDefPtr, sizeof(MaterialConstantDef*) * count);
	MaterialConstantDef** pointer = varMaterialConstantDefPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialConstantDefPtr = pointer;
		Load_MaterialConstantDefPtr(false);
		pointer++;
	}
}

void Load_MaterialInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialInfo, sizeof(MaterialInfo));

	varXString = &varMaterialInfo->name;
	Load_XString(false);

	varGfxDrawSurf = &varMaterialInfo->drawSurf;
	Load_GfxDrawSurf(false);

}

void Load_MaterialInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialInfo, sizeof(MaterialInfo) * count);
	MaterialInfo* pointer = varMaterialInfo;
	for (int i = 0; i < count; i++)
	{
		varMaterialInfo = pointer;
		Load_MaterialInfo(false);
		pointer++;
	}
}

void Load_MaterialInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialInfo, sizeof(MaterialInfo));
	if (*varMaterialInfoPtr != nullptr)
	{
		if (*varMaterialInfoPtr == (MaterialInfo*)0xFFFFFFFF)
		{
			*varMaterialInfoPtr = AllocLoad_MaterialInfo();
			varMaterialInfo = *varMaterialInfoPtr;
			Load_MaterialInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialInfoPtr);
		}
	}
}

void Load_MaterialInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialInfoPtr, sizeof(MaterialInfo*) * count);
	MaterialInfo** pointer = varMaterialInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialInfoPtr = pointer;
		Load_MaterialInfoPtr(false);
		pointer++;
	}
}

void Load_MaterialPass(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialPass, sizeof(MaterialPass));

	varMaterialVertexDeclarationPtr = &varMaterialPass->vertexDecl;
	Load_MaterialVertexDeclarationPtr(false);

	varMaterialVertexShaderPtr = &varMaterialPass->vertexShader;
	Load_MaterialVertexShaderPtr(false);

	varMaterialPixelShaderPtr = &varMaterialPass->pixelShader;
	Load_MaterialPixelShaderPtr(false);

	if (varMaterialPass->args)
	{
		if (varMaterialPass->args == (MaterialShaderArgument*)0xFFFFFFFF)
		{
			varMaterialPass->args = AllocLoad_MaterialShaderArgument();
			varMaterialShaderArgument = varMaterialPass->args;
			Load_MaterialShaderArgumentArray(true, (varMaterialPass->perPrimArgCount + varMaterialPass->perObjArgCount + varMaterialPass->stableArgCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMaterialPass->args);
		}
	}

}

void Load_MaterialPassArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPass, sizeof(MaterialPass) * count);
	MaterialPass* pointer = varMaterialPass;
	for (int i = 0; i < count; i++)
	{
		varMaterialPass = pointer;
		Load_MaterialPass(false);
		pointer++;
	}
}

void Load_MaterialPassPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialPass, sizeof(MaterialPass));
	if (*varMaterialPassPtr != nullptr)
	{
		if (*varMaterialPassPtr == (MaterialPass*)0xFFFFFFFF)
		{
			*varMaterialPassPtr = AllocLoad_MaterialPass();
			varMaterialPass = *varMaterialPassPtr;
			Load_MaterialPass(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialPassPtr);
		}
	}
}

void Load_MaterialPassPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPassPtr, sizeof(MaterialPass*) * count);
	MaterialPass** pointer = varMaterialPassPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialPassPtr = pointer;
		Load_MaterialPassPtr(false);
		pointer++;
	}
}

void Load_MaterialPixelShader(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialPixelShader, sizeof(MaterialPixelShader));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varMaterialPixelShader->name;
	Load_XString(false);

	varMaterialPixelShaderProgram = &varMaterialPixelShader->prog;
	Load_MaterialPixelShaderProgram(false);

	DB_PopStreamPos();
}

void Load_MaterialPixelShaderArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPixelShader, sizeof(MaterialPixelShader) * count);
	MaterialPixelShader* pointer = varMaterialPixelShader;
	for (int i = 0; i < count; i++)
	{
		varMaterialPixelShader = pointer;
		Load_MaterialPixelShader(false);
		pointer++;
	}
}

void Load_MaterialPixelShaderAsset(MaterialPixelShader** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_PIXELSHADER, (void**)varMaterialPixelShaderPtr);
}

void Load_MaterialPixelShaderProgram(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialPixelShaderProgram, sizeof(MaterialPixelShaderProgram));

	varGfxPixelShaderLoadDef = &varMaterialPixelShaderProgram->loadDef;
	Load_GfxPixelShaderLoadDef(false);

}

void Load_MaterialPixelShaderProgramArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPixelShaderProgram, sizeof(MaterialPixelShaderProgram) * count);
	MaterialPixelShaderProgram* pointer = varMaterialPixelShaderProgram;
	for (int i = 0; i < count; i++)
	{
		varMaterialPixelShaderProgram = pointer;
		Load_MaterialPixelShaderProgram(false);
		pointer++;
	}
}

void Load_MaterialPixelShaderProgramPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialPixelShaderProgram, sizeof(MaterialPixelShaderProgram));
	if (*varMaterialPixelShaderProgramPtr != nullptr)
	{
		if (*varMaterialPixelShaderProgramPtr == (MaterialPixelShaderProgram*)0xFFFFFFFF)
		{
			*varMaterialPixelShaderProgramPtr = AllocLoad_MaterialPixelShaderProgram();
			varMaterialPixelShaderProgram = *varMaterialPixelShaderProgramPtr;
			Load_MaterialPixelShaderProgram(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialPixelShaderProgramPtr);
		}
	}
}

void Load_MaterialPixelShaderProgramPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPixelShaderProgramPtr, sizeof(MaterialPixelShaderProgram*) * count);
	MaterialPixelShaderProgram** pointer = varMaterialPixelShaderProgramPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialPixelShaderProgramPtr = pointer;
		Load_MaterialPixelShaderProgramPtr(false);
		pointer++;
	}
}

void Load_MaterialPixelShaderPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialPixelShader, sizeof(MaterialPixelShader*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	MaterialPixelShader* pointer = *varMaterialPixelShaderPtr;
	if (*varMaterialPixelShaderPtr != nullptr)
	{
		if (*varMaterialPixelShaderPtr == (MaterialPixelShader*)0xFFFFFFFF || *varMaterialPixelShaderPtr == (MaterialPixelShader*)0xFFFFFFFE)
		{
			*varMaterialPixelShaderPtr = AllocLoad_MaterialPixelShader();
			varMaterialPixelShader = *varMaterialPixelShaderPtr;
			MaterialPixelShader** insertedPointer = nullptr;
			if (pointer == (MaterialPixelShader*)0xFFFFFFFE)
			{
				insertedPointer = (MaterialPixelShader**)DB_InsertPointer();
			}
			Load_MaterialPixelShader(true);
			Load_MaterialPixelShaderAsset(varMaterialPixelShaderPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMaterialPixelShaderPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMaterialPixelShaderPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MaterialPixelShaderPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPixelShaderPtr, sizeof(MaterialPixelShader*) * count);
	MaterialPixelShader** pointer = varMaterialPixelShaderPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialPixelShaderPtr = pointer;
		Load_MaterialPixelShaderPtr(false);
		pointer++;
	}
}

void Load_MaterialPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterial, sizeof(Material*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	Material* pointer = *varMaterialPtr;
	if (*varMaterialPtr != nullptr)
	{
		if (*varMaterialPtr == (Material*)0xFFFFFFFF || *varMaterialPtr == (Material*)0xFFFFFFFE)
		{
			*varMaterialPtr = AllocLoad_Material();
			varMaterial = *varMaterialPtr;
			Material** insertedPointer = nullptr;
			if (pointer == (Material*)0xFFFFFFFE)
			{
				insertedPointer = (Material**)DB_InsertPointer();
			}
			Load_Material(true);
			Load_MaterialAsset(varMaterialPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMaterialPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMaterialPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MaterialPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialPtr, sizeof(Material*) * count);
	Material** pointer = varMaterialPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialPtr = pointer;
		Load_MaterialPtr(false);
		pointer++;
	}
}

void Load_MaterialShaderArgument(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialShaderArgument, sizeof(MaterialShaderArgument));

	varMaterialArgumentDef = &varMaterialShaderArgument->u;
	Load_MaterialArgumentDef(false);

}

void Load_MaterialShaderArgumentArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialShaderArgument, sizeof(MaterialShaderArgument) * count);
	MaterialShaderArgument* pointer = varMaterialShaderArgument;
	for (int i = 0; i < count; i++)
	{
		varMaterialShaderArgument = pointer;
		Load_MaterialShaderArgument(false);
		pointer++;
	}
}

void Load_MaterialShaderArgumentPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialShaderArgument, sizeof(MaterialShaderArgument));
	if (*varMaterialShaderArgumentPtr != nullptr)
	{
		if (*varMaterialShaderArgumentPtr == (MaterialShaderArgument*)0xFFFFFFFF)
		{
			*varMaterialShaderArgumentPtr = AllocLoad_MaterialShaderArgument();
			varMaterialShaderArgument = *varMaterialShaderArgumentPtr;
			Load_MaterialShaderArgument(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialShaderArgumentPtr);
		}
	}
}

void Load_MaterialShaderArgumentPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialShaderArgumentPtr, sizeof(MaterialShaderArgument*) * count);
	MaterialShaderArgument** pointer = varMaterialShaderArgumentPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialShaderArgumentPtr = pointer;
		Load_MaterialShaderArgumentPtr(false);
		pointer++;
	}
}

void Load_MaterialStreamRouting(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialStreamRouting, sizeof(MaterialStreamRouting));

}

void Load_MaterialStreamRoutingArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialStreamRouting, sizeof(MaterialStreamRouting) * count);
	MaterialStreamRouting* pointer = varMaterialStreamRouting;
	for (int i = 0; i < count; i++)
	{
		varMaterialStreamRouting = pointer;
		Load_MaterialStreamRouting(false);
		pointer++;
	}
}

void Load_MaterialStreamRoutingPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialStreamRouting, sizeof(MaterialStreamRouting));
	if (*varMaterialStreamRoutingPtr != nullptr)
	{
		if (*varMaterialStreamRoutingPtr == (MaterialStreamRouting*)0xFFFFFFFF)
		{
			*varMaterialStreamRoutingPtr = AllocLoad_MaterialStreamRouting();
			varMaterialStreamRouting = *varMaterialStreamRoutingPtr;
			Load_MaterialStreamRouting(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialStreamRoutingPtr);
		}
	}
}

void Load_MaterialStreamRoutingPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialStreamRoutingPtr, sizeof(MaterialStreamRouting*) * count);
	MaterialStreamRouting** pointer = varMaterialStreamRoutingPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialStreamRoutingPtr = pointer;
		Load_MaterialStreamRoutingPtr(false);
		pointer++;
	}
}

void Load_MaterialTechnique(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTechnique, (sizeof(MaterialTechnique) - sizeof(MaterialPass)));

	varMaterialPass = varMaterialTechnique->passArray;
	Load_MaterialPassArray(true, varMaterialTechnique->passCount);

	varXString = &varMaterialTechnique->name;
	Load_XString(false);

}

void Load_MaterialTechniqueArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTechnique, sizeof(MaterialTechnique) * count);
	MaterialTechnique* pointer = varMaterialTechnique;
	for (int i = 0; i < count; i++)
	{
		varMaterialTechnique = pointer;
		Load_MaterialTechnique(false);
		pointer++;
	}
}

void Load_MaterialTechniquePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTechnique, sizeof(MaterialTechnique));
	if (*varMaterialTechniquePtr != nullptr)
	{
		if (*varMaterialTechniquePtr == (MaterialTechnique*)0xFFFFFFFF)
		{
			*varMaterialTechniquePtr = AllocLoad_MaterialTechnique();
			varMaterialTechnique = *varMaterialTechniquePtr;
			Load_MaterialTechnique(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialTechniquePtr);
		}
	}
}

void Load_MaterialTechniquePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTechniquePtr, sizeof(MaterialTechnique*) * count);
	MaterialTechnique** pointer = varMaterialTechniquePtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialTechniquePtr = pointer;
		Load_MaterialTechniquePtr(false);
		pointer++;
	}
}

void Load_MaterialTechniqueSet(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTechniqueSet, sizeof(MaterialTechniqueSet));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varMaterialTechniqueSet->name;
	Load_XString(false);

	if (varMaterialTechniqueSet->techniques)
	{
		varMaterialTechniquePtr = varMaterialTechniqueSet->techniques;
		Load_MaterialTechniquePtrArray(false, 48);
	}

	DB_PopStreamPos();
}

void Load_MaterialTechniqueSetArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTechniqueSet, sizeof(MaterialTechniqueSet) * count);
	MaterialTechniqueSet* pointer = varMaterialTechniqueSet;
	for (int i = 0; i < count; i++)
	{
		varMaterialTechniqueSet = pointer;
		Load_MaterialTechniqueSet(false);
		pointer++;
	}
}

void Load_MaterialTechniqueSetAsset(MaterialTechniqueSet** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_TECHNIQUE_SET, (void**)varMaterialTechniqueSetPtr);
}

void Load_MaterialTechniqueSetPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTechniqueSet, sizeof(MaterialTechniqueSet*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	MaterialTechniqueSet* pointer = *varMaterialTechniqueSetPtr;
	if (*varMaterialTechniqueSetPtr != nullptr)
	{
		if (*varMaterialTechniqueSetPtr == (MaterialTechniqueSet*)0xFFFFFFFF || *varMaterialTechniqueSetPtr == (MaterialTechniqueSet*)0xFFFFFFFE)
		{
			*varMaterialTechniqueSetPtr = AllocLoad_MaterialTechniqueSet();
			varMaterialTechniqueSet = *varMaterialTechniqueSetPtr;
			MaterialTechniqueSet** insertedPointer = nullptr;
			if (pointer == (MaterialTechniqueSet*)0xFFFFFFFE)
			{
				insertedPointer = (MaterialTechniqueSet**)DB_InsertPointer();
			}
			Load_MaterialTechniqueSet(true);
			Load_MaterialTechniqueSetAsset(varMaterialTechniqueSetPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMaterialTechniqueSetPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMaterialTechniqueSetPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MaterialTechniqueSetPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTechniqueSetPtr, sizeof(MaterialTechniqueSet*) * count);
	MaterialTechniqueSet** pointer = varMaterialTechniqueSetPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialTechniqueSetPtr = pointer;
		Load_MaterialTechniqueSetPtr(false);
		pointer++;
	}
}

void Load_MaterialTextureDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTextureDef, sizeof(MaterialTextureDef));

	varMaterialTextureDefInfo = &varMaterialTextureDef->u;
	Load_MaterialTextureDefInfo(false);

}

void Load_MaterialTextureDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTextureDef, sizeof(MaterialTextureDef) * count);
	MaterialTextureDef* pointer = varMaterialTextureDef;
	for (int i = 0; i < count; i++)
	{
		varMaterialTextureDef = pointer;
		Load_MaterialTextureDef(false);
		pointer++;
	}
}

void Load_MaterialTextureDefInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTextureDefInfo, sizeof(MaterialTextureDefInfo));

	switch (varMaterialTextureDef->semantic)
	{
	case 11:
		varwater_tPtr = &varMaterialTextureDefInfo->water;
		Load_water_tPtr(false);
		break;
	default:
		varGfxImagePtr = &varMaterialTextureDefInfo->image;
		Load_GfxImagePtr(false);
		break;
	}
}

void Load_MaterialTextureDefInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTextureDefInfo, sizeof(MaterialTextureDefInfo) * count);
	MaterialTextureDefInfo* pointer = varMaterialTextureDefInfo;
	for (int i = 0; i < count; i++)
	{
		varMaterialTextureDefInfo = pointer;
		Load_MaterialTextureDefInfo(false);
		pointer++;
	}
}

void Load_MaterialTextureDefInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTextureDefInfo, sizeof(MaterialTextureDefInfo));
	if (*varMaterialTextureDefInfoPtr != nullptr)
	{
		if (*varMaterialTextureDefInfoPtr == (MaterialTextureDefInfo*)0xFFFFFFFF)
		{
			*varMaterialTextureDefInfoPtr = AllocLoad_MaterialTextureDefInfo();
			varMaterialTextureDefInfo = *varMaterialTextureDefInfoPtr;
			Load_MaterialTextureDefInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialTextureDefInfoPtr);
		}
	}
}

void Load_MaterialTextureDefInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTextureDefInfoPtr, sizeof(MaterialTextureDefInfo*) * count);
	MaterialTextureDefInfo** pointer = varMaterialTextureDefInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialTextureDefInfoPtr = pointer;
		Load_MaterialTextureDefInfoPtr(false);
		pointer++;
	}
}

void Load_MaterialTextureDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialTextureDef, sizeof(MaterialTextureDef));
	if (*varMaterialTextureDefPtr != nullptr)
	{
		if (*varMaterialTextureDefPtr == (MaterialTextureDef*)0xFFFFFFFF)
		{
			*varMaterialTextureDefPtr = AllocLoad_MaterialTextureDef();
			varMaterialTextureDef = *varMaterialTextureDefPtr;
			Load_MaterialTextureDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialTextureDefPtr);
		}
	}
}

void Load_MaterialTextureDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialTextureDefPtr, sizeof(MaterialTextureDef*) * count);
	MaterialTextureDef** pointer = varMaterialTextureDefPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialTextureDefPtr = pointer;
		Load_MaterialTextureDefPtr(false);
		pointer++;
	}
}

void Load_MaterialVertexDeclaration(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexDeclaration, sizeof(MaterialVertexDeclaration));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varMaterialVertexDeclaration->name;
	Load_XString(false);

	varMaterialVertexStreamRouting = &varMaterialVertexDeclaration->routing;
	Load_MaterialVertexStreamRouting(false);

	DB_PopStreamPos();
}

void Load_MaterialVertexDeclarationArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexDeclaration, sizeof(MaterialVertexDeclaration) * count);
	MaterialVertexDeclaration* pointer = varMaterialVertexDeclaration;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexDeclaration = pointer;
		Load_MaterialVertexDeclaration(false);
		pointer++;
	}
}

void Load_MaterialVertexDeclarationAsset(MaterialVertexDeclaration** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_VERTEXDECL, (void**)varMaterialVertexDeclarationPtr);
}

void Load_MaterialVertexDeclarationPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexDeclaration, sizeof(MaterialVertexDeclaration*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	MaterialVertexDeclaration* pointer = *varMaterialVertexDeclarationPtr;
	if (*varMaterialVertexDeclarationPtr != nullptr)
	{
		if (*varMaterialVertexDeclarationPtr == (MaterialVertexDeclaration*)0xFFFFFFFF || *varMaterialVertexDeclarationPtr == (MaterialVertexDeclaration*)0xFFFFFFFE)
		{
			*varMaterialVertexDeclarationPtr = AllocLoad_MaterialVertexDeclaration();
			varMaterialVertexDeclaration = *varMaterialVertexDeclarationPtr;
			MaterialVertexDeclaration** insertedPointer = nullptr;
			if (pointer == (MaterialVertexDeclaration*)0xFFFFFFFE)
			{
				insertedPointer = (MaterialVertexDeclaration**)DB_InsertPointer();
			}
			Load_MaterialVertexDeclaration(true);
			Load_MaterialVertexDeclarationAsset(varMaterialVertexDeclarationPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMaterialVertexDeclarationPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMaterialVertexDeclarationPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MaterialVertexDeclarationPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexDeclarationPtr, sizeof(MaterialVertexDeclaration*) * count);
	MaterialVertexDeclaration** pointer = varMaterialVertexDeclarationPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexDeclarationPtr = pointer;
		Load_MaterialVertexDeclarationPtr(false);
		pointer++;
	}
}

void Load_MaterialVertexShader(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexShader, sizeof(MaterialVertexShader));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varMaterialVertexShader->name;
	Load_XString(false);

	varMaterialVertexShaderProgram = &varMaterialVertexShader->prog;
	Load_MaterialVertexShaderProgram(false);

	DB_PopStreamPos();
}

void Load_MaterialVertexShaderArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexShader, sizeof(MaterialVertexShader) * count);
	MaterialVertexShader* pointer = varMaterialVertexShader;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexShader = pointer;
		Load_MaterialVertexShader(false);
		pointer++;
	}
}

void Load_MaterialVertexShaderAsset(MaterialVertexShader** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_VERTEXSHADER, (void**)varMaterialVertexShaderPtr);
}

void Load_MaterialVertexShaderProgram(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexShaderProgram, sizeof(MaterialVertexShaderProgram));

	varGfxVertexShaderLoadDef = &varMaterialVertexShaderProgram->loadDef;
	Load_GfxVertexShaderLoadDef(false);

}

void Load_MaterialVertexShaderProgramArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexShaderProgram, sizeof(MaterialVertexShaderProgram) * count);
	MaterialVertexShaderProgram* pointer = varMaterialVertexShaderProgram;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexShaderProgram = pointer;
		Load_MaterialVertexShaderProgram(false);
		pointer++;
	}
}

void Load_MaterialVertexShaderProgramPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexShaderProgram, sizeof(MaterialVertexShaderProgram));
	if (*varMaterialVertexShaderProgramPtr != nullptr)
	{
		if (*varMaterialVertexShaderProgramPtr == (MaterialVertexShaderProgram*)0xFFFFFFFF)
		{
			*varMaterialVertexShaderProgramPtr = AllocLoad_MaterialVertexShaderProgram();
			varMaterialVertexShaderProgram = *varMaterialVertexShaderProgramPtr;
			Load_MaterialVertexShaderProgram(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialVertexShaderProgramPtr);
		}
	}
}

void Load_MaterialVertexShaderProgramPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexShaderProgramPtr, sizeof(MaterialVertexShaderProgram*) * count);
	MaterialVertexShaderProgram** pointer = varMaterialVertexShaderProgramPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexShaderProgramPtr = pointer;
		Load_MaterialVertexShaderProgramPtr(false);
		pointer++;
	}
}

void Load_MaterialVertexShaderPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexShader, sizeof(MaterialVertexShader*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	MaterialVertexShader* pointer = *varMaterialVertexShaderPtr;
	if (*varMaterialVertexShaderPtr != nullptr)
	{
		if (*varMaterialVertexShaderPtr == (MaterialVertexShader*)0xFFFFFFFF || *varMaterialVertexShaderPtr == (MaterialVertexShader*)0xFFFFFFFE)
		{
			*varMaterialVertexShaderPtr = AllocLoad_MaterialVertexShader();
			varMaterialVertexShader = *varMaterialVertexShaderPtr;
			MaterialVertexShader** insertedPointer = nullptr;
			if (pointer == (MaterialVertexShader*)0xFFFFFFFE)
			{
				insertedPointer = (MaterialVertexShader**)DB_InsertPointer();
			}
			Load_MaterialVertexShader(true);
			Load_MaterialVertexShaderAsset(varMaterialVertexShaderPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMaterialVertexShaderPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMaterialVertexShaderPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MaterialVertexShaderPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexShaderPtr, sizeof(MaterialVertexShader*) * count);
	MaterialVertexShader** pointer = varMaterialVertexShaderPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexShaderPtr = pointer;
		Load_MaterialVertexShaderPtr(false);
		pointer++;
	}
}

void Load_MaterialVertexStreamRouting(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexStreamRouting, sizeof(MaterialVertexStreamRouting));

	varMaterialStreamRouting = varMaterialVertexStreamRouting->data;
	Load_MaterialStreamRoutingArray(false, 13);

}

void Load_MaterialVertexStreamRoutingArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexStreamRouting, sizeof(MaterialVertexStreamRouting) * count);
	MaterialVertexStreamRouting* pointer = varMaterialVertexStreamRouting;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexStreamRouting = pointer;
		Load_MaterialVertexStreamRouting(false);
		pointer++;
	}
}

void Load_MaterialVertexStreamRoutingPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMaterialVertexStreamRouting, sizeof(MaterialVertexStreamRouting));
	if (*varMaterialVertexStreamRoutingPtr != nullptr)
	{
		if (*varMaterialVertexStreamRoutingPtr == (MaterialVertexStreamRouting*)0xFFFFFFFF)
		{
			*varMaterialVertexStreamRoutingPtr = AllocLoad_MaterialVertexStreamRouting();
			varMaterialVertexStreamRouting = *varMaterialVertexStreamRoutingPtr;
			Load_MaterialVertexStreamRouting(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMaterialVertexStreamRoutingPtr);
		}
	}
}

void Load_MaterialVertexStreamRoutingPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMaterialVertexStreamRoutingPtr, sizeof(MaterialVertexStreamRouting*) * count);
	MaterialVertexStreamRouting** pointer = varMaterialVertexStreamRoutingPtr;
	for (int i = 0; i < count; i++)
	{
		varMaterialVertexStreamRoutingPtr = pointer;
		Load_MaterialVertexStreamRoutingPtr(false);
		pointer++;
	}
}

void Load_MenuEventHandler(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMenuEventHandler, sizeof(MenuEventHandler));

	varEventData = &varMenuEventHandler->eventData;
	Load_EventData(false);

}

void Load_MenuEventHandlerArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMenuEventHandler, sizeof(MenuEventHandler) * count);
	MenuEventHandler* pointer = varMenuEventHandler;
	for (int i = 0; i < count; i++)
	{
		varMenuEventHandler = pointer;
		Load_MenuEventHandler(false);
		pointer++;
	}
}

void Load_MenuEventHandlerPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMenuEventHandler, sizeof(MenuEventHandler));
	if (*varMenuEventHandlerPtr != nullptr)
	{
		if (*varMenuEventHandlerPtr == (MenuEventHandler*)0xFFFFFFFF)
		{
			*varMenuEventHandlerPtr = AllocLoad_MenuEventHandler();
			varMenuEventHandler = *varMenuEventHandlerPtr;
			Load_MenuEventHandler(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMenuEventHandlerPtr);
		}
	}
}

void Load_MenuEventHandlerPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMenuEventHandlerPtr, sizeof(MenuEventHandler*) * count);
	MenuEventHandler** pointer = varMenuEventHandlerPtr;
	for (int i = 0; i < count; i++)
	{
		varMenuEventHandlerPtr = pointer;
		Load_MenuEventHandlerPtr(false);
		pointer++;
	}
}

void Load_MenuEventHandlerSet(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMenuEventHandlerSet, sizeof(MenuEventHandlerSet));

	if (varMenuEventHandlerSet->eventHandlers)
	{
		if (varMenuEventHandlerSet->eventHandlers == (MenuEventHandler**)0xFFFFFFFF)
		{
			varMenuEventHandlerSet->eventHandlers = AllocLoad_MenuEventHandlerPtr();
			varMenuEventHandlerPtr = varMenuEventHandlerSet->eventHandlers;
			Load_MenuEventHandlerPtrArray(true, (varMenuEventHandlerSet->eventHandlerCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMenuEventHandlerSet->eventHandlers);
		}
	}

}

void Load_MenuEventHandlerSetArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMenuEventHandlerSet, sizeof(MenuEventHandlerSet) * count);
	MenuEventHandlerSet* pointer = varMenuEventHandlerSet;
	for (int i = 0; i < count; i++)
	{
		varMenuEventHandlerSet = pointer;
		Load_MenuEventHandlerSet(false);
		pointer++;
	}
}

void Load_MenuEventHandlerSetPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMenuEventHandlerSet, sizeof(MenuEventHandlerSet));
	if (*varMenuEventHandlerSetPtr != nullptr)
	{
		if (*varMenuEventHandlerSetPtr == (MenuEventHandlerSet*)0xFFFFFFFF)
		{
			*varMenuEventHandlerSetPtr = AllocLoad_MenuEventHandlerSet();
			varMenuEventHandlerSet = *varMenuEventHandlerSetPtr;
			Load_MenuEventHandlerSet(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMenuEventHandlerSetPtr);
		}
	}
}

void Load_MenuEventHandlerSetPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMenuEventHandlerSetPtr, sizeof(MenuEventHandlerSet*) * count);
	MenuEventHandlerSet** pointer = varMenuEventHandlerSetPtr;
	for (int i = 0; i < count; i++)
	{
		varMenuEventHandlerSetPtr = pointer;
		Load_MenuEventHandlerSetPtr(false);
		pointer++;
	}
}

void Load_MenuList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMenuList, sizeof(MenuList));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varMenuList->name;
	Load_XString(false);

	if (varMenuList->menus)
	{
		if (varMenuList->menus == (menuDef_t**)0xFFFFFFFF)
		{
			varMenuList->menus = AllocLoad_menuDef_tPtr();
			varmenuDef_tPtr = varMenuList->menus;
			Load_menuDef_tPtrArray(true, (varMenuList->menuCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMenuList->menus);
		}
	}

	DB_PopStreamPos();
}

void Load_MenuListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMenuList, sizeof(MenuList) * count);
	MenuList* pointer = varMenuList;
	for (int i = 0; i < count; i++)
	{
		varMenuList = pointer;
		Load_MenuList(false);
		pointer++;
	}
}

void Load_MenuListAsset(MenuList** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_MENULIST, (void**)varMenuListPtr);
}

void Load_MenuListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMenuList, sizeof(MenuList*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	MenuList* pointer = *varMenuListPtr;
	if (*varMenuListPtr != nullptr)
	{
		if (*varMenuListPtr == (MenuList*)0xFFFFFFFF || *varMenuListPtr == (MenuList*)0xFFFFFFFE)
		{
			*varMenuListPtr = AllocLoad_MenuList();
			varMenuList = *varMenuListPtr;
			MenuList** insertedPointer = nullptr;
			if (pointer == (MenuList*)0xFFFFFFFE)
			{
				insertedPointer = (MenuList**)DB_InsertPointer();
			}
			Load_MenuList(true);
			Load_MenuListAsset(varMenuListPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varMenuListPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varMenuListPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_MenuListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMenuListPtr, sizeof(MenuList*) * count);
	MenuList** pointer = varMenuListPtr;
	for (int i = 0; i < count; i++)
	{
		varMenuListPtr = pointer;
		Load_MenuListPtr(false);
		pointer++;
	}
}

void Load_MssSound(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMssSound, sizeof(MssSound));

	var_AILSOUNDINFO = &varMssSound->info;
	Load__AILSOUNDINFO(false);

	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	if (varMssSound->data)
	{
		if (varMssSound->data == (char*)0xFFFFFFFF)
		{
			varMssSound->data = AllocLoad_char();
			varchar = varMssSound->data;
			Load_charArray(true, (varMssSound->info.data_len));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varMssSound->data);
		}
	}
	DB_PopStreamPos();

}

void Load_MssSoundArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMssSound, sizeof(MssSound) * count);
	MssSound* pointer = varMssSound;
	for (int i = 0; i < count; i++)
	{
		varMssSound = pointer;
		Load_MssSound(false);
		pointer++;
	}
}

void Load_MssSoundPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varMssSound, sizeof(MssSound));
	if (*varMssSoundPtr != nullptr)
	{
		if (*varMssSoundPtr == (MssSound*)0xFFFFFFFF)
		{
			*varMssSoundPtr = AllocLoad_MssSound();
			varMssSound = *varMssSoundPtr;
			Load_MssSound(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varMssSoundPtr);
		}
	}
}

void Load_MssSoundPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varMssSoundPtr, sizeof(MssSound*) * count);
	MssSound** pointer = varMssSoundPtr;
	for (int i = 0; i < count; i++)
	{
		varMssSoundPtr = pointer;
		Load_MssSoundPtr(false);
		pointer++;
	}
}

void Load_Operand(bool atStreamStart)
{
	Load_Stream(atStreamStart, varOperand, sizeof(Operand));

	varoperandInternalDataUnion = &varOperand->internals;
	Load_operandInternalDataUnion(false);

}

void Load_OperandArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varOperand, sizeof(Operand) * count);
	Operand* pointer = varOperand;
	for (int i = 0; i < count; i++)
	{
		varOperand = pointer;
		Load_Operand(false);
		pointer++;
	}
}

void Load_OperandPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varOperand, sizeof(Operand));
	if (*varOperandPtr != nullptr)
	{
		if (*varOperandPtr == (Operand*)0xFFFFFFFF)
		{
			*varOperandPtr = AllocLoad_Operand();
			varOperand = *varOperandPtr;
			Load_Operand(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varOperandPtr);
		}
	}
}

void Load_OperandPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varOperandPtr, sizeof(Operand*) * count);
	Operand** pointer = varOperandPtr;
	for (int i = 0; i < count; i++)
	{
		varOperandPtr = pointer;
		Load_OperandPtr(false);
		pointer++;
	}
}

void Load_PackedTexCoords(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPackedTexCoords, sizeof(PackedTexCoords));

}

void Load_PackedTexCoordsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPackedTexCoords, sizeof(PackedTexCoords) * count);
	PackedTexCoords* pointer = varPackedTexCoords;
	for (int i = 0; i < count; i++)
	{
		varPackedTexCoords = pointer;
		Load_PackedTexCoords(false);
		pointer++;
	}
}

void Load_PackedTexCoordsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPackedTexCoords, sizeof(PackedTexCoords));
	if (*varPackedTexCoordsPtr != nullptr)
	{
		*varPackedTexCoordsPtr = AllocLoad_PackedTexCoords();
		varPackedTexCoords = *varPackedTexCoordsPtr;
		Load_PackedTexCoords(true);
	}
}

void Load_PackedTexCoordsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPackedTexCoordsPtr, sizeof(PackedTexCoords*) * count);
	PackedTexCoords** pointer = varPackedTexCoordsPtr;
	for (int i = 0; i < count; i++)
	{
		varPackedTexCoordsPtr = pointer;
		Load_PackedTexCoordsPtr(false);
		pointer++;
	}
}

void Load_PackedUnitVec(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPackedUnitVec, sizeof(PackedUnitVec));

}

void Load_PackedUnitVecArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPackedUnitVec, sizeof(PackedUnitVec) * count);
	PackedUnitVec* pointer = varPackedUnitVec;
	for (int i = 0; i < count; i++)
	{
		varPackedUnitVec = pointer;
		Load_PackedUnitVec(false);
		pointer++;
	}
}

void Load_PackedUnitVecPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPackedUnitVec, sizeof(PackedUnitVec));
	if (*varPackedUnitVecPtr != nullptr)
	{
		if (*varPackedUnitVecPtr == (PackedUnitVec*)0xFFFFFFFF)
		{
			*varPackedUnitVecPtr = AllocLoad_PackedUnitVec();
			varPackedUnitVec = *varPackedUnitVecPtr;
			Load_PackedUnitVec(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varPackedUnitVecPtr);
		}
	}
}

void Load_PackedUnitVecPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPackedUnitVecPtr, sizeof(PackedUnitVec*) * count);
	PackedUnitVec** pointer = varPackedUnitVecPtr;
	for (int i = 0; i < count; i++)
	{
		varPackedUnitVecPtr = pointer;
		Load_PackedUnitVecPtr(false);
		pointer++;
	}
}

void Load_PhysCollmap(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysCollmap, sizeof(PhysCollmap));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varPhysCollmap->name;
	Load_XString(false);

	if (varPhysCollmap->geoms)
	{
		varPhysGeomInfoPtr = &varPhysCollmap->geoms;
		Load_PhysGeomInfoPtr(false);
	}

	varPhysMass = &varPhysCollmap->mass;
	Load_PhysMass(false);

	varBounds = &varPhysCollmap->bounds;
	Load_Bounds(false);

	DB_PopStreamPos();
}

void Load_PhysCollmapArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysCollmap, sizeof(PhysCollmap) * count);
	PhysCollmap* pointer = varPhysCollmap;
	for (int i = 0; i < count; i++)
	{
		varPhysCollmap = pointer;
		Load_PhysCollmap(false);
		pointer++;
	}
}

void Load_PhysCollmapAsset(PhysCollmap** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_PHYSCOLLMAP, (void**)varPhysCollmapPtr);
}

void Load_PhysCollmapPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysCollmap, sizeof(PhysCollmap*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	PhysCollmap* pointer = *varPhysCollmapPtr;
	if (*varPhysCollmapPtr != nullptr)
	{
		if (*varPhysCollmapPtr == (PhysCollmap*)0xFFFFFFFF || *varPhysCollmapPtr == (PhysCollmap*)0xFFFFFFFE)
		{
			*varPhysCollmapPtr = AllocLoad_PhysCollmap();
			varPhysCollmap = *varPhysCollmapPtr;
			PhysCollmap** insertedPointer = nullptr;
			if (pointer == (PhysCollmap*)0xFFFFFFFE)
			{
				insertedPointer = (PhysCollmap**)DB_InsertPointer();
			}
			Load_PhysCollmap(true);
			Load_PhysCollmapAsset(varPhysCollmapPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varPhysCollmapPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varPhysCollmapPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_PhysCollmapPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysCollmapPtr, sizeof(PhysCollmap*) * count);
	PhysCollmap** pointer = varPhysCollmapPtr;
	for (int i = 0; i < count; i++)
	{
		varPhysCollmapPtr = pointer;
		Load_PhysCollmapPtr(false);
		pointer++;
	}
}

void Load_PhysGeomInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysGeomInfo, sizeof(PhysGeomInfo));

	if (varPhysGeomInfo->brushWrapper)
	{
		varBrushWrapperPtr = &varPhysGeomInfo->brushWrapper;
		Load_BrushWrapperPtr(false);
	}

	varBounds = &varPhysGeomInfo->bounds;
	Load_Bounds(false);

}

void Load_PhysGeomInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysGeomInfo, sizeof(PhysGeomInfo) * count);
	PhysGeomInfo* pointer = varPhysGeomInfo;
	for (int i = 0; i < count; i++)
	{
		varPhysGeomInfo = pointer;
		Load_PhysGeomInfo(false);
		pointer++;
	}
}

void Load_PhysGeomInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysGeomInfo, sizeof(PhysGeomInfo));
	if (*varPhysGeomInfoPtr != nullptr)
	{
		if (*varPhysGeomInfoPtr == (PhysGeomInfo*)0xFFFFFFFF)
		{
			*varPhysGeomInfoPtr = AllocLoad_PhysGeomInfo();
			varPhysGeomInfo = *varPhysGeomInfoPtr;
			Load_PhysGeomInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varPhysGeomInfoPtr);
		}
	}
}

void Load_PhysGeomInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysGeomInfoPtr, sizeof(PhysGeomInfo*) * count);
	PhysGeomInfo** pointer = varPhysGeomInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varPhysGeomInfoPtr = pointer;
		Load_PhysGeomInfoPtr(false);
		pointer++;
	}
}

void Load_PhysMass(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysMass, sizeof(PhysMass));

}

void Load_PhysMassArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysMass, sizeof(PhysMass) * count);
	PhysMass* pointer = varPhysMass;
	for (int i = 0; i < count; i++)
	{
		varPhysMass = pointer;
		Load_PhysMass(false);
		pointer++;
	}
}

void Load_PhysMassPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysMass, sizeof(PhysMass));
	if (*varPhysMassPtr != nullptr)
	{
		if (*varPhysMassPtr == (PhysMass*)0xFFFFFFFF)
		{
			*varPhysMassPtr = AllocLoad_PhysMass();
			varPhysMass = *varPhysMassPtr;
			Load_PhysMass(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varPhysMassPtr);
		}
	}
}

void Load_PhysMassPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysMassPtr, sizeof(PhysMass*) * count);
	PhysMass** pointer = varPhysMassPtr;
	for (int i = 0; i < count; i++)
	{
		varPhysMassPtr = pointer;
		Load_PhysMassPtr(false);
		pointer++;
	}
}

void Load_PhysPreset(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysPreset, sizeof(PhysPreset));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varPhysPreset->name;
	Load_XString(false);

	varXString = &varPhysPreset->sndAliasPrefix;
	Load_XString(false);

	DB_PopStreamPos();
}

void Load_PhysPresetArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysPreset, sizeof(PhysPreset) * count);
	PhysPreset* pointer = varPhysPreset;
	for (int i = 0; i < count; i++)
	{
		varPhysPreset = pointer;
		Load_PhysPreset(false);
		pointer++;
	}
}

void Load_PhysPresetAsset(PhysPreset** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_PHYSPRESET, (void**)varPhysPresetPtr);
}

void Load_PhysPresetPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPhysPreset, sizeof(PhysPreset*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	PhysPreset* pointer = *varPhysPresetPtr;
	if (*varPhysPresetPtr != nullptr)
	{
		if (*varPhysPresetPtr == (PhysPreset*)0xFFFFFFFF || *varPhysPresetPtr == (PhysPreset*)0xFFFFFFFE)
		{
			*varPhysPresetPtr = AllocLoad_PhysPreset();
			varPhysPreset = *varPhysPresetPtr;
			PhysPreset** insertedPointer = nullptr;
			if (pointer == (PhysPreset*)0xFFFFFFFE)
			{
				insertedPointer = (PhysPreset**)DB_InsertPointer();
			}
			Load_PhysPreset(true);
			Load_PhysPresetAsset(varPhysPresetPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varPhysPresetPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varPhysPresetPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_PhysPresetPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPhysPresetPtr, sizeof(PhysPreset*) * count);
	PhysPreset** pointer = varPhysPresetPtr;
	for (int i = 0; i < count; i++)
	{
		varPhysPresetPtr = pointer;
		Load_PhysPresetPtr(false);
		pointer++;
	}
}

void Load_Picmip(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPicmip, sizeof(Picmip));

}

void Load_PicmipArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPicmip, sizeof(Picmip) * count);
	Picmip* pointer = varPicmip;
	for (int i = 0; i < count; i++)
	{
		varPicmip = pointer;
		Load_Picmip(false);
		pointer++;
	}
}

void Load_PicmipPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varPicmip, sizeof(Picmip));
	if (*varPicmipPtr != nullptr)
	{
		*varPicmipPtr = AllocLoad_Picmip();
		varPicmip = *varPicmipPtr;
		Load_Picmip(true);
	}
}

void Load_PicmipPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varPicmipPtr, sizeof(Picmip*) * count);
	Picmip** pointer = varPicmipPtr;
	for (int i = 0; i < count; i++)
	{
		varPicmipPtr = pointer;
		Load_PicmipPtr(false);
		pointer++;
	}
}

void Load_RawFile(bool atStreamStart)
{
	Load_Stream(atStreamStart, varRawFile, sizeof(RawFile));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varRawFile->name;
	Load_XString(false);

	if (varRawFile->buffer)
	{
		if (varRawFile->buffer == (char*)0xFFFFFFFF)
		{
			varRawFile->buffer = AllocLoad_char();
			varchar = varRawFile->buffer;
			Load_charArray(true, ((varRawFile->compressedLen) ? varRawFile->compressedLen : varRawFile->len + 1));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varRawFile->buffer);
		}
	}

	DB_PopStreamPos();
}

void Load_RawFileArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varRawFile, sizeof(RawFile) * count);
	RawFile* pointer = varRawFile;
	for (int i = 0; i < count; i++)
	{
		varRawFile = pointer;
		Load_RawFile(false);
		pointer++;
	}
}

void Load_RawFileAsset(RawFile** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_RAWFILE, (void**)varRawFilePtr);
}

void Load_RawFilePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varRawFile, sizeof(RawFile*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	RawFile* pointer = *varRawFilePtr;
	if (*varRawFilePtr != nullptr)
	{
		if (*varRawFilePtr == (RawFile*)0xFFFFFFFF || *varRawFilePtr == (RawFile*)0xFFFFFFFE)
		{
			*varRawFilePtr = AllocLoad_RawFile();
			varRawFile = *varRawFilePtr;
			RawFile** insertedPointer = nullptr;
			if (pointer == (RawFile*)0xFFFFFFFE)
			{
				insertedPointer = (RawFile**)DB_InsertPointer();
			}
			Load_RawFile(true);
			Load_RawFileAsset(varRawFilePtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varRawFilePtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varRawFilePtr);
		}
	}
	DB_PopStreamPos();
}

void Load_RawFilePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varRawFilePtr, sizeof(RawFile*) * count);
	RawFile** pointer = varRawFilePtr;
	for (int i = 0; i < count; i++)
	{
		varRawFilePtr = pointer;
		Load_RawFilePtr(false);
		pointer++;
	}
}

void Load_SModelAabbNode(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSModelAabbNode, sizeof(SModelAabbNode));

	varBounds = &varSModelAabbNode->bounds;
	Load_Bounds(false);

}

void Load_SModelAabbNodeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSModelAabbNode, sizeof(SModelAabbNode) * count);
	SModelAabbNode* pointer = varSModelAabbNode;
	for (int i = 0; i < count; i++)
	{
		varSModelAabbNode = pointer;
		Load_SModelAabbNode(false);
		pointer++;
	}
}

void Load_SModelAabbNodePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSModelAabbNode, sizeof(SModelAabbNode));
	if (*varSModelAabbNodePtr != nullptr)
	{
		if (*varSModelAabbNodePtr == (SModelAabbNode*)0xFFFFFFFF)
		{
			*varSModelAabbNodePtr = AllocLoad_SModelAabbNode();
			varSModelAabbNode = *varSModelAabbNodePtr;
			Load_SModelAabbNode(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varSModelAabbNodePtr);
		}
	}
}

void Load_SModelAabbNodePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSModelAabbNodePtr, sizeof(SModelAabbNode*) * count);
	SModelAabbNode** pointer = varSModelAabbNodePtr;
	for (int i = 0; i < count; i++)
	{
		varSModelAabbNodePtr = pointer;
		Load_SModelAabbNodePtr(false);
		pointer++;
	}
}

void Load_ScriptStringList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varScriptStringList, sizeof(ScriptStringList));

	if (varScriptStringList->strings)
	{
		if (varScriptStringList->strings == (TempString*)0xFFFFFFFF)
		{
			varScriptStringList->strings = AllocLoad_TempString();
			varTempString = varScriptStringList->strings;
			Load_TempStringArray(true, (varScriptStringList->count));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varScriptStringList->strings);
		}
	}

}

void Load_ScriptStringListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varScriptStringList, sizeof(ScriptStringList) * count);
	ScriptStringList* pointer = varScriptStringList;
	for (int i = 0; i < count; i++)
	{
		varScriptStringList = pointer;
		Load_ScriptStringList(false);
		pointer++;
	}
}

void Load_ScriptStringListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varScriptStringList, sizeof(ScriptStringList));
	if (*varScriptStringListPtr != nullptr)
	{
		if (*varScriptStringListPtr == (ScriptStringList*)0xFFFFFFFF)
		{
			*varScriptStringListPtr = AllocLoad_ScriptStringList();
			varScriptStringList = *varScriptStringListPtr;
			Load_ScriptStringList(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varScriptStringListPtr);
		}
	}
}

void Load_ScriptStringListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varScriptStringListPtr, sizeof(ScriptStringList*) * count);
	ScriptStringList** pointer = varScriptStringListPtr;
	for (int i = 0; i < count; i++)
	{
		varScriptStringListPtr = pointer;
		Load_ScriptStringListPtr(false);
		pointer++;
	}
}

void Load_SetLocalVarData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSetLocalVarData, sizeof(SetLocalVarData));

	varXString = &varSetLocalVarData->localVarName;
	Load_XString(false);

	if (varSetLocalVarData->expression)
	{
		varStatement_sPtr = &varSetLocalVarData->expression;
		Load_Statement_sPtr(false);
	}

}

void Load_SetLocalVarDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSetLocalVarData, sizeof(SetLocalVarData) * count);
	SetLocalVarData* pointer = varSetLocalVarData;
	for (int i = 0; i < count; i++)
	{
		varSetLocalVarData = pointer;
		Load_SetLocalVarData(false);
		pointer++;
	}
}

void Load_SetLocalVarDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSetLocalVarData, sizeof(SetLocalVarData));
	if (*varSetLocalVarDataPtr != nullptr)
	{
		if (*varSetLocalVarDataPtr == (SetLocalVarData*)0xFFFFFFFF)
		{
			*varSetLocalVarDataPtr = AllocLoad_SetLocalVarData();
			varSetLocalVarData = *varSetLocalVarDataPtr;
			Load_SetLocalVarData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varSetLocalVarDataPtr);
		}
	}
}

void Load_SetLocalVarDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSetLocalVarDataPtr, sizeof(SetLocalVarData*) * count);
	SetLocalVarData** pointer = varSetLocalVarDataPtr;
	for (int i = 0; i < count; i++)
	{
		varSetLocalVarDataPtr = pointer;
		Load_SetLocalVarDataPtr(false);
		pointer++;
	}
}

void Load_SndCurve(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSndCurve, sizeof(SndCurve));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varSndCurve->filename;
	Load_XString(false);

	DB_PopStreamPos();
}

void Load_SndCurveArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSndCurve, sizeof(SndCurve) * count);
	SndCurve* pointer = varSndCurve;
	for (int i = 0; i < count; i++)
	{
		varSndCurve = pointer;
		Load_SndCurve(false);
		pointer++;
	}
}

void Load_SndCurveAsset(SndCurve** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_SOUND_CURVE, (void**)varSndCurvePtr);
}

void Load_SndCurvePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSndCurve, sizeof(SndCurve*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	SndCurve* pointer = *varSndCurvePtr;
	if (*varSndCurvePtr != nullptr)
	{
		if (*varSndCurvePtr == (SndCurve*)0xFFFFFFFF || *varSndCurvePtr == (SndCurve*)0xFFFFFFFE)
		{
			*varSndCurvePtr = AllocLoad_SndCurve();
			varSndCurve = *varSndCurvePtr;
			SndCurve** insertedPointer = nullptr;
			if (pointer == (SndCurve*)0xFFFFFFFE)
			{
				insertedPointer = (SndCurve**)DB_InsertPointer();
			}
			Load_SndCurve(true);
			Load_SndCurveAsset(varSndCurvePtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varSndCurvePtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varSndCurvePtr);
		}
	}
	DB_PopStreamPos();
}

void Load_SndCurvePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSndCurvePtr, sizeof(SndCurve*) * count);
	SndCurve** pointer = varSndCurvePtr;
	for (int i = 0; i < count; i++)
	{
		varSndCurvePtr = pointer;
		Load_SndCurvePtr(false);
		pointer++;
	}
}

void Load_SndDriverGlobals(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSndDriverGlobals, sizeof(SndDriverGlobals));

	varXString = &varSndDriverGlobals->name;
	Load_XString(false);

}

void Load_SndDriverGlobalsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSndDriverGlobals, sizeof(SndDriverGlobals) * count);
	SndDriverGlobals* pointer = varSndDriverGlobals;
	for (int i = 0; i < count; i++)
	{
		varSndDriverGlobals = pointer;
		Load_SndDriverGlobals(false);
		pointer++;
	}
}

void Load_SndDriverGlobalsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSndDriverGlobals, sizeof(SndDriverGlobals));
	if (*varSndDriverGlobalsPtr != nullptr)
	{
		*varSndDriverGlobalsPtr = AllocLoad_SndDriverGlobals();
		varSndDriverGlobals = *varSndDriverGlobalsPtr;
		Load_SndDriverGlobals(true);
	}
}

void Load_SndDriverGlobalsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSndDriverGlobalsPtr, sizeof(SndDriverGlobals*) * count);
	SndDriverGlobals** pointer = varSndDriverGlobalsPtr;
	for (int i = 0; i < count; i++)
	{
		varSndDriverGlobalsPtr = pointer;
		Load_SndDriverGlobalsPtr(false);
		pointer++;
	}
}

void Load_SoundFile(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSoundFile, sizeof(SoundFile));

	varSoundFileRef = &varSoundFile->u;
	Load_SoundFileRef(false);

}

void Load_SoundFileArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSoundFile, sizeof(SoundFile) * count);
	SoundFile* pointer = varSoundFile;
	for (int i = 0; i < count; i++)
	{
		varSoundFile = pointer;
		Load_SoundFile(false);
		pointer++;
	}
}

void Load_SoundFilePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSoundFile, sizeof(SoundFile));
	if (*varSoundFilePtr != nullptr)
	{
		if (*varSoundFilePtr == (SoundFile*)0xFFFFFFFF)
		{
			*varSoundFilePtr = AllocLoad_SoundFile();
			varSoundFile = *varSoundFilePtr;
			Load_SoundFile(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varSoundFilePtr);
		}
	}
}

void Load_SoundFilePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSoundFilePtr, sizeof(SoundFile*) * count);
	SoundFile** pointer = varSoundFilePtr;
	for (int i = 0; i < count; i++)
	{
		varSoundFilePtr = pointer;
		Load_SoundFilePtr(false);
		pointer++;
	}
}

void Load_SoundFileRef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSoundFileRef, sizeof(SoundFileRef));

	switch (varSoundFile->type)
	{
	case 1:
		varLoadedSoundPtr = &varSoundFileRef->loadSnd;
		Load_LoadedSoundPtr(false);
		break;
	default:
		varStreamedSound = &varSoundFileRef->streamSnd;
		Load_StreamedSound(atStreamStart);
		break;
	}
}

void Load_SoundFileRefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSoundFileRef, sizeof(SoundFileRef) * count);
	SoundFileRef* pointer = varSoundFileRef;
	for (int i = 0; i < count; i++)
	{
		varSoundFileRef = pointer;
		Load_SoundFileRef(false);
		pointer++;
	}
}

void Load_SoundFileRefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSoundFileRef, sizeof(SoundFileRef));
	if (*varSoundFileRefPtr != nullptr)
	{
		if (*varSoundFileRefPtr == (SoundFileRef*)0xFFFFFFFF)
		{
			*varSoundFileRefPtr = AllocLoad_SoundFileRef();
			varSoundFileRef = *varSoundFileRefPtr;
			Load_SoundFileRef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varSoundFileRefPtr);
		}
	}
}

void Load_SoundFileRefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSoundFileRefPtr, sizeof(SoundFileRef*) * count);
	SoundFileRef** pointer = varSoundFileRefPtr;
	for (int i = 0; i < count; i++)
	{
		varSoundFileRefPtr = pointer;
		Load_SoundFileRefPtr(false);
		pointer++;
	}
}

void Load_SpeakerMap(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSpeakerMap, sizeof(SpeakerMap));

	varXString = &varSpeakerMap->name;
	Load_XString(false);

	varMSSChannelMap = varSpeakerMap->channelMaps;
	Load_MSSChannelMapArray(false, 4);

}

void Load_SpeakerMapArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSpeakerMap, sizeof(SpeakerMap) * count);
	SpeakerMap* pointer = varSpeakerMap;
	for (int i = 0; i < count; i++)
	{
		varSpeakerMap = pointer;
		Load_SpeakerMap(false);
		pointer++;
	}
}

void Load_SpeakerMapPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varSpeakerMap, sizeof(SpeakerMap));
	if (*varSpeakerMapPtr != nullptr)
	{
		if (*varSpeakerMapPtr == (SpeakerMap*)0xFFFFFFFF)
		{
			*varSpeakerMapPtr = AllocLoad_SpeakerMap();
			varSpeakerMap = *varSpeakerMapPtr;
			Load_SpeakerMap(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varSpeakerMapPtr);
		}
	}
}

void Load_SpeakerMapPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varSpeakerMapPtr, sizeof(SpeakerMap*) * count);
	SpeakerMap** pointer = varSpeakerMapPtr;
	for (int i = 0; i < count; i++)
	{
		varSpeakerMapPtr = pointer;
		Load_SpeakerMapPtr(false);
		pointer++;
	}
}

void Load_Stage(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStage, sizeof(Stage));

	varXString = &varStage->name;
	Load_XString(false);

}

void Load_StageArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStage, sizeof(Stage) * count);
	Stage* pointer = varStage;
	for (int i = 0; i < count; i++)
	{
		varStage = pointer;
		Load_Stage(false);
		pointer++;
	}
}

void Load_StagePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStage, sizeof(Stage));
	if (*varStagePtr != nullptr)
	{
		if (*varStagePtr == (Stage*)0xFFFFFFFF)
		{
			*varStagePtr = AllocLoad_Stage();
			varStage = *varStagePtr;
			Load_Stage(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStagePtr);
		}
	}
}

void Load_StagePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStagePtr, sizeof(Stage*) * count);
	Stage** pointer = varStagePtr;
	for (int i = 0; i < count; i++)
	{
		varStagePtr = pointer;
		Load_StagePtr(false);
		pointer++;
	}
}

void Load_Statement_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStatement_s, sizeof(Statement_s));

	if (varStatement_s->entries)
	{
		if (varStatement_s->entries == (expressionEntry*)0xFFFFFFFF)
		{
			varStatement_s->entries = AllocLoad_expressionEntry();
			varexpressionEntry = varStatement_s->entries;
			Load_expressionEntryArray(true, (varStatement_s->numEntries));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStatement_s->entries);
		}
	}

	if (varStatement_s->supportingData)
	{
		varExpressionSupportingDataPtr = &varStatement_s->supportingData;
		Load_ExpressionSupportingDataPtr(false);
	}

}

void Load_Statement_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStatement_s, sizeof(Statement_s) * count);
	Statement_s* pointer = varStatement_s;
	for (int i = 0; i < count; i++)
	{
		varStatement_s = pointer;
		Load_Statement_s(false);
		pointer++;
	}
}

void Load_Statement_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStatement_s, sizeof(Statement_s));
	if (*varStatement_sPtr != nullptr)
	{
		if (*varStatement_sPtr == (Statement_s*)0xFFFFFFFF)
		{
			*varStatement_sPtr = AllocLoad_Statement_s();
			varStatement_s = *varStatement_sPtr;
			Load_Statement_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStatement_sPtr);
		}
	}
}

void Load_Statement_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStatement_sPtr, sizeof(Statement_s*) * count);
	Statement_s** pointer = varStatement_sPtr;
	for (int i = 0; i < count; i++)
	{
		varStatement_sPtr = pointer;
		Load_Statement_sPtr(false);
		pointer++;
	}
}

void Load_StaticDvar(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStaticDvar, sizeof(StaticDvar));

	varXString = &varStaticDvar->dvarName;
	Load_XString(false);

}

void Load_StaticDvarArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStaticDvar, sizeof(StaticDvar) * count);
	StaticDvar* pointer = varStaticDvar;
	for (int i = 0; i < count; i++)
	{
		varStaticDvar = pointer;
		Load_StaticDvar(false);
		pointer++;
	}
}

void Load_StaticDvarList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStaticDvarList, sizeof(StaticDvarList));

	if (varStaticDvarList->staticDvars)
	{
		if (varStaticDvarList->staticDvars == (StaticDvar**)0xFFFFFFFF)
		{
			varStaticDvarList->staticDvars = AllocLoad_StaticDvarPtr();
			varStaticDvarPtr = varStaticDvarList->staticDvars;
			Load_StaticDvarPtrArray(true, (varStaticDvarList->numStaticDvars));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStaticDvarList->staticDvars);
		}
	}

}

void Load_StaticDvarListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStaticDvarList, sizeof(StaticDvarList) * count);
	StaticDvarList* pointer = varStaticDvarList;
	for (int i = 0; i < count; i++)
	{
		varStaticDvarList = pointer;
		Load_StaticDvarList(false);
		pointer++;
	}
}

void Load_StaticDvarListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStaticDvarList, sizeof(StaticDvarList));
	if (*varStaticDvarListPtr != nullptr)
	{
		if (*varStaticDvarListPtr == (StaticDvarList*)0xFFFFFFFF)
		{
			*varStaticDvarListPtr = AllocLoad_StaticDvarList();
			varStaticDvarList = *varStaticDvarListPtr;
			Load_StaticDvarList(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStaticDvarListPtr);
		}
	}
}

void Load_StaticDvarListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStaticDvarListPtr, sizeof(StaticDvarList*) * count);
	StaticDvarList** pointer = varStaticDvarListPtr;
	for (int i = 0; i < count; i++)
	{
		varStaticDvarListPtr = pointer;
		Load_StaticDvarListPtr(false);
		pointer++;
	}
}

void Load_StaticDvarPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStaticDvar, sizeof(StaticDvar));
	if (*varStaticDvarPtr != nullptr)
	{
		if (*varStaticDvarPtr == (StaticDvar*)0xFFFFFFFF)
		{
			*varStaticDvarPtr = AllocLoad_StaticDvar();
			varStaticDvar = *varStaticDvarPtr;
			Load_StaticDvar(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStaticDvarPtr);
		}
	}
}

void Load_StaticDvarPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStaticDvarPtr, sizeof(StaticDvar*) * count);
	StaticDvar** pointer = varStaticDvarPtr;
	for (int i = 0; i < count; i++)
	{
		varStaticDvarPtr = pointer;
		Load_StaticDvarPtr(false);
		pointer++;
	}
}

void Load_StreamFileInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamFileInfo, sizeof(StreamFileInfo));

	varStreamFileNameRaw = &varStreamFileInfo->raw;
	Load_StreamFileNameRaw(false);

}

void Load_StreamFileInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamFileInfo, sizeof(StreamFileInfo) * count);
	StreamFileInfo* pointer = varStreamFileInfo;
	for (int i = 0; i < count; i++)
	{
		varStreamFileInfo = pointer;
		Load_StreamFileInfo(false);
		pointer++;
	}
}

void Load_StreamFileInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamFileInfo, sizeof(StreamFileInfo));
	if (*varStreamFileInfoPtr != nullptr)
	{
		*varStreamFileInfoPtr = AllocLoad_StreamFileInfo();
		varStreamFileInfo = *varStreamFileInfoPtr;
		Load_StreamFileInfo(true);
	}
}

void Load_StreamFileInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamFileInfoPtr, sizeof(StreamFileInfo*) * count);
	StreamFileInfo** pointer = varStreamFileInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varStreamFileInfoPtr = pointer;
		Load_StreamFileInfoPtr(false);
		pointer++;
	}
}

void Load_StreamFileName(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamFileName, sizeof(StreamFileName));

	varStreamFileInfo = &varStreamFileName->info;
	Load_StreamFileInfo(false);

}

void Load_StreamFileNameArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamFileName, sizeof(StreamFileName) * count);
	StreamFileName* pointer = varStreamFileName;
	for (int i = 0; i < count; i++)
	{
		varStreamFileName = pointer;
		Load_StreamFileName(false);
		pointer++;
	}
}

void Load_StreamFileNamePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamFileName, sizeof(StreamFileName));
	if (*varStreamFileNamePtr != nullptr)
	{
		*varStreamFileNamePtr = AllocLoad_StreamFileName();
		varStreamFileName = *varStreamFileNamePtr;
		Load_StreamFileName(true);
	}
}

void Load_StreamFileNamePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamFileNamePtr, sizeof(StreamFileName*) * count);
	StreamFileName** pointer = varStreamFileNamePtr;
	for (int i = 0; i < count; i++)
	{
		varStreamFileNamePtr = pointer;
		Load_StreamFileNamePtr(false);
		pointer++;
	}
}

void Load_StreamFileNameRaw(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamFileNameRaw, sizeof(StreamFileNameRaw));

	varXString = &varStreamFileNameRaw->dir;
	Load_XString(false);

	varXString = &varStreamFileNameRaw->name;
	Load_XString(false);

}

void Load_StreamFileNameRawArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamFileNameRaw, sizeof(StreamFileNameRaw) * count);
	StreamFileNameRaw* pointer = varStreamFileNameRaw;
	for (int i = 0; i < count; i++)
	{
		varStreamFileNameRaw = pointer;
		Load_StreamFileNameRaw(false);
		pointer++;
	}
}

void Load_StreamFileNameRawPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamFileNameRaw, sizeof(StreamFileNameRaw));
	if (*varStreamFileNameRawPtr != nullptr)
	{
		if (*varStreamFileNameRawPtr == (StreamFileNameRaw*)0xFFFFFFFF)
		{
			*varStreamFileNameRawPtr = AllocLoad_StreamFileNameRaw();
			varStreamFileNameRaw = *varStreamFileNameRawPtr;
			Load_StreamFileNameRaw(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStreamFileNameRawPtr);
		}
	}
}

void Load_StreamFileNameRawPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamFileNameRawPtr, sizeof(StreamFileNameRaw*) * count);
	StreamFileNameRaw** pointer = varStreamFileNameRawPtr;
	for (int i = 0; i < count; i++)
	{
		varStreamFileNameRawPtr = pointer;
		Load_StreamFileNameRawPtr(false);
		pointer++;
	}
}

void Load_StreamedSound(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamedSound, sizeof(StreamedSound));

	varStreamFileName = &varStreamedSound->filename;
	Load_StreamFileName(false);

}

void Load_StreamedSoundArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamedSound, sizeof(StreamedSound) * count);
	StreamedSound* pointer = varStreamedSound;
	for (int i = 0; i < count; i++)
	{
		varStreamedSound = pointer;
		Load_StreamedSound(false);
		pointer++;
	}
}

void Load_StreamedSoundPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStreamedSound, sizeof(StreamedSound));
	if (*varStreamedSoundPtr != nullptr)
	{
		*varStreamedSoundPtr = AllocLoad_StreamedSound();
		varStreamedSound = *varStreamedSoundPtr;
		Load_StreamedSound(true);
	}
}

void Load_StreamedSoundPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStreamedSoundPtr, sizeof(StreamedSound*) * count);
	StreamedSound** pointer = varStreamedSoundPtr;
	for (int i = 0; i < count; i++)
	{
		varStreamedSoundPtr = pointer;
		Load_StreamedSoundPtr(false);
		pointer++;
	}
}

void Load_StringList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStringList, sizeof(StringList));

	if (varStringList->strings)
	{
		if (varStringList->strings == (XString*)0xFFFFFFFF)
		{
			varStringList->strings = AllocLoad_XString();
			varXString = varStringList->strings;
			Load_XStringArray(true, (varStringList->totalStrings));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStringList->strings);
		}
	}

}

void Load_StringListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStringList, sizeof(StringList) * count);
	StringList* pointer = varStringList;
	for (int i = 0; i < count; i++)
	{
		varStringList = pointer;
		Load_StringList(false);
		pointer++;
	}
}

void Load_StringListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStringList, sizeof(StringList));
	if (*varStringListPtr != nullptr)
	{
		if (*varStringListPtr == (StringList*)0xFFFFFFFF)
		{
			*varStringListPtr = AllocLoad_StringList();
			varStringList = *varStringListPtr;
			Load_StringList(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStringListPtr);
		}
	}
}

void Load_StringListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStringListPtr, sizeof(StringList*) * count);
	StringList** pointer = varStringListPtr;
	for (int i = 0; i < count; i++)
	{
		varStringListPtr = pointer;
		Load_StringListPtr(false);
		pointer++;
	}
}

void Load_StringTable(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStringTable, sizeof(StringTable));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varStringTable->name;
	Load_XString(false);

	if (varStringTable->values)
	{
		if (varStringTable->values == (StringTableCell*)0xFFFFFFFF)
		{
			varStringTable->values = AllocLoad_StringTableCell();
			varStringTableCell = varStringTable->values;
			Load_StringTableCellArray(true, (varStringTable->columnCount * varStringTable->rowCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStringTable->values);
		}
	}

	DB_PopStreamPos();
}

void Load_StringTableArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStringTable, sizeof(StringTable) * count);
	StringTable* pointer = varStringTable;
	for (int i = 0; i < count; i++)
	{
		varStringTable = pointer;
		Load_StringTable(false);
		pointer++;
	}
}

void Load_StringTableAsset(StringTable** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_STRINGTABLE, (void**)varStringTablePtr);
}

void Load_StringTableCell(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStringTableCell, sizeof(StringTableCell));

	varXString = &varStringTableCell->string;
	Load_XString(false);

}

void Load_StringTableCellArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStringTableCell, sizeof(StringTableCell) * count);
	StringTableCell* pointer = varStringTableCell;
	for (int i = 0; i < count; i++)
	{
		varStringTableCell = pointer;
		Load_StringTableCell(false);
		pointer++;
	}
}

void Load_StringTableCellPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStringTableCell, sizeof(StringTableCell));
	if (*varStringTableCellPtr != nullptr)
	{
		if (*varStringTableCellPtr == (StringTableCell*)0xFFFFFFFF)
		{
			*varStringTableCellPtr = AllocLoad_StringTableCell();
			varStringTableCell = *varStringTableCellPtr;
			Load_StringTableCell(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStringTableCellPtr);
		}
	}
}

void Load_StringTableCellPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStringTableCellPtr, sizeof(StringTableCell*) * count);
	StringTableCell** pointer = varStringTableCellPtr;
	for (int i = 0; i < count; i++)
	{
		varStringTableCellPtr = pointer;
		Load_StringTableCellPtr(false);
		pointer++;
	}
}

void Load_StringTablePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStringTable, sizeof(StringTable*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	StringTable* pointer = *varStringTablePtr;
	if (*varStringTablePtr != nullptr)
	{
		if (*varStringTablePtr == (StringTable*)0xFFFFFFFF || *varStringTablePtr == (StringTable*)0xFFFFFFFE)
		{
			*varStringTablePtr = AllocLoad_StringTable();
			varStringTable = *varStringTablePtr;
			StringTable** insertedPointer = nullptr;
			if (pointer == (StringTable*)0xFFFFFFFE)
			{
				insertedPointer = (StringTable**)DB_InsertPointer();
			}
			Load_StringTable(true);
			Load_StringTableAsset(varStringTablePtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varStringTablePtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varStringTablePtr);
		}
	}
	DB_PopStreamPos();
}

void Load_StringTablePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStringTablePtr, sizeof(StringTable*) * count);
	StringTable** pointer = varStringTablePtr;
	for (int i = 0; i < count; i++)
	{
		varStringTablePtr = pointer;
		Load_StringTablePtr(false);
		pointer++;
	}
}

void Load_StructuredDataDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataDef, sizeof(StructuredDataDef));

	if (varStructuredDataDef->enums)
	{
		if (varStructuredDataDef->enums == (StructuredDataEnum*)0xFFFFFFFF)
		{
			varStructuredDataDef->enums = AllocLoad_StructuredDataEnum();
			varStructuredDataEnum = varStructuredDataDef->enums;
			Load_StructuredDataEnumArray(true, (varStructuredDataDef->enumCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataDef->enums);
		}
	}

	if (varStructuredDataDef->structs)
	{
		if (varStructuredDataDef->structs == (StructuredDataStruct*)0xFFFFFFFF)
		{
			varStructuredDataDef->structs = AllocLoad_StructuredDataStruct();
			varStructuredDataStruct = varStructuredDataDef->structs;
			Load_StructuredDataStructArray(true, (varStructuredDataDef->structCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataDef->structs);
		}
	}

	if (varStructuredDataDef->indexedArrays)
	{
		if (varStructuredDataDef->indexedArrays == (StructuredDataIndexedArray*)0xFFFFFFFF)
		{
			varStructuredDataDef->indexedArrays = AllocLoad_StructuredDataIndexedArray();
			varStructuredDataIndexedArray = varStructuredDataDef->indexedArrays;
			Load_StructuredDataIndexedArrayArray(true, (varStructuredDataDef->indexedArrayCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataDef->indexedArrays);
		}
	}

	if (varStructuredDataDef->enumedArrays)
	{
		if (varStructuredDataDef->enumedArrays == (StructuredDataEnumedArray*)0xFFFFFFFF)
		{
			varStructuredDataDef->enumedArrays = AllocLoad_StructuredDataEnumedArray();
			varStructuredDataEnumedArray = varStructuredDataDef->enumedArrays;
			Load_StructuredDataEnumedArrayArray(true, (varStructuredDataDef->enumedArrayCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataDef->enumedArrays);
		}
	}

	varStructuredDataType = &varStructuredDataDef->rootType;
	Load_StructuredDataType(false);

}

void Load_StructuredDataDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataDef, sizeof(StructuredDataDef) * count);
	StructuredDataDef* pointer = varStructuredDataDef;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataDef = pointer;
		Load_StructuredDataDef(false);
		pointer++;
	}
}

void Load_StructuredDataDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataDef, sizeof(StructuredDataDef));
	if (*varStructuredDataDefPtr != nullptr)
	{
		if (*varStructuredDataDefPtr == (StructuredDataDef*)0xFFFFFFFF)
		{
			*varStructuredDataDefPtr = AllocLoad_StructuredDataDef();
			varStructuredDataDef = *varStructuredDataDefPtr;
			Load_StructuredDataDef(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataDefPtr);
		}
	}
}

void Load_StructuredDataDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataDefPtr, sizeof(StructuredDataDef*) * count);
	StructuredDataDef** pointer = varStructuredDataDefPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataDefPtr = pointer;
		Load_StructuredDataDefPtr(false);
		pointer++;
	}
}

void Load_StructuredDataDefSet(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataDefSet, sizeof(StructuredDataDefSet));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varStructuredDataDefSet->name;
	Load_XString(false);

	if (varStructuredDataDefSet->defs)
	{
		if (varStructuredDataDefSet->defs == (StructuredDataDef*)0xFFFFFFFF)
		{
			varStructuredDataDefSet->defs = AllocLoad_StructuredDataDef();
			varStructuredDataDef = varStructuredDataDefSet->defs;
			Load_StructuredDataDefArray(true, (varStructuredDataDefSet->defCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataDefSet->defs);
		}
	}

	DB_PopStreamPos();
}

void Load_StructuredDataDefSetArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataDefSet, sizeof(StructuredDataDefSet) * count);
	StructuredDataDefSet* pointer = varStructuredDataDefSet;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataDefSet = pointer;
		Load_StructuredDataDefSet(false);
		pointer++;
	}
}

void Load_StructuredDataDefSetAsset(StructuredDataDefSet** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_STRUCTURED_DATA_DEF, (void**)varStructuredDataDefSetPtr);
}

void Load_StructuredDataDefSetPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataDefSet, sizeof(StructuredDataDefSet*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	StructuredDataDefSet* pointer = *varStructuredDataDefSetPtr;
	if (*varStructuredDataDefSetPtr != nullptr)
	{
		if (*varStructuredDataDefSetPtr == (StructuredDataDefSet*)0xFFFFFFFF || *varStructuredDataDefSetPtr == (StructuredDataDefSet*)0xFFFFFFFE)
		{
			*varStructuredDataDefSetPtr = AllocLoad_StructuredDataDefSet();
			varStructuredDataDefSet = *varStructuredDataDefSetPtr;
			StructuredDataDefSet** insertedPointer = nullptr;
			if (pointer == (StructuredDataDefSet*)0xFFFFFFFE)
			{
				insertedPointer = (StructuredDataDefSet**)DB_InsertPointer();
			}
			Load_StructuredDataDefSet(true);
			Load_StructuredDataDefSetAsset(varStructuredDataDefSetPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varStructuredDataDefSetPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varStructuredDataDefSetPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_StructuredDataDefSetPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataDefSetPtr, sizeof(StructuredDataDefSet*) * count);
	StructuredDataDefSet** pointer = varStructuredDataDefSetPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataDefSetPtr = pointer;
		Load_StructuredDataDefSetPtr(false);
		pointer++;
	}
}

void Load_StructuredDataEnum(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataEnum, sizeof(StructuredDataEnum));

	if (varStructuredDataEnum->entries)
	{
		if (varStructuredDataEnum->entries == (StructuredDataEnumEntry*)0xFFFFFFFF)
		{
			varStructuredDataEnum->entries = AllocLoad_StructuredDataEnumEntry();
			varStructuredDataEnumEntry = varStructuredDataEnum->entries;
			Load_StructuredDataEnumEntryArray(true, (varStructuredDataEnum->entryCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataEnum->entries);
		}
	}

}

void Load_StructuredDataEnumArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataEnum, sizeof(StructuredDataEnum) * count);
	StructuredDataEnum* pointer = varStructuredDataEnum;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataEnum = pointer;
		Load_StructuredDataEnum(false);
		pointer++;
	}
}

void Load_StructuredDataEnumEntry(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataEnumEntry, sizeof(StructuredDataEnumEntry));

	varXString = &varStructuredDataEnumEntry->string;
	Load_XString(false);

}

void Load_StructuredDataEnumEntryArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataEnumEntry, sizeof(StructuredDataEnumEntry) * count);
	StructuredDataEnumEntry* pointer = varStructuredDataEnumEntry;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataEnumEntry = pointer;
		Load_StructuredDataEnumEntry(false);
		pointer++;
	}
}

void Load_StructuredDataEnumEntryPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataEnumEntry, sizeof(StructuredDataEnumEntry));
	if (*varStructuredDataEnumEntryPtr != nullptr)
	{
		if (*varStructuredDataEnumEntryPtr == (StructuredDataEnumEntry*)0xFFFFFFFF)
		{
			*varStructuredDataEnumEntryPtr = AllocLoad_StructuredDataEnumEntry();
			varStructuredDataEnumEntry = *varStructuredDataEnumEntryPtr;
			Load_StructuredDataEnumEntry(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataEnumEntryPtr);
		}
	}
}

void Load_StructuredDataEnumEntryPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataEnumEntryPtr, sizeof(StructuredDataEnumEntry*) * count);
	StructuredDataEnumEntry** pointer = varStructuredDataEnumEntryPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataEnumEntryPtr = pointer;
		Load_StructuredDataEnumEntryPtr(false);
		pointer++;
	}
}

void Load_StructuredDataEnumPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataEnum, sizeof(StructuredDataEnum));
	if (*varStructuredDataEnumPtr != nullptr)
	{
		if (*varStructuredDataEnumPtr == (StructuredDataEnum*)0xFFFFFFFF)
		{
			*varStructuredDataEnumPtr = AllocLoad_StructuredDataEnum();
			varStructuredDataEnum = *varStructuredDataEnumPtr;
			Load_StructuredDataEnum(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataEnumPtr);
		}
	}
}

void Load_StructuredDataEnumPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataEnumPtr, sizeof(StructuredDataEnum*) * count);
	StructuredDataEnum** pointer = varStructuredDataEnumPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataEnumPtr = pointer;
		Load_StructuredDataEnumPtr(false);
		pointer++;
	}
}

void Load_StructuredDataEnumedArray(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataEnumedArray, sizeof(StructuredDataEnumedArray));

	varStructuredDataType = &varStructuredDataEnumedArray->elementType;
	Load_StructuredDataType(false);

}

void Load_StructuredDataEnumedArrayArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataEnumedArray, sizeof(StructuredDataEnumedArray) * count);
	StructuredDataEnumedArray* pointer = varStructuredDataEnumedArray;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataEnumedArray = pointer;
		Load_StructuredDataEnumedArray(false);
		pointer++;
	}
}

void Load_StructuredDataEnumedArrayPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataEnumedArray, sizeof(StructuredDataEnumedArray));
	if (*varStructuredDataEnumedArrayPtr != nullptr)
	{
		if (*varStructuredDataEnumedArrayPtr == (StructuredDataEnumedArray*)0xFFFFFFFF)
		{
			*varStructuredDataEnumedArrayPtr = AllocLoad_StructuredDataEnumedArray();
			varStructuredDataEnumedArray = *varStructuredDataEnumedArrayPtr;
			Load_StructuredDataEnumedArray(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataEnumedArrayPtr);
		}
	}
}

void Load_StructuredDataEnumedArrayPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataEnumedArrayPtr, sizeof(StructuredDataEnumedArray*) * count);
	StructuredDataEnumedArray** pointer = varStructuredDataEnumedArrayPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataEnumedArrayPtr = pointer;
		Load_StructuredDataEnumedArrayPtr(false);
		pointer++;
	}
}

void Load_StructuredDataIndexedArray(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataIndexedArray, sizeof(StructuredDataIndexedArray));

	varStructuredDataType = &varStructuredDataIndexedArray->elementType;
	Load_StructuredDataType(false);

}

void Load_StructuredDataIndexedArrayArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataIndexedArray, sizeof(StructuredDataIndexedArray) * count);
	StructuredDataIndexedArray* pointer = varStructuredDataIndexedArray;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataIndexedArray = pointer;
		Load_StructuredDataIndexedArray(false);
		pointer++;
	}
}

void Load_StructuredDataIndexedArrayPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataIndexedArray, sizeof(StructuredDataIndexedArray));
	if (*varStructuredDataIndexedArrayPtr != nullptr)
	{
		if (*varStructuredDataIndexedArrayPtr == (StructuredDataIndexedArray*)0xFFFFFFFF)
		{
			*varStructuredDataIndexedArrayPtr = AllocLoad_StructuredDataIndexedArray();
			varStructuredDataIndexedArray = *varStructuredDataIndexedArrayPtr;
			Load_StructuredDataIndexedArray(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataIndexedArrayPtr);
		}
	}
}

void Load_StructuredDataIndexedArrayPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataIndexedArrayPtr, sizeof(StructuredDataIndexedArray*) * count);
	StructuredDataIndexedArray** pointer = varStructuredDataIndexedArrayPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataIndexedArrayPtr = pointer;
		Load_StructuredDataIndexedArrayPtr(false);
		pointer++;
	}
}

void Load_StructuredDataStruct(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataStruct, sizeof(StructuredDataStruct));

	if (varStructuredDataStruct->properties)
	{
		if (varStructuredDataStruct->properties == (StructuredDataStructProperty*)0xFFFFFFFF)
		{
			varStructuredDataStruct->properties = AllocLoad_StructuredDataStructProperty();
			varStructuredDataStructProperty = varStructuredDataStruct->properties;
			Load_StructuredDataStructPropertyArray(true, (varStructuredDataStruct->propertyCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varStructuredDataStruct->properties);
		}
	}

}

void Load_StructuredDataStructArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataStruct, sizeof(StructuredDataStruct) * count);
	StructuredDataStruct* pointer = varStructuredDataStruct;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataStruct = pointer;
		Load_StructuredDataStruct(false);
		pointer++;
	}
}

void Load_StructuredDataStructProperty(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataStructProperty, sizeof(StructuredDataStructProperty));

	varXString = &varStructuredDataStructProperty->name;
	Load_XString(false);

	varStructuredDataType = &varStructuredDataStructProperty->type;
	Load_StructuredDataType(false);

}

void Load_StructuredDataStructPropertyArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataStructProperty, sizeof(StructuredDataStructProperty) * count);
	StructuredDataStructProperty* pointer = varStructuredDataStructProperty;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataStructProperty = pointer;
		Load_StructuredDataStructProperty(false);
		pointer++;
	}
}

void Load_StructuredDataStructPropertyPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataStructProperty, sizeof(StructuredDataStructProperty));
	if (*varStructuredDataStructPropertyPtr != nullptr)
	{
		if (*varStructuredDataStructPropertyPtr == (StructuredDataStructProperty*)0xFFFFFFFF)
		{
			*varStructuredDataStructPropertyPtr = AllocLoad_StructuredDataStructProperty();
			varStructuredDataStructProperty = *varStructuredDataStructPropertyPtr;
			Load_StructuredDataStructProperty(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataStructPropertyPtr);
		}
	}
}

void Load_StructuredDataStructPropertyPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataStructPropertyPtr, sizeof(StructuredDataStructProperty*) * count);
	StructuredDataStructProperty** pointer = varStructuredDataStructPropertyPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataStructPropertyPtr = pointer;
		Load_StructuredDataStructPropertyPtr(false);
		pointer++;
	}
}

void Load_StructuredDataStructPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataStruct, sizeof(StructuredDataStruct));
	if (*varStructuredDataStructPtr != nullptr)
	{
		if (*varStructuredDataStructPtr == (StructuredDataStruct*)0xFFFFFFFF)
		{
			*varStructuredDataStructPtr = AllocLoad_StructuredDataStruct();
			varStructuredDataStruct = *varStructuredDataStructPtr;
			Load_StructuredDataStruct(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataStructPtr);
		}
	}
}

void Load_StructuredDataStructPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataStructPtr, sizeof(StructuredDataStruct*) * count);
	StructuredDataStruct** pointer = varStructuredDataStructPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataStructPtr = pointer;
		Load_StructuredDataStructPtr(false);
		pointer++;
	}
}

void Load_StructuredDataType(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataType, sizeof(StructuredDataType));

	varStructuredDataTypeUnion = &varStructuredDataType->u;
	Load_StructuredDataTypeUnion(false);

}

void Load_StructuredDataTypeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataType, sizeof(StructuredDataType) * count);
	StructuredDataType* pointer = varStructuredDataType;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataType = pointer;
		Load_StructuredDataType(false);
		pointer++;
	}
}

void Load_StructuredDataTypePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataType, sizeof(StructuredDataType));
	if (*varStructuredDataTypePtr != nullptr)
	{
		if (*varStructuredDataTypePtr == (StructuredDataType*)0xFFFFFFFF)
		{
			*varStructuredDataTypePtr = AllocLoad_StructuredDataType();
			varStructuredDataType = *varStructuredDataTypePtr;
			Load_StructuredDataType(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataTypePtr);
		}
	}
}

void Load_StructuredDataTypePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataTypePtr, sizeof(StructuredDataType*) * count);
	StructuredDataType** pointer = varStructuredDataTypePtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataTypePtr = pointer;
		Load_StructuredDataTypePtr(false);
		pointer++;
	}
}

void Load_StructuredDataTypeUnion(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataTypeUnion, sizeof(StructuredDataTypeUnion));

}

void Load_StructuredDataTypeUnionArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataTypeUnion, sizeof(StructuredDataTypeUnion) * count);
	StructuredDataTypeUnion* pointer = varStructuredDataTypeUnion;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataTypeUnion = pointer;
		Load_StructuredDataTypeUnion(false);
		pointer++;
	}
}

void Load_StructuredDataTypeUnionPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varStructuredDataTypeUnion, sizeof(StructuredDataTypeUnion));
	if (*varStructuredDataTypeUnionPtr != nullptr)
	{
		if (*varStructuredDataTypeUnionPtr == (StructuredDataTypeUnion*)0xFFFFFFFF)
		{
			*varStructuredDataTypeUnionPtr = AllocLoad_StructuredDataTypeUnion();
			varStructuredDataTypeUnion = *varStructuredDataTypeUnionPtr;
			Load_StructuredDataTypeUnion(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varStructuredDataTypeUnionPtr);
		}
	}
}

void Load_StructuredDataTypeUnionPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varStructuredDataTypeUnionPtr, sizeof(StructuredDataTypeUnion*) * count);
	StructuredDataTypeUnion** pointer = varStructuredDataTypeUnionPtr;
	for (int i = 0; i < count; i++)
	{
		varStructuredDataTypeUnionPtr = pointer;
		Load_StructuredDataTypeUnionPtr(false);
		pointer++;
	}
}

void Load_TempStringArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTempString, sizeof(TempString) * count);
	TempString* pointer = varTempString;
	for (int i = 0; i < count; i++)
	{
		varTempString = pointer;
		Load_TempString(false);
		pointer++;
	}
}

void Load_TempStringPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTempString, sizeof(TempString));
	if (*varTempStringPtr != nullptr)
	{
		*varTempStringPtr = AllocLoad_TempString();
		varTempString = *varTempStringPtr;
		Load_TempString(true);
	}
}

void Load_TempStringPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTempStringPtr, sizeof(TempString*) * count);
	TempString** pointer = varTempStringPtr;
	for (int i = 0; i < count; i++)
	{
		varTempStringPtr = pointer;
		Load_TempStringPtr(false);
		pointer++;
	}
}

void Load_TracerDef(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTracerDef, sizeof(TracerDef));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varTracerDef->name;
	Load_XString(false);

	varMaterialPtr = &varTracerDef->material;
	Load_MaterialPtr(false);

	DB_PopStreamPos();
}

void Load_TracerDefArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTracerDef, sizeof(TracerDef) * count);
	TracerDef* pointer = varTracerDef;
	for (int i = 0; i < count; i++)
	{
		varTracerDef = pointer;
		Load_TracerDef(false);
		pointer++;
	}
}

void Load_TracerDefAsset(TracerDef** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_TRACER, (void**)varTracerDefPtr);
}

void Load_TracerDefPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTracerDef, sizeof(TracerDef*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	TracerDef* pointer = *varTracerDefPtr;
	if (*varTracerDefPtr != nullptr)
	{
		if (*varTracerDefPtr == (TracerDef*)0xFFFFFFFF || *varTracerDefPtr == (TracerDef*)0xFFFFFFFE)
		{
			*varTracerDefPtr = AllocLoad_TracerDef();
			varTracerDef = *varTracerDefPtr;
			TracerDef** insertedPointer = nullptr;
			if (pointer == (TracerDef*)0xFFFFFFFE)
			{
				insertedPointer = (TracerDef**)DB_InsertPointer();
			}
			Load_TracerDef(true);
			Load_TracerDefAsset(varTracerDefPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varTracerDefPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varTracerDefPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_TracerDefPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTracerDefPtr, sizeof(TracerDef*) * count);
	TracerDef** pointer = varTracerDefPtr;
	for (int i = 0; i < count; i++)
	{
		varTracerDefPtr = pointer;
		Load_TracerDefPtr(false);
		pointer++;
	}
}

void Load_TriIndice(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriIndice, sizeof(TriIndice));

}

void Load_TriIndiceArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriIndice, sizeof(TriIndice) * count);
	TriIndice* pointer = varTriIndice;
	for (int i = 0; i < count; i++)
	{
		varTriIndice = pointer;
		Load_TriIndice(false);
		pointer++;
	}
}

void Load_TriIndicePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriIndice, sizeof(TriIndice));
	if (*varTriIndicePtr != nullptr)
	{
		if (*varTriIndicePtr == (TriIndice*)0xFFFFFFFF)
		{
			*varTriIndicePtr = AllocLoad_TriIndice();
			varTriIndice = *varTriIndicePtr;
			Load_TriIndice(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varTriIndicePtr);
		}
	}
}

void Load_TriIndicePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriIndicePtr, sizeof(TriIndice*) * count);
	TriIndice** pointer = varTriIndicePtr;
	for (int i = 0; i < count; i++)
	{
		varTriIndicePtr = pointer;
		Load_TriIndicePtr(false);
		pointer++;
	}
}

void Load_TriggerHull(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriggerHull, sizeof(TriggerHull));

	varBounds = &varTriggerHull->bounds;
	Load_Bounds(false);

}

void Load_TriggerHullArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriggerHull, sizeof(TriggerHull) * count);
	TriggerHull* pointer = varTriggerHull;
	for (int i = 0; i < count; i++)
	{
		varTriggerHull = pointer;
		Load_TriggerHull(false);
		pointer++;
	}
}

void Load_TriggerHullPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriggerHull, sizeof(TriggerHull));
	if (*varTriggerHullPtr != nullptr)
	{
		if (*varTriggerHullPtr == (TriggerHull*)0xFFFFFFFF)
		{
			*varTriggerHullPtr = AllocLoad_TriggerHull();
			varTriggerHull = *varTriggerHullPtr;
			Load_TriggerHull(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varTriggerHullPtr);
		}
	}
}

void Load_TriggerHullPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriggerHullPtr, sizeof(TriggerHull*) * count);
	TriggerHull** pointer = varTriggerHullPtr;
	for (int i = 0; i < count; i++)
	{
		varTriggerHullPtr = pointer;
		Load_TriggerHullPtr(false);
		pointer++;
	}
}

void Load_TriggerModel(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriggerModel, sizeof(TriggerModel));

}

void Load_TriggerModelArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriggerModel, sizeof(TriggerModel) * count);
	TriggerModel* pointer = varTriggerModel;
	for (int i = 0; i < count; i++)
	{
		varTriggerModel = pointer;
		Load_TriggerModel(false);
		pointer++;
	}
}

void Load_TriggerModelPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriggerModel, sizeof(TriggerModel));
	if (*varTriggerModelPtr != nullptr)
	{
		if (*varTriggerModelPtr == (TriggerModel*)0xFFFFFFFF)
		{
			*varTriggerModelPtr = AllocLoad_TriggerModel();
			varTriggerModel = *varTriggerModelPtr;
			Load_TriggerModel(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varTriggerModelPtr);
		}
	}
}

void Load_TriggerModelPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriggerModelPtr, sizeof(TriggerModel*) * count);
	TriggerModel** pointer = varTriggerModelPtr;
	for (int i = 0; i < count; i++)
	{
		varTriggerModelPtr = pointer;
		Load_TriggerModelPtr(false);
		pointer++;
	}
}

void Load_TriggerSlab(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriggerSlab, sizeof(TriggerSlab));

}

void Load_TriggerSlabArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriggerSlab, sizeof(TriggerSlab) * count);
	TriggerSlab* pointer = varTriggerSlab;
	for (int i = 0; i < count; i++)
	{
		varTriggerSlab = pointer;
		Load_TriggerSlab(false);
		pointer++;
	}
}

void Load_TriggerSlabPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varTriggerSlab, sizeof(TriggerSlab));
	if (*varTriggerSlabPtr != nullptr)
	{
		if (*varTriggerSlabPtr == (TriggerSlab*)0xFFFFFFFF)
		{
			*varTriggerSlabPtr = AllocLoad_TriggerSlab();
			varTriggerSlab = *varTriggerSlabPtr;
			Load_TriggerSlab(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varTriggerSlabPtr);
		}
	}
}

void Load_TriggerSlabPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varTriggerSlabPtr, sizeof(TriggerSlab*) * count);
	TriggerSlab** pointer = varTriggerSlabPtr;
	for (int i = 0; i < count; i++)
	{
		varTriggerSlabPtr = pointer;
		Load_TriggerSlabPtr(false);
		pointer++;
	}
}

void Load_UIFunctionList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varUIFunctionList, sizeof(UIFunctionList));

	if (varUIFunctionList->functions)
	{
		if (varUIFunctionList->functions == (Statement_s**)0xFFFFFFFF)
		{
			varUIFunctionList->functions = AllocLoad_Statement_sPtr();
			varStatement_sPtr = varUIFunctionList->functions;
			Load_Statement_sPtrArray(true, (varUIFunctionList->totalFunctions));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varUIFunctionList->functions);
		}
	}

}

void Load_UIFunctionListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varUIFunctionList, sizeof(UIFunctionList) * count);
	UIFunctionList* pointer = varUIFunctionList;
	for (int i = 0; i < count; i++)
	{
		varUIFunctionList = pointer;
		Load_UIFunctionList(false);
		pointer++;
	}
}

void Load_UIFunctionListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varUIFunctionList, sizeof(UIFunctionList));
	if (*varUIFunctionListPtr != nullptr)
	{
		if (*varUIFunctionListPtr == (UIFunctionList*)0xFFFFFFFF)
		{
			*varUIFunctionListPtr = AllocLoad_UIFunctionList();
			varUIFunctionList = *varUIFunctionListPtr;
			Load_UIFunctionList(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varUIFunctionListPtr);
		}
	}
}

void Load_UIFunctionListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varUIFunctionListPtr, sizeof(UIFunctionList*) * count);
	UIFunctionList** pointer = varUIFunctionListPtr;
	for (int i = 0; i < count; i++)
	{
		varUIFunctionListPtr = pointer;
		Load_UIFunctionListPtr(false);
		pointer++;
	}
}

void Load_WaterWritable(bool atStreamStart)
{
	Load_Stream(atStreamStart, varWaterWritable, sizeof(WaterWritable));

}

void Load_WaterWritableArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varWaterWritable, sizeof(WaterWritable) * count);
	WaterWritable* pointer = varWaterWritable;
	for (int i = 0; i < count; i++)
	{
		varWaterWritable = pointer;
		Load_WaterWritable(false);
		pointer++;
	}
}

void Load_WaterWritablePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varWaterWritable, sizeof(WaterWritable));
	if (*varWaterWritablePtr != nullptr)
	{
		*varWaterWritablePtr = AllocLoad_WaterWritable();
		varWaterWritable = *varWaterWritablePtr;
		Load_WaterWritable(true);
	}
}

void Load_WaterWritablePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varWaterWritablePtr, sizeof(WaterWritable*) * count);
	WaterWritable** pointer = varWaterWritablePtr;
	for (int i = 0; i < count; i++)
	{
		varWaterWritablePtr = pointer;
		Load_WaterWritablePtr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPart(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPart, sizeof(XAnimDeltaPart));

	if (varXAnimDeltaPart->trans)
	{
		varXAnimPartTransPtr = &varXAnimDeltaPart->trans;
		Load_XAnimPartTransPtr(false);
	}

	if (varXAnimDeltaPart->quat2)
	{
		varXAnimDeltaPartQuat2Ptr = &varXAnimDeltaPart->quat2;
		Load_XAnimDeltaPartQuat2Ptr(false);
	}

	if (varXAnimDeltaPart->quat)
	{
		varXAnimDeltaPartQuatPtr = &varXAnimDeltaPart->quat;
		Load_XAnimDeltaPartQuatPtr(false);
	}

}

void Load_XAnimDeltaPartArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPart, sizeof(XAnimDeltaPart) * count);
	XAnimDeltaPart* pointer = varXAnimDeltaPart;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPart = pointer;
		Load_XAnimDeltaPart(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPart, sizeof(XAnimDeltaPart));
	if (*varXAnimDeltaPartPtr != nullptr)
	{
		if (*varXAnimDeltaPartPtr == (XAnimDeltaPart*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartPtr = AllocLoad_XAnimDeltaPart();
			varXAnimDeltaPart = *varXAnimDeltaPartPtr;
			Load_XAnimDeltaPart(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartPtr);
		}
	}
}

void Load_XAnimDeltaPartPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartPtr, sizeof(XAnimDeltaPart*) * count);
	XAnimDeltaPart** pointer = varXAnimDeltaPartPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartPtr = pointer;
		Load_XAnimDeltaPartPtr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuat(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat, sizeof(XAnimDeltaPartQuat));

	varXAnimDeltaPartQuatData = &varXAnimDeltaPartQuat->u;
	Load_XAnimDeltaPartQuatData(false);

}

void Load_XAnimDeltaPartQuat2(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat2, sizeof(XAnimDeltaPartQuat2));

	varXAnimDeltaPartQuatData2 = &varXAnimDeltaPartQuat2->u;
	Load_XAnimDeltaPartQuatData2(false);

}

void Load_XAnimDeltaPartQuat2Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat2, sizeof(XAnimDeltaPartQuat2) * count);
	XAnimDeltaPartQuat2* pointer = varXAnimDeltaPartQuat2;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuat2 = pointer;
		Load_XAnimDeltaPartQuat2(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuat2Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat2, sizeof(XAnimDeltaPartQuat2));
	if (*varXAnimDeltaPartQuat2Ptr != nullptr)
	{
		if (*varXAnimDeltaPartQuat2Ptr == (XAnimDeltaPartQuat2*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartQuat2Ptr = AllocLoad_XAnimDeltaPartQuat2();
			varXAnimDeltaPartQuat2 = *varXAnimDeltaPartQuat2Ptr;
			Load_XAnimDeltaPartQuat2(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartQuat2Ptr);
		}
	}
}

void Load_XAnimDeltaPartQuat2PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat2Ptr, sizeof(XAnimDeltaPartQuat2*) * count);
	XAnimDeltaPartQuat2** pointer = varXAnimDeltaPartQuat2Ptr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuat2Ptr = pointer;
		Load_XAnimDeltaPartQuat2Ptr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat, sizeof(XAnimDeltaPartQuat) * count);
	XAnimDeltaPartQuat* pointer = varXAnimDeltaPartQuat;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuat = pointer;
		Load_XAnimDeltaPartQuat(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData, sizeof(XAnimDeltaPartQuatData));

}

void Load_XAnimDeltaPartQuatData2(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData2, sizeof(XAnimDeltaPartQuatData2));

}

void Load_XAnimDeltaPartQuatData2Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData2, sizeof(XAnimDeltaPartQuatData2) * count);
	XAnimDeltaPartQuatData2* pointer = varXAnimDeltaPartQuatData2;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatData2 = pointer;
		Load_XAnimDeltaPartQuatData2(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatData2Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData2, sizeof(XAnimDeltaPartQuatData2));
	if (*varXAnimDeltaPartQuatData2Ptr != nullptr)
	{
		if (*varXAnimDeltaPartQuatData2Ptr == (XAnimDeltaPartQuatData2*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartQuatData2Ptr = AllocLoad_XAnimDeltaPartQuatData2();
			varXAnimDeltaPartQuatData2 = *varXAnimDeltaPartQuatData2Ptr;
			Load_XAnimDeltaPartQuatData2(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartQuatData2Ptr);
		}
	}
}

void Load_XAnimDeltaPartQuatData2PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData2Ptr, sizeof(XAnimDeltaPartQuatData2*) * count);
	XAnimDeltaPartQuatData2** pointer = varXAnimDeltaPartQuatData2Ptr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatData2Ptr = pointer;
		Load_XAnimDeltaPartQuatData2Ptr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData, sizeof(XAnimDeltaPartQuatData) * count);
	XAnimDeltaPartQuatData* pointer = varXAnimDeltaPartQuatData;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatData = pointer;
		Load_XAnimDeltaPartQuatData(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatDataFrames(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames, sizeof(XAnimDeltaPartQuatDataFrames));

	if (varXAnimDeltaPartQuatDataFrames->frames4)
	{
		varint64Ptr = &varXAnimDeltaPartQuatDataFrames->frames4;
		Load_int64Ptr(false);
	}

	varXAnimDynamicIndices = &varXAnimDeltaPartQuatDataFrames->indices;
	Load_XAnimDynamicIndices(false);

}

void Load_XAnimDeltaPartQuatDataFrames2(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames2, sizeof(XAnimDeltaPartQuatDataFrames2));

	if (varXAnimDeltaPartQuatDataFrames2->frames)
	{
		varint32Ptr = &varXAnimDeltaPartQuatDataFrames2->frames;
		Load_int32Ptr(false);
	}

	varXAnimDynamicIndices = &varXAnimDeltaPartQuatDataFrames2->indices;
	Load_XAnimDynamicIndices(false);

}

void Load_XAnimDeltaPartQuatDataFrames2Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames2, sizeof(XAnimDeltaPartQuatDataFrames2) * count);
	XAnimDeltaPartQuatDataFrames2* pointer = varXAnimDeltaPartQuatDataFrames2;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatDataFrames2 = pointer;
		Load_XAnimDeltaPartQuatDataFrames2(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatDataFrames2Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames2, sizeof(XAnimDeltaPartQuatDataFrames2));
	if (*varXAnimDeltaPartQuatDataFrames2Ptr != nullptr)
	{
		if (*varXAnimDeltaPartQuatDataFrames2Ptr == (XAnimDeltaPartQuatDataFrames2*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartQuatDataFrames2Ptr = AllocLoad_XAnimDeltaPartQuatDataFrames2();
			varXAnimDeltaPartQuatDataFrames2 = *varXAnimDeltaPartQuatDataFrames2Ptr;
			Load_XAnimDeltaPartQuatDataFrames2(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartQuatDataFrames2Ptr);
		}
	}
}

void Load_XAnimDeltaPartQuatDataFrames2PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames2Ptr, sizeof(XAnimDeltaPartQuatDataFrames2*) * count);
	XAnimDeltaPartQuatDataFrames2** pointer = varXAnimDeltaPartQuatDataFrames2Ptr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatDataFrames2Ptr = pointer;
		Load_XAnimDeltaPartQuatDataFrames2Ptr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatDataFramesArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames, sizeof(XAnimDeltaPartQuatDataFrames) * count);
	XAnimDeltaPartQuatDataFrames* pointer = varXAnimDeltaPartQuatDataFrames;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatDataFrames = pointer;
		Load_XAnimDeltaPartQuatDataFrames(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatDataFramesPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFrames, sizeof(XAnimDeltaPartQuatDataFrames));
	if (*varXAnimDeltaPartQuatDataFramesPtr != nullptr)
	{
		if (*varXAnimDeltaPartQuatDataFramesPtr == (XAnimDeltaPartQuatDataFrames*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartQuatDataFramesPtr = AllocLoad_XAnimDeltaPartQuatDataFrames();
			varXAnimDeltaPartQuatDataFrames = *varXAnimDeltaPartQuatDataFramesPtr;
			Load_XAnimDeltaPartQuatDataFrames(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartQuatDataFramesPtr);
		}
	}
}

void Load_XAnimDeltaPartQuatDataFramesPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataFramesPtr, sizeof(XAnimDeltaPartQuatDataFrames*) * count);
	XAnimDeltaPartQuatDataFrames** pointer = varXAnimDeltaPartQuatDataFramesPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatDataFramesPtr = pointer;
		Load_XAnimDeltaPartQuatDataFramesPtr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatData, sizeof(XAnimDeltaPartQuatData));
	if (*varXAnimDeltaPartQuatDataPtr != nullptr)
	{
		if (*varXAnimDeltaPartQuatDataPtr == (XAnimDeltaPartQuatData*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartQuatDataPtr = AllocLoad_XAnimDeltaPartQuatData();
			varXAnimDeltaPartQuatData = *varXAnimDeltaPartQuatDataPtr;
			Load_XAnimDeltaPartQuatData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartQuatDataPtr);
		}
	}
}

void Load_XAnimDeltaPartQuatDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatDataPtr, sizeof(XAnimDeltaPartQuatData*) * count);
	XAnimDeltaPartQuatData** pointer = varXAnimDeltaPartQuatDataPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatDataPtr = pointer;
		Load_XAnimDeltaPartQuatDataPtr(false);
		pointer++;
	}
}

void Load_XAnimDeltaPartQuatPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuat, sizeof(XAnimDeltaPartQuat));
	if (*varXAnimDeltaPartQuatPtr != nullptr)
	{
		if (*varXAnimDeltaPartQuatPtr == (XAnimDeltaPartQuat*)0xFFFFFFFF)
		{
			*varXAnimDeltaPartQuatPtr = AllocLoad_XAnimDeltaPartQuat();
			varXAnimDeltaPartQuat = *varXAnimDeltaPartQuatPtr;
			Load_XAnimDeltaPartQuat(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDeltaPartQuatPtr);
		}
	}
}

void Load_XAnimDeltaPartQuatPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDeltaPartQuatPtr, sizeof(XAnimDeltaPartQuat*) * count);
	XAnimDeltaPartQuat** pointer = varXAnimDeltaPartQuatPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDeltaPartQuatPtr = pointer;
		Load_XAnimDeltaPartQuatPtr(false);
		pointer++;
	}
}

void Load_XAnimDynamicFrames(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDynamicFrames, sizeof(XAnimDynamicFrames));

}

void Load_XAnimDynamicFramesArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDynamicFrames, sizeof(XAnimDynamicFrames) * count);
	XAnimDynamicFrames* pointer = varXAnimDynamicFrames;
	for (int i = 0; i < count; i++)
	{
		varXAnimDynamicFrames = pointer;
		Load_XAnimDynamicFrames(false);
		pointer++;
	}
}

void Load_XAnimDynamicFramesPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDynamicFrames, sizeof(XAnimDynamicFrames));
	if (*varXAnimDynamicFramesPtr != nullptr)
	{
		if (*varXAnimDynamicFramesPtr == (XAnimDynamicFrames*)0xFFFFFFFF)
		{
			*varXAnimDynamicFramesPtr = AllocLoad_XAnimDynamicFrames();
			varXAnimDynamicFrames = *varXAnimDynamicFramesPtr;
			Load_XAnimDynamicFrames(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDynamicFramesPtr);
		}
	}
}

void Load_XAnimDynamicFramesPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDynamicFramesPtr, sizeof(XAnimDynamicFrames*) * count);
	XAnimDynamicFrames** pointer = varXAnimDynamicFramesPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDynamicFramesPtr = pointer;
		Load_XAnimDynamicFramesPtr(false);
		pointer++;
	}
}

void Load_XAnimDynamicIndices(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDynamicIndices, sizeof(XAnimDynamicIndices));

}

void Load_XAnimDynamicIndicesArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDynamicIndices, sizeof(XAnimDynamicIndices) * count);
	XAnimDynamicIndices* pointer = varXAnimDynamicIndices;
	for (int i = 0; i < count; i++)
	{
		varXAnimDynamicIndices = pointer;
		Load_XAnimDynamicIndices(false);
		pointer++;
	}
}

void Load_XAnimDynamicIndicesPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimDynamicIndices, sizeof(XAnimDynamicIndices));
	if (*varXAnimDynamicIndicesPtr != nullptr)
	{
		if (*varXAnimDynamicIndicesPtr == (XAnimDynamicIndices*)0xFFFFFFFF)
		{
			*varXAnimDynamicIndicesPtr = AllocLoad_XAnimDynamicIndices();
			varXAnimDynamicIndices = *varXAnimDynamicIndicesPtr;
			Load_XAnimDynamicIndices(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimDynamicIndicesPtr);
		}
	}
}

void Load_XAnimDynamicIndicesPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimDynamicIndicesPtr, sizeof(XAnimDynamicIndices*) * count);
	XAnimDynamicIndices** pointer = varXAnimDynamicIndicesPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimDynamicIndicesPtr = pointer;
		Load_XAnimDynamicIndicesPtr(false);
		pointer++;
	}
}

void Load_XAnimIndices(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimIndices, sizeof(XAnimIndices));

}

void Load_XAnimIndicesArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimIndices, sizeof(XAnimIndices) * count);
	XAnimIndices* pointer = varXAnimIndices;
	for (int i = 0; i < count; i++)
	{
		varXAnimIndices = pointer;
		Load_XAnimIndices(false);
		pointer++;
	}
}

void Load_XAnimIndicesPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimIndices, sizeof(XAnimIndices));
	if (*varXAnimIndicesPtr != nullptr)
	{
		if (*varXAnimIndicesPtr == (XAnimIndices*)0xFFFFFFFF)
		{
			*varXAnimIndicesPtr = AllocLoad_XAnimIndices();
			varXAnimIndices = *varXAnimIndicesPtr;
			Load_XAnimIndices(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimIndicesPtr);
		}
	}
}

void Load_XAnimIndicesPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimIndicesPtr, sizeof(XAnimIndices*) * count);
	XAnimIndices** pointer = varXAnimIndicesPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimIndicesPtr = pointer;
		Load_XAnimIndicesPtr(false);
		pointer++;
	}
}

void Load_XAnimNotifyInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimNotifyInfo, sizeof(XAnimNotifyInfo));

}

void Load_XAnimNotifyInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimNotifyInfo, sizeof(XAnimNotifyInfo) * count);
	XAnimNotifyInfo* pointer = varXAnimNotifyInfo;
	for (int i = 0; i < count; i++)
	{
		varXAnimNotifyInfo = pointer;
		Load_XAnimNotifyInfo(false);
		pointer++;
	}
}

void Load_XAnimNotifyInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimNotifyInfo, sizeof(XAnimNotifyInfo));
	if (*varXAnimNotifyInfoPtr != nullptr)
	{
		if (*varXAnimNotifyInfoPtr == (XAnimNotifyInfo*)0xFFFFFFFF)
		{
			*varXAnimNotifyInfoPtr = AllocLoad_XAnimNotifyInfo();
			varXAnimNotifyInfo = *varXAnimNotifyInfoPtr;
			Load_XAnimNotifyInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimNotifyInfoPtr);
		}
	}
}

void Load_XAnimNotifyInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimNotifyInfoPtr, sizeof(XAnimNotifyInfo*) * count);
	XAnimNotifyInfo** pointer = varXAnimNotifyInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimNotifyInfoPtr = pointer;
		Load_XAnimNotifyInfoPtr(false);
		pointer++;
	}
}

void Load_XAnimPartTrans(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimPartTrans, sizeof(XAnimPartTrans));

	varXAnimPartTransData = &varXAnimPartTrans->u;
	Load_XAnimPartTransData(false);

}

void Load_XAnimPartTransArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartTrans, sizeof(XAnimPartTrans) * count);
	XAnimPartTrans* pointer = varXAnimPartTrans;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartTrans = pointer;
		Load_XAnimPartTrans(false);
		pointer++;
	}
}

void Load_XAnimPartTransData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimPartTransData, sizeof(XAnimPartTransData));

}

void Load_XAnimPartTransDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartTransData, sizeof(XAnimPartTransData) * count);
	XAnimPartTransData* pointer = varXAnimPartTransData;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartTransData = pointer;
		Load_XAnimPartTransData(false);
		pointer++;
	}
}

void Load_XAnimPartTransDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimPartTransData, sizeof(XAnimPartTransData));
	if (*varXAnimPartTransDataPtr != nullptr)
	{
		if (*varXAnimPartTransDataPtr == (XAnimPartTransData*)0xFFFFFFFF)
		{
			*varXAnimPartTransDataPtr = AllocLoad_XAnimPartTransData();
			varXAnimPartTransData = *varXAnimPartTransDataPtr;
			Load_XAnimPartTransData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimPartTransDataPtr);
		}
	}
}

void Load_XAnimPartTransDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartTransDataPtr, sizeof(XAnimPartTransData*) * count);
	XAnimPartTransData** pointer = varXAnimPartTransDataPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartTransDataPtr = pointer;
		Load_XAnimPartTransDataPtr(false);
		pointer++;
	}
}

void Load_XAnimPartTransFrames(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimPartTransFrames, sizeof(XAnimPartTransFrames));

	varXAnimDynamicFrames = &varXAnimPartTransFrames->frames;
	Load_XAnimDynamicFrames(false);

	varXAnimDynamicIndices = &varXAnimPartTransFrames->indices;
	Load_XAnimDynamicIndices(false);

}

void Load_XAnimPartTransFramesArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartTransFrames, sizeof(XAnimPartTransFrames) * count);
	XAnimPartTransFrames* pointer = varXAnimPartTransFrames;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartTransFrames = pointer;
		Load_XAnimPartTransFrames(false);
		pointer++;
	}
}

void Load_XAnimPartTransFramesPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimPartTransFrames, sizeof(XAnimPartTransFrames));
	if (*varXAnimPartTransFramesPtr != nullptr)
	{
		if (*varXAnimPartTransFramesPtr == (XAnimPartTransFrames*)0xFFFFFFFF)
		{
			*varXAnimPartTransFramesPtr = AllocLoad_XAnimPartTransFrames();
			varXAnimPartTransFrames = *varXAnimPartTransFramesPtr;
			Load_XAnimPartTransFrames(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimPartTransFramesPtr);
		}
	}
}

void Load_XAnimPartTransFramesPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartTransFramesPtr, sizeof(XAnimPartTransFrames*) * count);
	XAnimPartTransFrames** pointer = varXAnimPartTransFramesPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartTransFramesPtr = pointer;
		Load_XAnimPartTransFramesPtr(false);
		pointer++;
	}
}

void Load_XAnimPartTransPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimPartTrans, sizeof(XAnimPartTrans));
	if (*varXAnimPartTransPtr != nullptr)
	{
		if (*varXAnimPartTransPtr == (XAnimPartTrans*)0xFFFFFFFF)
		{
			*varXAnimPartTransPtr = AllocLoad_XAnimPartTrans();
			varXAnimPartTrans = *varXAnimPartTransPtr;
			Load_XAnimPartTrans(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAnimPartTransPtr);
		}
	}
}

void Load_XAnimPartTransPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartTransPtr, sizeof(XAnimPartTrans*) * count);
	XAnimPartTrans** pointer = varXAnimPartTransPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartTransPtr = pointer;
		Load_XAnimPartTransPtr(false);
		pointer++;
	}
}

void Load_XAnimParts(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimParts, sizeof(XAnimParts));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varXAnimParts->name;
	Load_XString(false);

	if (varXAnimParts->names)
	{
		if (varXAnimParts->names == (uint16*)0xFFFFFFFF)
		{
			varXAnimParts->names = AllocLoad_uint16();
			varuint16 = varXAnimParts->names;
			Load_uint16Array(true, (varXAnimParts->boneCount[9]));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAnimParts->names);
		}
	}

	if (varXAnimParts->notify)
	{
		if (varXAnimParts->notify == (XAnimNotifyInfo*)0xFFFFFFFF)
		{
			varXAnimParts->notify = AllocLoad_XAnimNotifyInfo();
			varXAnimNotifyInfo = varXAnimParts->notify;
			Load_XAnimNotifyInfoArray(true, (varXAnimParts->notifyCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAnimParts->notify);
		}
	}

	if (varXAnimParts->deltaPart)
	{
		varXAnimDeltaPartPtr = &varXAnimParts->deltaPart;
		Load_XAnimDeltaPartPtr(false);
	}

	if (varXAnimParts->dataByte)
	{
		if (varXAnimParts->dataByte == (char*)0xFFFFFFFF)
		{
			varXAnimParts->dataByte = AllocLoad_char();
			varchar = varXAnimParts->dataByte;
			Load_charArray(true, (varXAnimParts->dataByteCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAnimParts->dataByte);
		}
	}

	if (varXAnimParts->dataShort)
	{
		if (varXAnimParts->dataShort == (int16*)0xFFFFFFFF)
		{
			varXAnimParts->dataShort = AllocLoad_int16();
			varint16 = varXAnimParts->dataShort;
			Load_int16Array(true, (varXAnimParts->dataShortCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAnimParts->dataShort);
		}
	}

	if (varXAnimParts->randomDataShort)
	{
		if (varXAnimParts->randomDataShort == (int16*)0xFFFFFFFF)
		{
			varXAnimParts->randomDataShort = AllocLoad_int16();
			varint16 = varXAnimParts->randomDataShort;
			Load_int16Array(true, (varXAnimParts->randomDataShortCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAnimParts->randomDataShort);
		}
	}

	if (varXAnimParts->randomDataByte)
	{
		if (varXAnimParts->randomDataByte == (char*)0xFFFFFFFF)
		{
			varXAnimParts->randomDataByte = AllocLoad_char();
			varchar = varXAnimParts->randomDataByte;
			Load_charArray(true, (varXAnimParts->randomDataByteCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAnimParts->randomDataByte);
		}
	}

	varXAnimIndices = &varXAnimParts->indices;
	Load_XAnimIndices(false);

	DB_PopStreamPos();
}

void Load_XAnimPartsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimParts, sizeof(XAnimParts) * count);
	XAnimParts* pointer = varXAnimParts;
	for (int i = 0; i < count; i++)
	{
		varXAnimParts = pointer;
		Load_XAnimParts(false);
		pointer++;
	}
}

void Load_XAnimPartsAsset(XAnimParts** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_XANIMPARTS, (void**)varXAnimPartsPtr);
}

void Load_XAnimPartsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAnimParts, sizeof(XAnimParts*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	XAnimParts* pointer = *varXAnimPartsPtr;
	if (*varXAnimPartsPtr != nullptr)
	{
		if (*varXAnimPartsPtr == (XAnimParts*)0xFFFFFFFF || *varXAnimPartsPtr == (XAnimParts*)0xFFFFFFFE)
		{
			*varXAnimPartsPtr = AllocLoad_XAnimParts();
			varXAnimParts = *varXAnimPartsPtr;
			XAnimParts** insertedPointer = nullptr;
			if (pointer == (XAnimParts*)0xFFFFFFFE)
			{
				insertedPointer = (XAnimParts**)DB_InsertPointer();
			}
			Load_XAnimParts(true);
			Load_XAnimPartsAsset(varXAnimPartsPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varXAnimPartsPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varXAnimPartsPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_XAnimPartsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAnimPartsPtr, sizeof(XAnimParts*) * count);
	XAnimParts** pointer = varXAnimPartsPtr;
	for (int i = 0; i < count; i++)
	{
		varXAnimPartsPtr = pointer;
		Load_XAnimPartsPtr(false);
		pointer++;
	}
}

void Load_XAsset(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAsset, sizeof(XAsset));

	varXAssetHeader = &varXAsset->asset;
	Load_XAssetHeader(false);

}

void Load_XAssetArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAsset, sizeof(XAsset) * count);
	XAsset* pointer = varXAsset;
	for (int i = 0; i < count; i++)
	{
		varXAsset = pointer;
		Load_XAsset(false);
		pointer++;
	}
}

void Load_XAssetHeader(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAssetHeader, sizeof(XAssetHeader));

	switch (varXAsset->type)
	{
	case XAssetType::ASSET_TYPE_PHYSPRESET:
		varPhysPresetPtr = &varXAssetHeader->physPreset;
		Load_PhysPresetPtr(false);
		break;
	case XAssetType::ASSET_TYPE_PHYSCOLLMAP:
		varPhysCollmapPtr = &varXAssetHeader->physCollmap;
		Load_PhysCollmapPtr(false);
		break;
	case XAssetType::ASSET_TYPE_XANIMPARTS:
		varXAnimPartsPtr = &varXAssetHeader->parts;
		Load_XAnimPartsPtr(false);
		break;
	case XAssetType::ASSET_TYPE_XMODEL_SURFS:
		varXModelSurfsPtr = &varXAssetHeader->modelSurfs;
		Load_XModelSurfsPtr(false);
		break;
	case XAssetType::ASSET_TYPE_XMODEL:
		varXModelPtr = &varXAssetHeader->xmodel;
		Load_XModelPtr(false);
		break;
	case XAssetType::ASSET_TYPE_MATERIAL:
		varMaterialPtr = &varXAssetHeader->material;
		Load_MaterialPtr(false);
		break;
	case XAssetType::ASSET_TYPE_PIXELSHADER:
		varMaterialPixelShaderPtr = &varXAssetHeader->pixelShader;
		Load_MaterialPixelShaderPtr(false);
		break;
	case XAssetType::ASSET_TYPE_VERTEXSHADER:
		varMaterialVertexShaderPtr = &varXAssetHeader->vertexShader;
		Load_MaterialVertexShaderPtr(false);
		break;
	case XAssetType::ASSET_TYPE_VERTEXDECL:
		varMaterialVertexDeclarationPtr = &varXAssetHeader->vertexDecl;
		Load_MaterialVertexDeclarationPtr(false);
		break;
	case XAssetType::ASSET_TYPE_TECHNIQUE_SET:
		varMaterialTechniqueSetPtr = &varXAssetHeader->techset;
		Load_MaterialTechniqueSetPtr(false);
		break;
	case XAssetType::ASSET_TYPE_IMAGE:
		varGfxImagePtr = &varXAssetHeader->image;
		Load_GfxImagePtr(false);
		break;
	case XAssetType::ASSET_TYPE_SOUND:
		varsnd_alias_list_tPtr = &varXAssetHeader->sound;
		Load_snd_alias_list_tPtr(false);
		break;
	case XAssetType::ASSET_TYPE_SOUND_CURVE:
		varSndCurvePtr = &varXAssetHeader->sndCurve;
		Load_SndCurvePtr(false);
		break;
	case XAssetType::ASSET_TYPE_FX:
		varFxEffectDefPtr = &varXAssetHeader->fxEffectDef;
		Load_FxEffectDefPtr(false);
		break;
	case XAssetType::ASSET_TYPE_CLIPMAP_MP:
		varclipMap_tPtr = &varXAssetHeader->clipMap;
		Load_clipMap_tPtr(false);
		break;
	case XAssetType::ASSET_TYPE_COMWORLD:
		varComWorldPtr = &varXAssetHeader->comWorld;
		Load_ComWorldPtr(false);
		break;
	case XAssetType::ASSET_TYPE_GAMEWORLD_MP:
		varGameWorldMpPtr = &varXAssetHeader->gameWorldMp;
		Load_GameWorldMpPtr(false);
		break;
	case XAssetType::ASSET_TYPE_MAP_ENTS:
		varMapEntsPtr = &varXAssetHeader->mapEnts;
		Load_MapEntsPtr(false);
		break;
	case XAssetType::ASSET_TYPE_FXWORLD:
		varFxWorldPtr = &varXAssetHeader->fxWorld;
		Load_FxWorldPtr(false);
		break;
	case XAssetType::ASSET_TYPE_LIGHT_DEF:
		varGfxLightDefPtr = &varXAssetHeader->lightDef;
		Load_GfxLightDefPtr(false);
		break;
	case XAssetType::ASSET_TYPE_FONT:
		varFont_sPtr = &varXAssetHeader->font;
		Load_Font_sPtr(false);
		break;
	case XAssetType::ASSET_TYPE_MENULIST:
		varMenuListPtr = &varXAssetHeader->menuList;
		Load_MenuListPtr(false);
		break;
	case XAssetType::ASSET_TYPE_MENU:
		varmenuDef_tPtr = &varXAssetHeader->menu;
		Load_menuDef_tPtr(false);
		break;
	case XAssetType::ASSET_TYPE_LOCALIZE_ENTRY:
		varLocalizeEntryPtr = &varXAssetHeader->localizeEntry;
		Load_LocalizeEntryPtr(false);
		break;
	case XAssetType::ASSET_TYPE_RAWFILE:
		varRawFilePtr = &varXAssetHeader->rawFile;
		Load_RawFilePtr(false);
		break;
	case XAssetType::ASSET_TYPE_STRINGTABLE:
		varStringTablePtr = &varXAssetHeader->stringTable;
		Load_StringTablePtr(false);
		break;
	case XAssetType::ASSET_TYPE_LEADERBOARD:
		varLeaderboardDefPtr = &varXAssetHeader->leaderboardDef;
		Load_LeaderboardDefPtr(false);
		break;
	case XAssetType::ASSET_TYPE_STRUCTURED_DATA_DEF:
		varStructuredDataDefSetPtr = &varXAssetHeader->structuredDataDefSet;
		Load_StructuredDataDefSetPtr(false);
		break;
	case XAssetType::ASSET_TYPE_TRACER:
		varTracerDefPtr = &varXAssetHeader->tracerDef;
		Load_TracerDefPtr(false);
		break;
	case XAssetType::ASSET_TYPE_ASSETLIST:
		varXAssetListPtr = &varXAssetHeader->assetList;
		Load_XAssetListPtr(false);
		break;
	}
}

void Load_XAssetHeaderArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAssetHeader, sizeof(XAssetHeader) * count);
	XAssetHeader* pointer = varXAssetHeader;
	for (int i = 0; i < count; i++)
	{
		varXAssetHeader = pointer;
		Load_XAssetHeader(false);
		pointer++;
	}
}

void Load_XAssetHeaderPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAssetHeader, sizeof(XAssetHeader));
	if (*varXAssetHeaderPtr != nullptr)
	{
		if (*varXAssetHeaderPtr == (XAssetHeader*)0xFFFFFFFF)
		{
			*varXAssetHeaderPtr = AllocLoad_XAssetHeader();
			varXAssetHeader = *varXAssetHeaderPtr;
			Load_XAssetHeader(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAssetHeaderPtr);
		}
	}
}

void Load_XAssetHeaderPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAssetHeaderPtr, sizeof(XAssetHeader*) * count);
	XAssetHeader** pointer = varXAssetHeaderPtr;
	for (int i = 0; i < count; i++)
	{
		varXAssetHeaderPtr = pointer;
		Load_XAssetHeaderPtr(false);
		pointer++;
	}
}

void Load_XAssetList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAssetList, sizeof(XAssetList));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varScriptStringList = &varXAssetList->stringList;
	Load_ScriptStringList(false);

	if (varXAssetList->assets)
	{
		if (varXAssetList->assets == (XAsset*)0xFFFFFFFF)
		{
			varXAssetList->assets = AllocLoad_XAsset();
			varXAsset = varXAssetList->assets;
			Load_XAssetArray(true, (varXAssetList->assetCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXAssetList->assets);
		}
	}

	DB_PopStreamPos();
}

void Load_XAssetListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAssetList, sizeof(XAssetList) * count);
	XAssetList* pointer = varXAssetList;
	for (int i = 0; i < count; i++)
	{
		varXAssetList = pointer;
		Load_XAssetList(false);
		pointer++;
	}
}

void Load_XAssetListAsset(XAssetList** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_ASSETLIST, (void**)varXAssetListPtr);
}

void Load_XAssetListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAssetList, sizeof(XAssetList*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	XAssetList* pointer = *varXAssetListPtr;
	if (*varXAssetListPtr != nullptr)
	{
		if (*varXAssetListPtr == (XAssetList*)0xFFFFFFFF || *varXAssetListPtr == (XAssetList*)0xFFFFFFFE)
		{
			*varXAssetListPtr = AllocLoad_XAssetList();
			varXAssetList = *varXAssetListPtr;
			XAssetList** insertedPointer = nullptr;
			if (pointer == (XAssetList*)0xFFFFFFFE)
			{
				insertedPointer = (XAssetList**)DB_InsertPointer();
			}
			Load_XAssetList(true);
			Load_XAssetListAsset(varXAssetListPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varXAssetListPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varXAssetListPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_XAssetListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAssetListPtr, sizeof(XAssetList*) * count);
	XAssetList** pointer = varXAssetListPtr;
	for (int i = 0; i < count; i++)
	{
		varXAssetListPtr = pointer;
		Load_XAssetListPtr(false);
		pointer++;
	}
}

void Load_XAssetPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXAsset, sizeof(XAsset));
	if (*varXAssetPtr != nullptr)
	{
		if (*varXAssetPtr == (XAsset*)0xFFFFFFFF)
		{
			*varXAssetPtr = AllocLoad_XAsset();
			varXAsset = *varXAssetPtr;
			Load_XAsset(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXAssetPtr);
		}
	}
}

void Load_XAssetPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXAssetPtr, sizeof(XAsset*) * count);
	XAsset** pointer = varXAssetPtr;
	for (int i = 0; i < count; i++)
	{
		varXAssetPtr = pointer;
		Load_XAssetPtr(false);
		pointer++;
	}
}

void Load_XBoneInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXBoneInfo, sizeof(XBoneInfo));

	varBounds = &varXBoneInfo->bounds;
	Load_Bounds(false);

}

void Load_XBoneInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXBoneInfo, sizeof(XBoneInfo) * count);
	XBoneInfo* pointer = varXBoneInfo;
	for (int i = 0; i < count; i++)
	{
		varXBoneInfo = pointer;
		Load_XBoneInfo(false);
		pointer++;
	}
}

void Load_XBoneInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXBoneInfo, sizeof(XBoneInfo));
	if (*varXBoneInfoPtr != nullptr)
	{
		if (*varXBoneInfoPtr == (XBoneInfo*)0xFFFFFFFF)
		{
			*varXBoneInfoPtr = AllocLoad_XBoneInfo();
			varXBoneInfo = *varXBoneInfoPtr;
			Load_XBoneInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXBoneInfoPtr);
		}
	}
}

void Load_XBoneInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXBoneInfoPtr, sizeof(XBoneInfo*) * count);
	XBoneInfo** pointer = varXBoneInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varXBoneInfoPtr = pointer;
		Load_XBoneInfoPtr(false);
		pointer++;
	}
}

void Load_XModel(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModel, sizeof(XModel));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varXModel->name;
	Load_XString(false);

	if (varXModel->boneNames)
	{
		if (varXModel->boneNames == (uint16*)0xFFFFFFFF)
		{
			varXModel->boneNames = AllocLoad_uint16();
			varuint16 = varXModel->boneNames;
			Load_uint16Array(true, (varXModel->numBones));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->boneNames);
		}
	}

	if (varXModel->parentList)
	{
		if (varXModel->parentList == (char*)0xFFFFFFFF)
		{
			varXModel->parentList = AllocLoad_char();
			varchar = varXModel->parentList;
			Load_charArray(true, (varXModel->numBones - varXModel->numRootBones));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->parentList);
		}
	}

	if (varXModel->quats)
	{
		if (varXModel->quats == (int16*)0xFFFFFFFF)
		{
			varXModel->quats = AllocLoad_int16();
			varint16 = varXModel->quats;
			Load_int16Array(true, (4 * (varXModel->numBones - varXModel->numRootBones)));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->quats);
		}
	}

	if (varXModel->trans)
	{
		if (varXModel->trans == (float*)0xFFFFFFFF)
		{
			varXModel->trans = AllocLoad_float();
			varfloat = varXModel->trans;
			Load_floatArray(true, (3 * (varXModel->numBones - varXModel->numRootBones)));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->trans);
		}
	}

	if (varXModel->partClassification)
	{
		if (varXModel->partClassification == (char*)0xFFFFFFFF)
		{
			varXModel->partClassification = AllocLoad_char();
			varchar = varXModel->partClassification;
			Load_charArray(true, (varXModel->numBones));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->partClassification);
		}
	}

	if (varXModel->baseMat)
	{
		if (varXModel->baseMat == (DObjAnimMat*)0xFFFFFFFF)
		{
			varXModel->baseMat = AllocLoad_DObjAnimMat();
			varDObjAnimMat = varXModel->baseMat;
			Load_DObjAnimMatArray(true, (varXModel->numBones));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->baseMat);
		}
	}

	if (varXModel->materialHandles)
	{
		if (varXModel->materialHandles == (Material**)0xFFFFFFFF)
		{
			varXModel->materialHandles = AllocLoad_MaterialPtr();
			varMaterialPtr = varXModel->materialHandles;
			Load_MaterialPtrArray(true, (varXModel->numsurfs));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->materialHandles);
		}
	}

	varXModelLodInfo = varXModel->lodInfo;
	Load_XModelLodInfoArray(false, 4);

	if (varXModel->collSurfs)
	{
		if (varXModel->collSurfs == (XModelCollSurf_s*)0xFFFFFFFF)
		{
			varXModel->collSurfs = AllocLoad_XModelCollSurf_s();
			varXModelCollSurf_s = varXModel->collSurfs;
			Load_XModelCollSurf_sArray(true, (varXModel->numCollSurfs));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->collSurfs);
		}
	}

	if (varXModel->boneInfo)
	{
		if (varXModel->boneInfo == (XBoneInfo*)0xFFFFFFFF)
		{
			varXModel->boneInfo = AllocLoad_XBoneInfo();
			varXBoneInfo = varXModel->boneInfo;
			Load_XBoneInfoArray(true, (varXModel->numBones));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModel->boneInfo);
		}
	}

	varBounds = &varXModel->bounds;
	Load_Bounds(false);

	varPhysPresetPtr = &varXModel->physPreset;
	Load_PhysPresetPtr(false);

	varPhysCollmapPtr = &varXModel->physCollmap;
	Load_PhysCollmapPtr(false);

	DB_PopStreamPos();
}

void Load_XModelArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModel, sizeof(XModel) * count);
	XModel* pointer = varXModel;
	for (int i = 0; i < count; i++)
	{
		varXModel = pointer;
		Load_XModel(false);
		pointer++;
	}
}

void Load_XModelAsset(XModel** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_XMODEL, (void**)varXModelPtr);
}

void Load_XModelCollSurf_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelCollSurf_s, sizeof(XModelCollSurf_s));

	if (varXModelCollSurf_s->collTris)
	{
		if (varXModelCollSurf_s->collTris == (XModelCollTri_s*)0xFFFFFFFF)
		{
			varXModelCollSurf_s->collTris = AllocLoad_XModelCollTri_s();
			varXModelCollTri_s = varXModelCollSurf_s->collTris;
			Load_XModelCollTri_sArray(true, (varXModelCollSurf_s->numCollTris));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModelCollSurf_s->collTris);
		}
	}

	varBounds = &varXModelCollSurf_s->bounds;
	Load_Bounds(false);

}

void Load_XModelCollSurf_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelCollSurf_s, sizeof(XModelCollSurf_s) * count);
	XModelCollSurf_s* pointer = varXModelCollSurf_s;
	for (int i = 0; i < count; i++)
	{
		varXModelCollSurf_s = pointer;
		Load_XModelCollSurf_s(false);
		pointer++;
	}
}

void Load_XModelCollSurf_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelCollSurf_s, sizeof(XModelCollSurf_s));
	if (*varXModelCollSurf_sPtr != nullptr)
	{
		if (*varXModelCollSurf_sPtr == (XModelCollSurf_s*)0xFFFFFFFF)
		{
			*varXModelCollSurf_sPtr = AllocLoad_XModelCollSurf_s();
			varXModelCollSurf_s = *varXModelCollSurf_sPtr;
			Load_XModelCollSurf_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXModelCollSurf_sPtr);
		}
	}
}

void Load_XModelCollSurf_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelCollSurf_sPtr, sizeof(XModelCollSurf_s*) * count);
	XModelCollSurf_s** pointer = varXModelCollSurf_sPtr;
	for (int i = 0; i < count; i++)
	{
		varXModelCollSurf_sPtr = pointer;
		Load_XModelCollSurf_sPtr(false);
		pointer++;
	}
}

void Load_XModelCollTri_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelCollTri_s, sizeof(XModelCollTri_s));

}

void Load_XModelCollTri_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelCollTri_s, sizeof(XModelCollTri_s) * count);
	XModelCollTri_s* pointer = varXModelCollTri_s;
	for (int i = 0; i < count; i++)
	{
		varXModelCollTri_s = pointer;
		Load_XModelCollTri_s(false);
		pointer++;
	}
}

void Load_XModelCollTri_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelCollTri_s, sizeof(XModelCollTri_s));
	if (*varXModelCollTri_sPtr != nullptr)
	{
		if (*varXModelCollTri_sPtr == (XModelCollTri_s*)0xFFFFFFFF)
		{
			*varXModelCollTri_sPtr = AllocLoad_XModelCollTri_s();
			varXModelCollTri_s = *varXModelCollTri_sPtr;
			Load_XModelCollTri_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXModelCollTri_sPtr);
		}
	}
}

void Load_XModelCollTri_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelCollTri_sPtr, sizeof(XModelCollTri_s*) * count);
	XModelCollTri_s** pointer = varXModelCollTri_sPtr;
	for (int i = 0; i < count; i++)
	{
		varXModelCollTri_sPtr = pointer;
		Load_XModelCollTri_sPtr(false);
		pointer++;
	}
}

void Load_XModelLodInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelLodInfo, sizeof(XModelLodInfo));

	varXModelSurfsPtr = &varXModelLodInfo->modelSurfs;
	Load_XModelSurfsPtr(false);

	if (varXModelLodInfo->surfs)
	{
		if (varXModelLodInfo->surfs == (XSurface*)0xFFFFFFFF)
		{
			varXModelLodInfo->surfs = AllocLoad_XSurface();
			varXSurface = varXModelLodInfo->surfs;
			Load_XSurfaceArray(true, (varXModelLodInfo->numsurfs));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModelLodInfo->surfs);
		}
	}

}

void Load_XModelLodInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelLodInfo, sizeof(XModelLodInfo) * count);
	XModelLodInfo* pointer = varXModelLodInfo;
	for (int i = 0; i < count; i++)
	{
		varXModelLodInfo = pointer;
		Load_XModelLodInfo(false);
		pointer++;
	}
}

void Load_XModelLodInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelLodInfo, sizeof(XModelLodInfo));
	if (*varXModelLodInfoPtr != nullptr)
	{
		if (*varXModelLodInfoPtr == (XModelLodInfo*)0xFFFFFFFF)
		{
			*varXModelLodInfoPtr = AllocLoad_XModelLodInfo();
			varXModelLodInfo = *varXModelLodInfoPtr;
			Load_XModelLodInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXModelLodInfoPtr);
		}
	}
}

void Load_XModelLodInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelLodInfoPtr, sizeof(XModelLodInfo*) * count);
	XModelLodInfo** pointer = varXModelLodInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varXModelLodInfoPtr = pointer;
		Load_XModelLodInfoPtr(false);
		pointer++;
	}
}

void Load_XModelPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModel, sizeof(XModel*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	XModel* pointer = *varXModelPtr;
	if (*varXModelPtr != nullptr)
	{
		if (*varXModelPtr == (XModel*)0xFFFFFFFF || *varXModelPtr == (XModel*)0xFFFFFFFE)
		{
			*varXModelPtr = AllocLoad_XModel();
			varXModel = *varXModelPtr;
			XModel** insertedPointer = nullptr;
			if (pointer == (XModel*)0xFFFFFFFE)
			{
				insertedPointer = (XModel**)DB_InsertPointer();
			}
			Load_XModel(true);
			Load_XModelAsset(varXModelPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varXModelPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varXModelPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_XModelPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelPtr, sizeof(XModel*) * count);
	XModel** pointer = varXModelPtr;
	for (int i = 0; i < count; i++)
	{
		varXModelPtr = pointer;
		Load_XModelPtr(false);
		pointer++;
	}
}

void Load_XModelSurfs(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelSurfs, sizeof(XModelSurfs));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varXModelSurfs->name;
	Load_XString(false);

	if (varXModelSurfs->surfs)
	{
		if (varXModelSurfs->surfs == (XSurface*)0xFFFFFFFF)
		{
			varXModelSurfs->surfs = AllocLoad_XSurface();
			varXSurface = varXModelSurfs->surfs;
			Load_XSurfaceArray(true, (varXModelSurfs->numsurfs));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXModelSurfs->surfs);
		}
	}

	DB_PopStreamPos();
}

void Load_XModelSurfsArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelSurfs, sizeof(XModelSurfs) * count);
	XModelSurfs* pointer = varXModelSurfs;
	for (int i = 0; i < count; i++)
	{
		varXModelSurfs = pointer;
		Load_XModelSurfs(false);
		pointer++;
	}
}

void Load_XModelSurfsAsset(XModelSurfs** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_XMODEL_SURFS, (void**)varXModelSurfsPtr);
}

void Load_XModelSurfsPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXModelSurfs, sizeof(XModelSurfs*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	XModelSurfs* pointer = *varXModelSurfsPtr;
	if (*varXModelSurfsPtr != nullptr)
	{
		if (*varXModelSurfsPtr == (XModelSurfs*)0xFFFFFFFF || *varXModelSurfsPtr == (XModelSurfs*)0xFFFFFFFE)
		{
			*varXModelSurfsPtr = AllocLoad_XModelSurfs();
			varXModelSurfs = *varXModelSurfsPtr;
			XModelSurfs** insertedPointer = nullptr;
			if (pointer == (XModelSurfs*)0xFFFFFFFE)
			{
				insertedPointer = (XModelSurfs**)DB_InsertPointer();
			}
			Load_XModelSurfs(true);
			Load_XModelSurfsAsset(varXModelSurfsPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varXModelSurfsPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varXModelSurfsPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_XModelSurfsPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXModelSurfsPtr, sizeof(XModelSurfs*) * count);
	XModelSurfs** pointer = varXModelSurfsPtr;
	for (int i = 0; i < count; i++)
	{
		varXModelSurfsPtr = pointer;
		Load_XModelSurfsPtr(false);
		pointer++;
	}
}

void Load_XRigidVertList(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXRigidVertList, sizeof(XRigidVertList));

	if (varXRigidVertList->collisionTree)
	{
		varXSurfaceCollisionTreePtr = &varXRigidVertList->collisionTree;
		Load_XSurfaceCollisionTreePtr(false);
	}

}

void Load_XRigidVertListArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXRigidVertList, sizeof(XRigidVertList) * count);
	XRigidVertList* pointer = varXRigidVertList;
	for (int i = 0; i < count; i++)
	{
		varXRigidVertList = pointer;
		Load_XRigidVertList(false);
		pointer++;
	}
}

void Load_XRigidVertListPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXRigidVertList, sizeof(XRigidVertList));
	if (*varXRigidVertListPtr != nullptr)
	{
		if (*varXRigidVertListPtr == (XRigidVertList*)0xFFFFFFFF)
		{
			*varXRigidVertListPtr = AllocLoad_XRigidVertList();
			varXRigidVertList = *varXRigidVertListPtr;
			Load_XRigidVertList(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXRigidVertListPtr);
		}
	}
}

void Load_XRigidVertListPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXRigidVertListPtr, sizeof(XRigidVertList*) * count);
	XRigidVertList** pointer = varXRigidVertListPtr;
	for (int i = 0; i < count; i++)
	{
		varXRigidVertListPtr = pointer;
		Load_XRigidVertListPtr(false);
		pointer++;
	}
}

void Load_XStringArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXString, sizeof(XString) * count);
	XString* pointer = varXString;
	for (int i = 0; i < count; i++)
	{
		varXString = pointer;
		Load_XString(false);
		pointer++;
	}
}

void Load_XStringPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXString, sizeof(XString));
	if (*varXStringPtr != nullptr)
	{
		*varXStringPtr = AllocLoad_XString();
		varXString = *varXStringPtr;
		Load_XString(true);
	}
}

void Load_XStringPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXStringPtr, sizeof(XString*) * count);
	XString** pointer = varXStringPtr;
	for (int i = 0; i < count; i++)
	{
		varXStringPtr = pointer;
		Load_XStringPtr(false);
		pointer++;
	}
}

void Load_XSurface(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurface, sizeof(XSurface));

	varXSurfaceVertexInfo = &varXSurface->vertInfo;
	Load_XSurfaceVertexInfo(false);

	DB_PushStreamPos(XFILE_BLOCK_VERTEX);
	if (varXSurface->verts0)
	{
		if (varXSurface->verts0 == (GfxPackedVertex*)0xFFFFFFFF)
		{
			varXSurface->verts0 = AllocLoad_GfxPackedVertex();
			varGfxPackedVertex = varXSurface->verts0;
			Load_GfxPackedVertexArray(true, (varXSurface->vertCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXSurface->verts0);
		}
	}
	DB_PopStreamPos();

	if (varXSurface->vertList)
	{
		if (varXSurface->vertList == (XRigidVertList*)0xFFFFFFFF)
		{
			varXSurface->vertList = AllocLoad_XRigidVertList();
			varXRigidVertList = varXSurface->vertList;
			Load_XRigidVertListArray(true, (varXSurface->vertListCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXSurface->vertList);
		}
	}

	DB_PushStreamPos(XFILE_BLOCK_INDEX);
	if (varXSurface->triIndices)
	{
		if (varXSurface->triIndices == (TriIndice*)0xFFFFFFFF)
		{
			varXSurface->triIndices = AllocLoad_TriIndice();
			varTriIndice = varXSurface->triIndices;
			Load_TriIndiceArray(true, (varXSurface->triCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXSurface->triIndices);
		}
	}
	DB_PopStreamPos();

}

void Load_XSurfaceArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurface, sizeof(XSurface) * count);
	XSurface* pointer = varXSurface;
	for (int i = 0; i < count; i++)
	{
		varXSurface = pointer;
		Load_XSurface(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionAabb(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionAabb, sizeof(XSurfaceCollisionAabb));

}

void Load_XSurfaceCollisionAabbArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionAabb, sizeof(XSurfaceCollisionAabb) * count);
	XSurfaceCollisionAabb* pointer = varXSurfaceCollisionAabb;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionAabb = pointer;
		Load_XSurfaceCollisionAabb(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionAabbPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionAabb, sizeof(XSurfaceCollisionAabb));
	if (*varXSurfaceCollisionAabbPtr != nullptr)
	{
		if (*varXSurfaceCollisionAabbPtr == (XSurfaceCollisionAabb*)0xFFFFFFFF)
		{
			*varXSurfaceCollisionAabbPtr = AllocLoad_XSurfaceCollisionAabb();
			varXSurfaceCollisionAabb = *varXSurfaceCollisionAabbPtr;
			Load_XSurfaceCollisionAabb(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXSurfaceCollisionAabbPtr);
		}
	}
}

void Load_XSurfaceCollisionAabbPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionAabbPtr, sizeof(XSurfaceCollisionAabb*) * count);
	XSurfaceCollisionAabb** pointer = varXSurfaceCollisionAabbPtr;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionAabbPtr = pointer;
		Load_XSurfaceCollisionAabbPtr(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionLeaf(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionLeaf, sizeof(XSurfaceCollisionLeaf));

}

void Load_XSurfaceCollisionLeafArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionLeaf, sizeof(XSurfaceCollisionLeaf) * count);
	XSurfaceCollisionLeaf* pointer = varXSurfaceCollisionLeaf;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionLeaf = pointer;
		Load_XSurfaceCollisionLeaf(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionLeafPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionLeaf, sizeof(XSurfaceCollisionLeaf));
	if (*varXSurfaceCollisionLeafPtr != nullptr)
	{
		*varXSurfaceCollisionLeafPtr = AllocLoad_XSurfaceCollisionLeaf();
		varXSurfaceCollisionLeaf = *varXSurfaceCollisionLeafPtr;
		Load_XSurfaceCollisionLeaf(true);
	}
}

void Load_XSurfaceCollisionLeafPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionLeafPtr, sizeof(XSurfaceCollisionLeaf*) * count);
	XSurfaceCollisionLeaf** pointer = varXSurfaceCollisionLeafPtr;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionLeafPtr = pointer;
		Load_XSurfaceCollisionLeafPtr(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionNode(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionNode, sizeof(XSurfaceCollisionNode));

	varXSurfaceCollisionAabb = &varXSurfaceCollisionNode->aabb;
	Load_XSurfaceCollisionAabb(false);

}

void Load_XSurfaceCollisionNodeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionNode, sizeof(XSurfaceCollisionNode) * count);
	XSurfaceCollisionNode* pointer = varXSurfaceCollisionNode;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionNode = pointer;
		Load_XSurfaceCollisionNode(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionNodePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionNode, sizeof(XSurfaceCollisionNode));
	if (*varXSurfaceCollisionNodePtr != nullptr)
	{
		if (*varXSurfaceCollisionNodePtr == (XSurfaceCollisionNode*)0xFFFFFFFF)
		{
			*varXSurfaceCollisionNodePtr = AllocLoad_XSurfaceCollisionNode();
			varXSurfaceCollisionNode = *varXSurfaceCollisionNodePtr;
			Load_XSurfaceCollisionNode(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXSurfaceCollisionNodePtr);
		}
	}
}

void Load_XSurfaceCollisionNodePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionNodePtr, sizeof(XSurfaceCollisionNode*) * count);
	XSurfaceCollisionNode** pointer = varXSurfaceCollisionNodePtr;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionNodePtr = pointer;
		Load_XSurfaceCollisionNodePtr(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionTree(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionTree, sizeof(XSurfaceCollisionTree));

	if (varXSurfaceCollisionTree->nodes)
	{
		if (varXSurfaceCollisionTree->nodes == (XSurfaceCollisionNode*)0xFFFFFFFF)
		{
			varXSurfaceCollisionTree->nodes = AllocLoad_XSurfaceCollisionNode();
			varXSurfaceCollisionNode = varXSurfaceCollisionTree->nodes;
			Load_XSurfaceCollisionNodeArray(true, (varXSurfaceCollisionTree->nodeCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXSurfaceCollisionTree->nodes);
		}
	}

	if (varXSurfaceCollisionTree->leafs)
	{
		if (varXSurfaceCollisionTree->leafs == (XSurfaceCollisionLeaf*)0xFFFFFFFF)
		{
			varXSurfaceCollisionTree->leafs = AllocLoad_XSurfaceCollisionLeaf();
			varXSurfaceCollisionLeaf = varXSurfaceCollisionTree->leafs;
			Load_XSurfaceCollisionLeafArray(true, (varXSurfaceCollisionTree->leafCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXSurfaceCollisionTree->leafs);
		}
	}

}

void Load_XSurfaceCollisionTreeArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionTree, sizeof(XSurfaceCollisionTree) * count);
	XSurfaceCollisionTree* pointer = varXSurfaceCollisionTree;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionTree = pointer;
		Load_XSurfaceCollisionTree(false);
		pointer++;
	}
}

void Load_XSurfaceCollisionTreePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionTree, sizeof(XSurfaceCollisionTree));
	if (*varXSurfaceCollisionTreePtr != nullptr)
	{
		if (*varXSurfaceCollisionTreePtr == (XSurfaceCollisionTree*)0xFFFFFFFF)
		{
			*varXSurfaceCollisionTreePtr = AllocLoad_XSurfaceCollisionTree();
			varXSurfaceCollisionTree = *varXSurfaceCollisionTreePtr;
			Load_XSurfaceCollisionTree(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXSurfaceCollisionTreePtr);
		}
	}
}

void Load_XSurfaceCollisionTreePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceCollisionTreePtr, sizeof(XSurfaceCollisionTree*) * count);
	XSurfaceCollisionTree** pointer = varXSurfaceCollisionTreePtr;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceCollisionTreePtr = pointer;
		Load_XSurfaceCollisionTreePtr(false);
		pointer++;
	}
}

void Load_XSurfacePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurface, sizeof(XSurface));
	if (*varXSurfacePtr != nullptr)
	{
		if (*varXSurfacePtr == (XSurface*)0xFFFFFFFF)
		{
			*varXSurfacePtr = AllocLoad_XSurface();
			varXSurface = *varXSurfacePtr;
			Load_XSurface(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXSurfacePtr);
		}
	}
}

void Load_XSurfacePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfacePtr, sizeof(XSurface*) * count);
	XSurface** pointer = varXSurfacePtr;
	for (int i = 0; i < count; i++)
	{
		varXSurfacePtr = pointer;
		Load_XSurfacePtr(false);
		pointer++;
	}
}

void Load_XSurfaceVertexInfo(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceVertexInfo, sizeof(XSurfaceVertexInfo));

	if (varXSurfaceVertexInfo->vertsBlend)
	{
		if (varXSurfaceVertexInfo->vertsBlend == (uint16*)0xFFFFFFFF)
		{
			varXSurfaceVertexInfo->vertsBlend = AllocLoad_uint16();
			varuint16 = varXSurfaceVertexInfo->vertsBlend;
			Load_uint16Array(true, (varXSurfaceVertexInfo->vertCount[0] + (varXSurfaceVertexInfo->vertCount[1] * 3) + (varXSurfaceVertexInfo->vertCount[2] * 5) + (varXSurfaceVertexInfo->vertCount[3] * 7)));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varXSurfaceVertexInfo->vertsBlend);
		}
	}

}

void Load_XSurfaceVertexInfoArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceVertexInfo, sizeof(XSurfaceVertexInfo) * count);
	XSurfaceVertexInfo* pointer = varXSurfaceVertexInfo;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceVertexInfo = pointer;
		Load_XSurfaceVertexInfo(false);
		pointer++;
	}
}

void Load_XSurfaceVertexInfoPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varXSurfaceVertexInfo, sizeof(XSurfaceVertexInfo));
	if (*varXSurfaceVertexInfoPtr != nullptr)
	{
		if (*varXSurfaceVertexInfoPtr == (XSurfaceVertexInfo*)0xFFFFFFFF)
		{
			*varXSurfaceVertexInfoPtr = AllocLoad_XSurfaceVertexInfo();
			varXSurfaceVertexInfo = *varXSurfaceVertexInfoPtr;
			Load_XSurfaceVertexInfo(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varXSurfaceVertexInfoPtr);
		}
	}
}

void Load_XSurfaceVertexInfoPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varXSurfaceVertexInfoPtr, sizeof(XSurfaceVertexInfo*) * count);
	XSurfaceVertexInfo** pointer = varXSurfaceVertexInfoPtr;
	for (int i = 0; i < count; i++)
	{
		varXSurfaceVertexInfoPtr = pointer;
		Load_XSurfaceVertexInfoPtr(false);
		pointer++;
	}
}

void Load__AILSOUNDINFO(bool atStreamStart)
{
	Load_Stream(atStreamStart, var_AILSOUNDINFO, sizeof(_AILSOUNDINFO));

}

void Load__AILSOUNDINFOArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, var_AILSOUNDINFO, sizeof(_AILSOUNDINFO) * count);
	_AILSOUNDINFO* pointer = var_AILSOUNDINFO;
	for (int i = 0; i < count; i++)
	{
		var_AILSOUNDINFO = pointer;
		Load__AILSOUNDINFO(false);
		pointer++;
	}
}

void Load__AILSOUNDINFOPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, var_AILSOUNDINFO, sizeof(_AILSOUNDINFO));
	if (*var_AILSOUNDINFOPtr != nullptr)
	{
		if (*var_AILSOUNDINFOPtr == (_AILSOUNDINFO*)0xFFFFFFFF)
		{
			*var_AILSOUNDINFOPtr = AllocLoad__AILSOUNDINFO();
			var_AILSOUNDINFO = *var_AILSOUNDINFOPtr;
			Load__AILSOUNDINFO(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)var_AILSOUNDINFOPtr);
		}
	}
}

void Load__AILSOUNDINFOPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, var_AILSOUNDINFOPtr, sizeof(_AILSOUNDINFO*) * count);
	_AILSOUNDINFO** pointer = var_AILSOUNDINFOPtr;
	for (int i = 0; i < count; i++)
	{
		var_AILSOUNDINFOPtr = pointer;
		Load__AILSOUNDINFOPtr(false);
		pointer++;
	}
}

void Load_bool(bool atStreamStart)
{
	Load_Stream(atStreamStart, varbool, sizeof(bool));

}

void Load_boolArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varbool, sizeof(bool) * count);
	bool* pointer = varbool;
	for (int i = 0; i < count; i++)
	{
		varbool = pointer;
		Load_bool(false);
		pointer++;
	}
}

void Load_boolPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varbool, sizeof(bool));
	if (*varboolPtr != nullptr)
	{
		*varboolPtr = AllocLoad_bool();
		varbool = *varboolPtr;
		Load_bool(true);
	}
}

void Load_boolPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varboolPtr, sizeof(bool*) * count);
	bool** pointer = varboolPtr;
	for (int i = 0; i < count; i++)
	{
		varboolPtr = pointer;
		Load_boolPtr(false);
		pointer++;
	}
}

void Load_cLeafBrushNodeChildren_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeChildren_t, sizeof(cLeafBrushNodeChildren_t));

}

void Load_cLeafBrushNodeChildren_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeChildren_t, sizeof(cLeafBrushNodeChildren_t) * count);
	cLeafBrushNodeChildren_t* pointer = varcLeafBrushNodeChildren_t;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNodeChildren_t = pointer;
		Load_cLeafBrushNodeChildren_t(false);
		pointer++;
	}
}

void Load_cLeafBrushNodeChildren_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeChildren_t, sizeof(cLeafBrushNodeChildren_t));
	if (*varcLeafBrushNodeChildren_tPtr != nullptr)
	{
		if (*varcLeafBrushNodeChildren_tPtr == (cLeafBrushNodeChildren_t*)0xFFFFFFFF)
		{
			*varcLeafBrushNodeChildren_tPtr = AllocLoad_cLeafBrushNodeChildren_t();
			varcLeafBrushNodeChildren_t = *varcLeafBrushNodeChildren_tPtr;
			Load_cLeafBrushNodeChildren_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcLeafBrushNodeChildren_tPtr);
		}
	}
}

void Load_cLeafBrushNodeChildren_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeChildren_tPtr, sizeof(cLeafBrushNodeChildren_t*) * count);
	cLeafBrushNodeChildren_t** pointer = varcLeafBrushNodeChildren_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNodeChildren_tPtr = pointer;
		Load_cLeafBrushNodeChildren_tPtr(false);
		pointer++;
	}
}

void Load_cLeafBrushNodeData_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeData_t, sizeof(cLeafBrushNodeData_t));

}

void Load_cLeafBrushNodeData_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeData_t, sizeof(cLeafBrushNodeData_t) * count);
	cLeafBrushNodeData_t* pointer = varcLeafBrushNodeData_t;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNodeData_t = pointer;
		Load_cLeafBrushNodeData_t(false);
		pointer++;
	}
}

void Load_cLeafBrushNodeData_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeData_t, sizeof(cLeafBrushNodeData_t));
	if (*varcLeafBrushNodeData_tPtr != nullptr)
	{
		if (*varcLeafBrushNodeData_tPtr == (cLeafBrushNodeData_t*)0xFFFFFFFF)
		{
			*varcLeafBrushNodeData_tPtr = AllocLoad_cLeafBrushNodeData_t();
			varcLeafBrushNodeData_t = *varcLeafBrushNodeData_tPtr;
			Load_cLeafBrushNodeData_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcLeafBrushNodeData_tPtr);
		}
	}
}

void Load_cLeafBrushNodeData_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeData_tPtr, sizeof(cLeafBrushNodeData_t*) * count);
	cLeafBrushNodeData_t** pointer = varcLeafBrushNodeData_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNodeData_tPtr = pointer;
		Load_cLeafBrushNodeData_tPtr(false);
		pointer++;
	}
}

void Load_cLeafBrushNodeLeaf_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeLeaf_t, sizeof(cLeafBrushNodeLeaf_t));

	if (varcLeafBrushNodeLeaf_t->brushes)
	{
		varuint16Ptr = &varcLeafBrushNodeLeaf_t->brushes;
		Load_uint16Ptr(false);
	}

}

void Load_cLeafBrushNodeLeaf_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeLeaf_t, sizeof(cLeafBrushNodeLeaf_t) * count);
	cLeafBrushNodeLeaf_t* pointer = varcLeafBrushNodeLeaf_t;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNodeLeaf_t = pointer;
		Load_cLeafBrushNodeLeaf_t(false);
		pointer++;
	}
}

void Load_cLeafBrushNodeLeaf_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeLeaf_t, sizeof(cLeafBrushNodeLeaf_t));
	if (*varcLeafBrushNodeLeaf_tPtr != nullptr)
	{
		*varcLeafBrushNodeLeaf_tPtr = AllocLoad_cLeafBrushNodeLeaf_t();
		varcLeafBrushNodeLeaf_t = *varcLeafBrushNodeLeaf_tPtr;
		Load_cLeafBrushNodeLeaf_t(true);
	}
}

void Load_cLeafBrushNodeLeaf_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNodeLeaf_tPtr, sizeof(cLeafBrushNodeLeaf_t*) * count);
	cLeafBrushNodeLeaf_t** pointer = varcLeafBrushNodeLeaf_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNodeLeaf_tPtr = pointer;
		Load_cLeafBrushNodeLeaf_tPtr(false);
		pointer++;
	}
}

void Load_cLeafBrushNode_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNode_s, sizeof(cLeafBrushNode_s));

	varcLeafBrushNodeData_t = &varcLeafBrushNode_s->data;
	Load_cLeafBrushNodeData_t(false);

}

void Load_cLeafBrushNode_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNode_s, sizeof(cLeafBrushNode_s) * count);
	cLeafBrushNode_s* pointer = varcLeafBrushNode_s;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNode_s = pointer;
		Load_cLeafBrushNode_s(false);
		pointer++;
	}
}

void Load_cLeafBrushNode_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeafBrushNode_s, sizeof(cLeafBrushNode_s));
	if (*varcLeafBrushNode_sPtr != nullptr)
	{
		if (*varcLeafBrushNode_sPtr == (cLeafBrushNode_s*)0xFFFFFFFF)
		{
			*varcLeafBrushNode_sPtr = AllocLoad_cLeafBrushNode_s();
			varcLeafBrushNode_s = *varcLeafBrushNode_sPtr;
			Load_cLeafBrushNode_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcLeafBrushNode_sPtr);
		}
	}
}

void Load_cLeafBrushNode_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeafBrushNode_sPtr, sizeof(cLeafBrushNode_s*) * count);
	cLeafBrushNode_s** pointer = varcLeafBrushNode_sPtr;
	for (int i = 0; i < count; i++)
	{
		varcLeafBrushNode_sPtr = pointer;
		Load_cLeafBrushNode_sPtr(false);
		pointer++;
	}
}

void Load_cLeaf_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeaf_t, sizeof(cLeaf_t));

	varBounds = &varcLeaf_t->bounds;
	Load_Bounds(false);

}

void Load_cLeaf_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeaf_t, sizeof(cLeaf_t) * count);
	cLeaf_t* pointer = varcLeaf_t;
	for (int i = 0; i < count; i++)
	{
		varcLeaf_t = pointer;
		Load_cLeaf_t(false);
		pointer++;
	}
}

void Load_cLeaf_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcLeaf_t, sizeof(cLeaf_t));
	if (*varcLeaf_tPtr != nullptr)
	{
		if (*varcLeaf_tPtr == (cLeaf_t*)0xFFFFFFFF)
		{
			*varcLeaf_tPtr = AllocLoad_cLeaf_t();
			varcLeaf_t = *varcLeaf_tPtr;
			Load_cLeaf_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcLeaf_tPtr);
		}
	}
}

void Load_cLeaf_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcLeaf_tPtr, sizeof(cLeaf_t*) * count);
	cLeaf_t** pointer = varcLeaf_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcLeaf_tPtr = pointer;
		Load_cLeaf_tPtr(false);
		pointer++;
	}
}

void Load_cNode_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcNode_t, sizeof(cNode_t));

	if (varcNode_t->plane)
	{
		varcplane_sPtr = &varcNode_t->plane;
		Load_cplane_sPtr(false);
	}

}

void Load_cNode_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcNode_t, sizeof(cNode_t) * count);
	cNode_t* pointer = varcNode_t;
	for (int i = 0; i < count; i++)
	{
		varcNode_t = pointer;
		Load_cNode_t(false);
		pointer++;
	}
}

void Load_cNode_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcNode_t, sizeof(cNode_t));
	if (*varcNode_tPtr != nullptr)
	{
		if (*varcNode_tPtr == (cNode_t*)0xFFFFFFFF)
		{
			*varcNode_tPtr = AllocLoad_cNode_t();
			varcNode_t = *varcNode_tPtr;
			Load_cNode_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcNode_tPtr);
		}
	}
}

void Load_cNode_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcNode_tPtr, sizeof(cNode_t*) * count);
	cNode_t** pointer = varcNode_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcNode_tPtr = pointer;
		Load_cNode_tPtr(false);
		pointer++;
	}
}

void Load_cStaticModel_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcStaticModel_s, sizeof(cStaticModel_s));

	varXModelPtr = &varcStaticModel_s->xmodel;
	Load_XModelPtr(false);

	varBounds = &varcStaticModel_s->absBounds;
	Load_Bounds(false);

}

void Load_cStaticModel_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcStaticModel_s, sizeof(cStaticModel_s) * count);
	cStaticModel_s* pointer = varcStaticModel_s;
	for (int i = 0; i < count; i++)
	{
		varcStaticModel_s = pointer;
		Load_cStaticModel_s(false);
		pointer++;
	}
}

void Load_cStaticModel_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcStaticModel_s, sizeof(cStaticModel_s));
	if (*varcStaticModel_sPtr != nullptr)
	{
		if (*varcStaticModel_sPtr == (cStaticModel_s*)0xFFFFFFFF)
		{
			*varcStaticModel_sPtr = AllocLoad_cStaticModel_s();
			varcStaticModel_s = *varcStaticModel_sPtr;
			Load_cStaticModel_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcStaticModel_sPtr);
		}
	}
}

void Load_cStaticModel_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcStaticModel_sPtr, sizeof(cStaticModel_s*) * count);
	cStaticModel_s** pointer = varcStaticModel_sPtr;
	for (int i = 0; i < count; i++)
	{
		varcStaticModel_sPtr = pointer;
		Load_cStaticModel_sPtr(false);
		pointer++;
	}
}

void Load_cbrush_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcbrush_t, sizeof(cbrush_t));

	if (varcbrush_t->sides)
	{
		if (varcbrush_t->sides == (cbrushside_t*)0xFFFFFFFF)
		{
			varcbrush_t->sides = AllocLoad_cbrushside_t();
			varcbrushside_t = varcbrush_t->sides;
			Load_cbrushside_tArray(true, (varcbrush_t->numsides));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varcbrush_t->sides);
		}
	}

	if (varcbrush_t->baseAdjacentSide)
	{
		varcharPtr = &varcbrush_t->baseAdjacentSide;
		Load_charPtr(false);
	}

}

void Load_cbrush_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcbrush_t, sizeof(cbrush_t) * count);
	cbrush_t* pointer = varcbrush_t;
	for (int i = 0; i < count; i++)
	{
		varcbrush_t = pointer;
		Load_cbrush_t(false);
		pointer++;
	}
}

void Load_cbrush_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcbrush_t, sizeof(cbrush_t));
	if (*varcbrush_tPtr != nullptr)
	{
		if (*varcbrush_tPtr == (cbrush_t*)0xFFFFFFFF)
		{
			*varcbrush_tPtr = AllocLoad_cbrush_t();
			varcbrush_t = *varcbrush_tPtr;
			Load_cbrush_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcbrush_tPtr);
		}
	}
}

void Load_cbrush_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcbrush_tPtr, sizeof(cbrush_t*) * count);
	cbrush_t** pointer = varcbrush_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcbrush_tPtr = pointer;
		Load_cbrush_tPtr(false);
		pointer++;
	}
}

void Load_cbrushside_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcbrushside_t, sizeof(cbrushside_t));

	if (varcbrushside_t->plane)
	{
		varcplane_sPtr = &varcbrushside_t->plane;
		Load_cplane_sPtr(false);
	}

}

void Load_cbrushside_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcbrushside_t, sizeof(cbrushside_t) * count);
	cbrushside_t* pointer = varcbrushside_t;
	for (int i = 0; i < count; i++)
	{
		varcbrushside_t = pointer;
		Load_cbrushside_t(false);
		pointer++;
	}
}

void Load_cbrushside_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcbrushside_t, sizeof(cbrushside_t));
	if (*varcbrushside_tPtr != nullptr)
	{
		if (*varcbrushside_tPtr == (cbrushside_t*)0xFFFFFFFF)
		{
			*varcbrushside_tPtr = AllocLoad_cbrushside_t();
			varcbrushside_t = *varcbrushside_tPtr;
			Load_cbrushside_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcbrushside_tPtr);
		}
	}
}

void Load_cbrushside_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcbrushside_tPtr, sizeof(cbrushside_t*) * count);
	cbrushside_t** pointer = varcbrushside_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcbrushside_tPtr = pointer;
		Load_cbrushside_tPtr(false);
		pointer++;
	}
}

void Load_char(bool atStreamStart)
{
	Load_Stream(atStreamStart, varchar, sizeof(char));

}

void Load_char16(bool atStreamStart)
{
	Load_Stream(atStreamStart, varchar16, sizeof(char16));

}

void Load_char16Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varchar16, sizeof(char16) * count);
	char16* pointer = varchar16;
	for (int i = 0; i < count; i++)
	{
		varchar16 = pointer;
		Load_char16(false);
		pointer++;
	}
}

void Load_char16Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varchar16, sizeof(char16));
	if (*varchar16Ptr != nullptr)
	{
		*varchar16Ptr = AllocLoad_char16();
		varchar16 = *varchar16Ptr;
		Load_char16(true);
	}
}

void Load_char16PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varchar16Ptr, sizeof(char16*) * count);
	char16** pointer = varchar16Ptr;
	for (int i = 0; i < count; i++)
	{
		varchar16Ptr = pointer;
		Load_char16Ptr(false);
		pointer++;
	}
}

void Load_charArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varchar, sizeof(char) * count);
	char* pointer = varchar;
	for (int i = 0; i < count; i++)
	{
		varchar = pointer;
		Load_char(false);
		pointer++;
	}
}

void Load_charPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varchar, sizeof(char));
	if (*varcharPtr != nullptr)
	{
		*varcharPtr = AllocLoad_char();
		varchar = *varcharPtr;
		Load_char(true);
	}
}

void Load_charPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcharPtr, sizeof(char*) * count);
	char** pointer = varcharPtr;
	for (int i = 0; i < count; i++)
	{
		varcharPtr = pointer;
		Load_charPtr(false);
		pointer++;
	}
}

void Load_clipMap_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varclipMap_t, sizeof(clipMap_t));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varclipMap_t->name;
	Load_XString(false);

	if (varclipMap_t->planes)
	{
		if (varclipMap_t->planes == (cplane_s*)0xFFFFFFFF)
		{
			varclipMap_t->planes = AllocLoad_cplane_s();
			varcplane_s = varclipMap_t->planes;
			Load_cplane_sArray(true, (varclipMap_t->planeCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->planes);
		}
	}

	if (varclipMap_t->staticModelList)
	{
		if (varclipMap_t->staticModelList == (cStaticModel_s*)0xFFFFFFFF)
		{
			varclipMap_t->staticModelList = AllocLoad_cStaticModel_s();
			varcStaticModel_s = varclipMap_t->staticModelList;
			Load_cStaticModel_sArray(true, (varclipMap_t->numStaticModels));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->staticModelList);
		}
	}

	if (varclipMap_t->materials)
	{
		if (varclipMap_t->materials == (ClipMaterial*)0xFFFFFFFF)
		{
			varclipMap_t->materials = AllocLoad_ClipMaterial();
			varClipMaterial = varclipMap_t->materials;
			Load_ClipMaterialArray(true, (varclipMap_t->numMaterials));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->materials);
		}
	}

	if (varclipMap_t->brushsides)
	{
		if (varclipMap_t->brushsides == (cbrushside_t*)0xFFFFFFFF)
		{
			varclipMap_t->brushsides = AllocLoad_cbrushside_t();
			varcbrushside_t = varclipMap_t->brushsides;
			Load_cbrushside_tArray(true, (varclipMap_t->numBrushSides));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->brushsides);
		}
	}

	if (varclipMap_t->brushEdges)
	{
		if (varclipMap_t->brushEdges == (char*)0xFFFFFFFF)
		{
			varclipMap_t->brushEdges = AllocLoad_char();
			varchar = varclipMap_t->brushEdges;
			Load_charArray(true, (varclipMap_t->numBrushEdges));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->brushEdges);
		}
	}

	if (varclipMap_t->nodes)
	{
		if (varclipMap_t->nodes == (cNode_t*)0xFFFFFFFF)
		{
			varclipMap_t->nodes = AllocLoad_cNode_t();
			varcNode_t = varclipMap_t->nodes;
			Load_cNode_tArray(true, (varclipMap_t->numNodes));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->nodes);
		}
	}

	if (varclipMap_t->leafs)
	{
		if (varclipMap_t->leafs == (cLeaf_t*)0xFFFFFFFF)
		{
			varclipMap_t->leafs = AllocLoad_cLeaf_t();
			varcLeaf_t = varclipMap_t->leafs;
			Load_cLeaf_tArray(true, (varclipMap_t->numLeafs));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->leafs);
		}
	}

	if (varclipMap_t->leafbrushNodes)
	{
		if (varclipMap_t->leafbrushNodes == (cLeafBrushNode_s*)0xFFFFFFFF)
		{
			varclipMap_t->leafbrushNodes = AllocLoad_cLeafBrushNode_s();
			varcLeafBrushNode_s = varclipMap_t->leafbrushNodes;
			Load_cLeafBrushNode_sArray(true, (varclipMap_t->leafbrushNodesCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->leafbrushNodes);
		}
	}

	if (varclipMap_t->leafbrushes)
	{
		if (varclipMap_t->leafbrushes == (uint16*)0xFFFFFFFF)
		{
			varclipMap_t->leafbrushes = AllocLoad_uint16();
			varuint16 = varclipMap_t->leafbrushes;
			Load_uint16Array(true, (varclipMap_t->numLeafBrushes));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->leafbrushes);
		}
	}

	if (varclipMap_t->verts)
	{
		if (varclipMap_t->verts == (vec3_t*)0xFFFFFFFF)
		{
			varclipMap_t->verts = AllocLoad_vec3_t();
			varvec3_t = varclipMap_t->verts;
			Load_vec3_tArray(true, (varclipMap_t->vertCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->verts);
		}
	}

	if (varclipMap_t->triIndices)
	{
		varuint16Ptr = &varclipMap_t->triIndices;
		Load_uint16Ptr(false);
	}

	if (varclipMap_t->triEdgeIsWalkable)
	{
		varcharPtr = &varclipMap_t->triEdgeIsWalkable;
		Load_charPtr(false);
	}

	if (varclipMap_t->borders)
	{
		if (varclipMap_t->borders == (CollisionBorder*)0xFFFFFFFF)
		{
			varclipMap_t->borders = AllocLoad_CollisionBorder();
			varCollisionBorder = varclipMap_t->borders;
			Load_CollisionBorderArray(true, (varclipMap_t->borderCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->borders);
		}
	}

	if (varclipMap_t->partitions)
	{
		if (varclipMap_t->partitions == (CollisionPartition*)0xFFFFFFFF)
		{
			varclipMap_t->partitions = AllocLoad_CollisionPartition();
			varCollisionPartition = varclipMap_t->partitions;
			Load_CollisionPartitionArray(true, (varclipMap_t->partitionCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->partitions);
		}
	}

	if (varclipMap_t->aabbTrees)
	{
		if (varclipMap_t->aabbTrees == (CollisionAabbTree*)0xFFFFFFFF)
		{
			varclipMap_t->aabbTrees = AllocLoad_CollisionAabbTree();
			varCollisionAabbTree = varclipMap_t->aabbTrees;
			Load_CollisionAabbTreeArray(true, (varclipMap_t->aabbTreeCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->aabbTrees);
		}
	}

	if (varclipMap_t->cmodels)
	{
		if (varclipMap_t->cmodels == (cmodel_t*)0xFFFFFFFF)
		{
			varclipMap_t->cmodels = AllocLoad_cmodel_t();
			varcmodel_t = varclipMap_t->cmodels;
			Load_cmodel_tArray(true, (varclipMap_t->numSubModels));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->cmodels);
		}
	}

	if (varclipMap_t->brushes)
	{
		if (varclipMap_t->brushes == (cbrush_t*)0xFFFFFFFF)
		{
			varclipMap_t->brushes = AllocLoad_cbrush_t();
			varcbrush_t = varclipMap_t->brushes;
			Load_cbrush_tArray(true, (varclipMap_t->numBrushes));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->brushes);
		}
	}

	if (varclipMap_t->brushBounds)
	{
		varBoundsPtr = &varclipMap_t->brushBounds;
		Load_BoundsPtr(false);
	}

	if (varclipMap_t->smodelNodes)
	{
		if (varclipMap_t->smodelNodes == (SModelAabbNode*)0xFFFFFFFF)
		{
			varclipMap_t->smodelNodes = AllocLoad_SModelAabbNode();
			varSModelAabbNode = varclipMap_t->smodelNodes;
			Load_SModelAabbNodeArray(true, (varclipMap_t->smodelNodeCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varclipMap_t->smodelNodes);
		}
	}

	varMapEntsPtr = &varclipMap_t->mapEnts;
	Load_MapEntsPtr(false);

	if (varclipMap_t->dynEntDefList)
	{
		varDynEntityDefPtr = varclipMap_t->dynEntDefList;
		Load_DynEntityDefPtrArray(false, 2);
	}

	if (varclipMap_t->dynEntPoseList)
	{
		varDynEntityPosePtr = varclipMap_t->dynEntPoseList;
		Load_DynEntityPosePtrArray(false, 2);
	}

	if (varclipMap_t->dynEntClientList)
	{
		varDynEntityClientPtr = varclipMap_t->dynEntClientList;
		Load_DynEntityClientPtrArray(false, 2);
	}

	if (varclipMap_t->dynEntCollList)
	{
		varDynEntityCollPtr = varclipMap_t->dynEntCollList;
		Load_DynEntityCollPtrArray(false, 2);
	}

	DB_PopStreamPos();
}

void Load_clipMap_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varclipMap_t, sizeof(clipMap_t) * count);
	clipMap_t* pointer = varclipMap_t;
	for (int i = 0; i < count; i++)
	{
		varclipMap_t = pointer;
		Load_clipMap_t(false);
		pointer++;
	}
}

void Load_clipMap_tAsset(clipMap_t** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_CLIPMAP_MP, (void**)varclipMap_tPtr);
}

void Load_clipMap_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varclipMap_t, sizeof(clipMap_t*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	clipMap_t* pointer = *varclipMap_tPtr;
	if (*varclipMap_tPtr != nullptr)
	{
		if (*varclipMap_tPtr == (clipMap_t*)0xFFFFFFFF || *varclipMap_tPtr == (clipMap_t*)0xFFFFFFFE)
		{
			*varclipMap_tPtr = AllocLoad_clipMap_t();
			varclipMap_t = *varclipMap_tPtr;
			clipMap_t** insertedPointer = nullptr;
			if (pointer == (clipMap_t*)0xFFFFFFFE)
			{
				insertedPointer = (clipMap_t**)DB_InsertPointer();
			}
			Load_clipMap_t(true);
			Load_clipMap_tAsset(varclipMap_tPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varclipMap_tPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varclipMap_tPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_clipMap_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varclipMap_tPtr, sizeof(clipMap_t*) * count);
	clipMap_t** pointer = varclipMap_tPtr;
	for (int i = 0; i < count; i++)
	{
		varclipMap_tPtr = pointer;
		Load_clipMap_tPtr(false);
		pointer++;
	}
}

void Load_cmodel_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcmodel_t, sizeof(cmodel_t));

	varBounds = &varcmodel_t->bounds;
	Load_Bounds(false);

	varcLeaf_t = &varcmodel_t->leaf;
	Load_cLeaf_t(false);

}

void Load_cmodel_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcmodel_t, sizeof(cmodel_t) * count);
	cmodel_t* pointer = varcmodel_t;
	for (int i = 0; i < count; i++)
	{
		varcmodel_t = pointer;
		Load_cmodel_t(false);
		pointer++;
	}
}

void Load_cmodel_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcmodel_t, sizeof(cmodel_t));
	if (*varcmodel_tPtr != nullptr)
	{
		if (*varcmodel_tPtr == (cmodel_t*)0xFFFFFFFF)
		{
			*varcmodel_tPtr = AllocLoad_cmodel_t();
			varcmodel_t = *varcmodel_tPtr;
			Load_cmodel_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcmodel_tPtr);
		}
	}
}

void Load_cmodel_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcmodel_tPtr, sizeof(cmodel_t*) * count);
	cmodel_t** pointer = varcmodel_tPtr;
	for (int i = 0; i < count; i++)
	{
		varcmodel_tPtr = pointer;
		Load_cmodel_tPtr(false);
		pointer++;
	}
}

void Load_columnInfo_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcolumnInfo_s, sizeof(columnInfo_s));

}

void Load_columnInfo_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcolumnInfo_s, sizeof(columnInfo_s) * count);
	columnInfo_s* pointer = varcolumnInfo_s;
	for (int i = 0; i < count; i++)
	{
		varcolumnInfo_s = pointer;
		Load_columnInfo_s(false);
		pointer++;
	}
}

void Load_columnInfo_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcolumnInfo_s, sizeof(columnInfo_s));
	if (*varcolumnInfo_sPtr != nullptr)
	{
		if (*varcolumnInfo_sPtr == (columnInfo_s*)0xFFFFFFFF)
		{
			*varcolumnInfo_sPtr = AllocLoad_columnInfo_s();
			varcolumnInfo_s = *varcolumnInfo_sPtr;
			Load_columnInfo_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcolumnInfo_sPtr);
		}
	}
}

void Load_columnInfo_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcolumnInfo_sPtr, sizeof(columnInfo_s*) * count);
	columnInfo_s** pointer = varcolumnInfo_sPtr;
	for (int i = 0; i < count; i++)
	{
		varcolumnInfo_sPtr = pointer;
		Load_columnInfo_sPtr(false);
		pointer++;
	}
}

void Load_complex_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcomplex_s, sizeof(complex_s));

}

void Load_complex_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcomplex_s, sizeof(complex_s) * count);
	complex_s* pointer = varcomplex_s;
	for (int i = 0; i < count; i++)
	{
		varcomplex_s = pointer;
		Load_complex_s(false);
		pointer++;
	}
}

void Load_complex_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcomplex_s, sizeof(complex_s));
	if (*varcomplex_sPtr != nullptr)
	{
		if (*varcomplex_sPtr == (complex_s*)0xFFFFFFFF)
		{
			*varcomplex_sPtr = AllocLoad_complex_s();
			varcomplex_s = *varcomplex_sPtr;
			Load_complex_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcomplex_sPtr);
		}
	}
}

void Load_complex_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcomplex_sPtr, sizeof(complex_s*) * count);
	complex_s** pointer = varcomplex_sPtr;
	for (int i = 0; i < count; i++)
	{
		varcomplex_sPtr = pointer;
		Load_complex_sPtr(false);
		pointer++;
	}
}

void Load_cplane_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcplane_s, sizeof(cplane_s));

}

void Load_cplane_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcplane_s, sizeof(cplane_s) * count);
	cplane_s* pointer = varcplane_s;
	for (int i = 0; i < count; i++)
	{
		varcplane_s = pointer;
		Load_cplane_s(false);
		pointer++;
	}
}

void Load_cplane_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varcplane_s, sizeof(cplane_s));
	if (*varcplane_sPtr != nullptr)
	{
		if (*varcplane_sPtr == (cplane_s*)0xFFFFFFFF)
		{
			*varcplane_sPtr = AllocLoad_cplane_s();
			varcplane_s = *varcplane_sPtr;
			Load_cplane_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varcplane_sPtr);
		}
	}
}

void Load_cplane_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varcplane_sPtr, sizeof(cplane_s*) * count);
	cplane_s** pointer = varcplane_sPtr;
	for (int i = 0; i < count; i++)
	{
		varcplane_sPtr = pointer;
		Load_cplane_sPtr(false);
		pointer++;
	}
}

void Load_double(bool atStreamStart)
{
	Load_Stream(atStreamStart, vardouble, sizeof(double));

}

void Load_doubleArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, vardouble, sizeof(double) * count);
	double* pointer = vardouble;
	for (int i = 0; i < count; i++)
	{
		vardouble = pointer;
		Load_double(false);
		pointer++;
	}
}

void Load_doublePtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, vardouble, sizeof(double));
	if (*vardoublePtr != nullptr)
	{
		*vardoublePtr = AllocLoad_double();
		vardouble = *vardoublePtr;
		Load_double(true);
	}
}

void Load_doublePtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, vardoublePtr, sizeof(double*) * count);
	double** pointer = vardoublePtr;
	for (int i = 0; i < count; i++)
	{
		vardoublePtr = pointer;
		Load_doublePtr(false);
		pointer++;
	}
}

void Load_editFieldDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, vareditFieldDef_s, sizeof(editFieldDef_s));

}

void Load_editFieldDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, vareditFieldDef_s, sizeof(editFieldDef_s) * count);
	editFieldDef_s* pointer = vareditFieldDef_s;
	for (int i = 0; i < count; i++)
	{
		vareditFieldDef_s = pointer;
		Load_editFieldDef_s(false);
		pointer++;
	}
}

void Load_editFieldDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, vareditFieldDef_s, sizeof(editFieldDef_s));
	if (*vareditFieldDef_sPtr != nullptr)
	{
		if (*vareditFieldDef_sPtr == (editFieldDef_s*)0xFFFFFFFF)
		{
			*vareditFieldDef_sPtr = AllocLoad_editFieldDef_s();
			vareditFieldDef_s = *vareditFieldDef_sPtr;
			Load_editFieldDef_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)vareditFieldDef_sPtr);
		}
	}
}

void Load_editFieldDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, vareditFieldDef_sPtr, sizeof(editFieldDef_s*) * count);
	editFieldDef_s** pointer = vareditFieldDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		vareditFieldDef_sPtr = pointer;
		Load_editFieldDef_sPtr(false);
		pointer++;
	}
}

void Load_entryInternalData(bool atStreamStart)
{
	Load_Stream(atStreamStart, varentryInternalData, sizeof(entryInternalData));

	switch (varexpressionEntry->type)
	{
	case 0:
		varint32 = &varentryInternalData->op;
		Load_int32(atStreamStart);
		break;
	case 1:
		varOperand = &varentryInternalData->operand;
		Load_Operand(atStreamStart);
		break;
	}
}

void Load_entryInternalDataArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varentryInternalData, sizeof(entryInternalData) * count);
	entryInternalData* pointer = varentryInternalData;
	for (int i = 0; i < count; i++)
	{
		varentryInternalData = pointer;
		Load_entryInternalData(false);
		pointer++;
	}
}

void Load_entryInternalDataPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varentryInternalData, sizeof(entryInternalData));
	if (*varentryInternalDataPtr != nullptr)
	{
		if (*varentryInternalDataPtr == (entryInternalData*)0xFFFFFFFF)
		{
			*varentryInternalDataPtr = AllocLoad_entryInternalData();
			varentryInternalData = *varentryInternalDataPtr;
			Load_entryInternalData(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varentryInternalDataPtr);
		}
	}
}

void Load_entryInternalDataPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varentryInternalDataPtr, sizeof(entryInternalData*) * count);
	entryInternalData** pointer = varentryInternalDataPtr;
	for (int i = 0; i < count; i++)
	{
		varentryInternalDataPtr = pointer;
		Load_entryInternalDataPtr(false);
		pointer++;
	}
}

void Load_expressionEntry(bool atStreamStart)
{
	Load_Stream(atStreamStart, varexpressionEntry, sizeof(expressionEntry));

	varentryInternalData = &varexpressionEntry->data;
	Load_entryInternalData(false);

}

void Load_expressionEntryArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varexpressionEntry, sizeof(expressionEntry) * count);
	expressionEntry* pointer = varexpressionEntry;
	for (int i = 0; i < count; i++)
	{
		varexpressionEntry = pointer;
		Load_expressionEntry(false);
		pointer++;
	}
}

void Load_expressionEntryPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varexpressionEntry, sizeof(expressionEntry));
	if (*varexpressionEntryPtr != nullptr)
	{
		if (*varexpressionEntryPtr == (expressionEntry*)0xFFFFFFFF)
		{
			*varexpressionEntryPtr = AllocLoad_expressionEntry();
			varexpressionEntry = *varexpressionEntryPtr;
			Load_expressionEntry(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varexpressionEntryPtr);
		}
	}
}

void Load_expressionEntryPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varexpressionEntryPtr, sizeof(expressionEntry*) * count);
	expressionEntry** pointer = varexpressionEntryPtr;
	for (int i = 0; i < count; i++)
	{
		varexpressionEntryPtr = pointer;
		Load_expressionEntryPtr(false);
		pointer++;
	}
}

void Load_float(bool atStreamStart)
{
	Load_Stream(atStreamStart, varfloat, sizeof(float));

}

void Load_float16(bool atStreamStart)
{
	Load_Stream(atStreamStart, varfloat16, sizeof(float16));

}

void Load_float16Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varfloat16, sizeof(float16) * count);
	float16* pointer = varfloat16;
	for (int i = 0; i < count; i++)
	{
		varfloat16 = pointer;
		Load_float16(false);
		pointer++;
	}
}

void Load_float16Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varfloat16, sizeof(float16));
	if (*varfloat16Ptr != nullptr)
	{
		*varfloat16Ptr = AllocLoad_float16();
		varfloat16 = *varfloat16Ptr;
		Load_float16(true);
	}
}

void Load_float16PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varfloat16Ptr, sizeof(float16*) * count);
	float16** pointer = varfloat16Ptr;
	for (int i = 0; i < count; i++)
	{
		varfloat16Ptr = pointer;
		Load_float16Ptr(false);
		pointer++;
	}
}

void Load_floatArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varfloat, sizeof(float) * count);
	float* pointer = varfloat;
	for (int i = 0; i < count; i++)
	{
		varfloat = pointer;
		Load_float(false);
		pointer++;
	}
}

void Load_floatPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varfloat, sizeof(float));
	if (*varfloatPtr != nullptr)
	{
		*varfloatPtr = AllocLoad_float();
		varfloat = *varfloatPtr;
		Load_float(true);
	}
}

void Load_floatPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varfloatPtr, sizeof(float*) * count);
	float** pointer = varfloatPtr;
	for (int i = 0; i < count; i++)
	{
		varfloatPtr = pointer;
		Load_floatPtr(false);
		pointer++;
	}
}

void Load_int16(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint16, sizeof(int16));

}

void Load_int16Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint16, sizeof(int16) * count);
	int16* pointer = varint16;
	for (int i = 0; i < count; i++)
	{
		varint16 = pointer;
		Load_int16(false);
		pointer++;
	}
}

void Load_int16Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint16, sizeof(int16));
	if (*varint16Ptr != nullptr)
	{
		*varint16Ptr = AllocLoad_int16();
		varint16 = *varint16Ptr;
		Load_int16(true);
	}
}

void Load_int16PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint16Ptr, sizeof(int16*) * count);
	int16** pointer = varint16Ptr;
	for (int i = 0; i < count; i++)
	{
		varint16Ptr = pointer;
		Load_int16Ptr(false);
		pointer++;
	}
}

void Load_int32(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint32, sizeof(int32));

}

void Load_int32Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint32, sizeof(int32) * count);
	int32* pointer = varint32;
	for (int i = 0; i < count; i++)
	{
		varint32 = pointer;
		Load_int32(false);
		pointer++;
	}
}

void Load_int32Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint32, sizeof(int32));
	if (*varint32Ptr != nullptr)
	{
		*varint32Ptr = AllocLoad_int32();
		varint32 = *varint32Ptr;
		Load_int32(true);
	}
}

void Load_int32PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint32Ptr, sizeof(int32*) * count);
	int32** pointer = varint32Ptr;
	for (int i = 0; i < count; i++)
	{
		varint32Ptr = pointer;
		Load_int32Ptr(false);
		pointer++;
	}
}

void Load_int64(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint64, sizeof(int64));

}

void Load_int64Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint64, sizeof(int64) * count);
	int64* pointer = varint64;
	for (int i = 0; i < count; i++)
	{
		varint64 = pointer;
		Load_int64(false);
		pointer++;
	}
}

void Load_int64Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint64, sizeof(int64));
	if (*varint64Ptr != nullptr)
	{
		*varint64Ptr = AllocLoad_int64();
		varint64 = *varint64Ptr;
		Load_int64(true);
	}
}

void Load_int64PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint64Ptr, sizeof(int64*) * count);
	int64** pointer = varint64Ptr;
	for (int i = 0; i < count; i++)
	{
		varint64Ptr = pointer;
		Load_int64Ptr(false);
		pointer++;
	}
}

void Load_int8(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint8, sizeof(int8));

}

void Load_int8Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint8, sizeof(int8) * count);
	int8* pointer = varint8;
	for (int i = 0; i < count; i++)
	{
		varint8 = pointer;
		Load_int8(false);
		pointer++;
	}
}

void Load_int8Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varint8, sizeof(int8));
	if (*varint8Ptr != nullptr)
	{
		*varint8Ptr = AllocLoad_int8();
		varint8 = *varint8Ptr;
		Load_int8(true);
	}
}

void Load_int8PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varint8Ptr, sizeof(int8*) * count);
	int8** pointer = varint8Ptr;
	for (int i = 0; i < count; i++)
	{
		varint8Ptr = pointer;
		Load_int8Ptr(false);
		pointer++;
	}
}

void Load_itemDefData_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varitemDefData_t, sizeof(itemDefData_t));

	switch (varitemDef_s->type)
	{
	case 6:
		varlistBoxDef_sPtr = &varitemDefData_t->listBox;
		Load_listBoxDef_sPtr(false);
		break;
	case 0:
	case 4:
	case 9:
	case 10:
	case 11:
	case 14:
	case 16:
	case 17:
	case 18:
	case 22:
	case 23:
		vareditFieldDef_sPtr = &varitemDefData_t->editField;
		Load_editFieldDef_sPtr(false);
		break;
	case 12:
		varmultiDef_sPtr = &varitemDefData_t->multi;
		Load_multiDef_sPtr(false);
		break;
	case 13:
		varXString = &varitemDefData_t->enumDvarName;
		Load_XString(atStreamStart);
		break;
	case 20:
		varnewsTickerDef_sPtr = &varitemDefData_t->ticker;
		Load_newsTickerDef_sPtr(false);
		break;
	case 21:
		vartextScrollDef_sPtr = &varitemDefData_t->scroll;
		Load_textScrollDef_sPtr(false);
		break;
	}
}

void Load_itemDefData_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varitemDefData_t, sizeof(itemDefData_t) * count);
	itemDefData_t* pointer = varitemDefData_t;
	for (int i = 0; i < count; i++)
	{
		varitemDefData_t = pointer;
		Load_itemDefData_t(false);
		pointer++;
	}
}

void Load_itemDefData_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varitemDefData_t, sizeof(itemDefData_t));
	if (*varitemDefData_tPtr != nullptr)
	{
		if (*varitemDefData_tPtr == (itemDefData_t*)0xFFFFFFFF)
		{
			*varitemDefData_tPtr = AllocLoad_itemDefData_t();
			varitemDefData_t = *varitemDefData_tPtr;
			Load_itemDefData_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varitemDefData_tPtr);
		}
	}
}

void Load_itemDefData_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varitemDefData_tPtr, sizeof(itemDefData_t*) * count);
	itemDefData_t** pointer = varitemDefData_tPtr;
	for (int i = 0; i < count; i++)
	{
		varitemDefData_tPtr = pointer;
		Load_itemDefData_tPtr(false);
		pointer++;
	}
}

void Load_itemDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varitemDef_s, sizeof(itemDef_s));

	varwindowDef_t = &varitemDef_s->window;
	Load_windowDef_t(false);

	varrectDef_s = varitemDef_s->textRect;
	Load_rectDef_sArray(false, 1);

	varXString = &varitemDef_s->text;
	Load_XString(false);

	if (varitemDef_s->mouseEnterText)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->mouseEnterText;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->mouseExitText)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->mouseExitText;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->mouseEnter)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->mouseEnter;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->mouseExit)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->mouseExit;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->action)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->action;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->accept)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->accept;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->onFocus)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->onFocus;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varitemDef_s->leaveFocus)
	{
		varMenuEventHandlerSetPtr = &varitemDef_s->leaveFocus;
		Load_MenuEventHandlerSetPtr(false);
	}

	varXString = &varitemDef_s->dvar;
	Load_XString(false);

	varXString = &varitemDef_s->dvarTest;
	Load_XString(false);

	if (varitemDef_s->onKey)
	{
		varItemKeyHandlerPtr = &varitemDef_s->onKey;
		Load_ItemKeyHandlerPtr(false);
	}

	varXString = &varitemDef_s->enableDvar;
	Load_XString(false);

	varXString = &varitemDef_s->localVar;
	Load_XString(false);

	varsnd_alias_list_tPtr = &varitemDef_s->focusSound;
	Load_snd_alias_list_tPtr(false);

	varitemDefData_t = &varitemDef_s->typeData;
	Load_itemDefData_t(false);

	if (varitemDef_s->floatExpressions)
	{
		if (varitemDef_s->floatExpressions == (ItemFloatExpression*)0xFFFFFFFF)
		{
			varitemDef_s->floatExpressions = AllocLoad_ItemFloatExpression();
			varItemFloatExpression = varitemDef_s->floatExpressions;
			Load_ItemFloatExpressionArray(true, (varitemDef_s->floatExpressionCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varitemDef_s->floatExpressions);
		}
	}

	if (varitemDef_s->visibleExp)
	{
		varStatement_sPtr = &varitemDef_s->visibleExp;
		Load_Statement_sPtr(false);
	}

	if (varitemDef_s->disabledExp)
	{
		varStatement_sPtr = &varitemDef_s->disabledExp;
		Load_Statement_sPtr(false);
	}

	if (varitemDef_s->textExp)
	{
		varStatement_sPtr = &varitemDef_s->textExp;
		Load_Statement_sPtr(false);
	}

	if (varitemDef_s->materialExp)
	{
		varStatement_sPtr = &varitemDef_s->materialExp;
		Load_Statement_sPtr(false);
	}

}

void Load_itemDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varitemDef_s, sizeof(itemDef_s) * count);
	itemDef_s* pointer = varitemDef_s;
	for (int i = 0; i < count; i++)
	{
		varitemDef_s = pointer;
		Load_itemDef_s(false);
		pointer++;
	}
}

void Load_itemDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varitemDef_s, sizeof(itemDef_s));
	if (*varitemDef_sPtr != nullptr)
	{
		if (*varitemDef_sPtr == (itemDef_s*)0xFFFFFFFF)
		{
			*varitemDef_sPtr = AllocLoad_itemDef_s();
			varitemDef_s = *varitemDef_sPtr;
			Load_itemDef_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varitemDef_sPtr);
		}
	}
}

void Load_itemDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varitemDef_sPtr, sizeof(itemDef_s*) * count);
	itemDef_s** pointer = varitemDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		varitemDef_sPtr = pointer;
		Load_itemDef_sPtr(false);
		pointer++;
	}
}

void Load_listBoxDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varlistBoxDef_s, sizeof(listBoxDef_s));

	varcolumnInfo_s = varlistBoxDef_s->columnInfo;
	Load_columnInfo_sArray(false, 16);

	if (varlistBoxDef_s->onDoubleClick)
	{
		varMenuEventHandlerSetPtr = &varlistBoxDef_s->onDoubleClick;
		Load_MenuEventHandlerSetPtr(false);
	}

	varMaterialPtr = &varlistBoxDef_s->selectIcon;
	Load_MaterialPtr(false);

}

void Load_listBoxDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varlistBoxDef_s, sizeof(listBoxDef_s) * count);
	listBoxDef_s* pointer = varlistBoxDef_s;
	for (int i = 0; i < count; i++)
	{
		varlistBoxDef_s = pointer;
		Load_listBoxDef_s(false);
		pointer++;
	}
}

void Load_listBoxDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varlistBoxDef_s, sizeof(listBoxDef_s));
	if (*varlistBoxDef_sPtr != nullptr)
	{
		if (*varlistBoxDef_sPtr == (listBoxDef_s*)0xFFFFFFFF)
		{
			*varlistBoxDef_sPtr = AllocLoad_listBoxDef_s();
			varlistBoxDef_s = *varlistBoxDef_sPtr;
			Load_listBoxDef_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varlistBoxDef_sPtr);
		}
	}
}

void Load_listBoxDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varlistBoxDef_sPtr, sizeof(listBoxDef_s*) * count);
	listBoxDef_s** pointer = varlistBoxDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		varlistBoxDef_sPtr = pointer;
		Load_listBoxDef_sPtr(false);
		pointer++;
	}
}

void Load_menuDef_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varmenuDef_t, sizeof(menuDef_t));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	if (varmenuDef_t->expressionData)
	{
		varExpressionSupportingDataPtr = &varmenuDef_t->expressionData;
		Load_ExpressionSupportingDataPtr(false);
	}

	varwindowDef_t = &varmenuDef_t->window;
	Load_windowDef_t(false);

	varXString = &varmenuDef_t->font;
	Load_XString(false);

	if (varmenuDef_t->onOpen)
	{
		varMenuEventHandlerSetPtr = &varmenuDef_t->onOpen;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varmenuDef_t->onClose)
	{
		varMenuEventHandlerSetPtr = &varmenuDef_t->onClose;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varmenuDef_t->onCloseRequest)
	{
		varMenuEventHandlerSetPtr = &varmenuDef_t->onCloseRequest;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varmenuDef_t->onESC)
	{
		varMenuEventHandlerSetPtr = &varmenuDef_t->onESC;
		Load_MenuEventHandlerSetPtr(false);
	}

	if (varmenuDef_t->onKey)
	{
		varItemKeyHandlerPtr = &varmenuDef_t->onKey;
		Load_ItemKeyHandlerPtr(false);
	}

	if (varmenuDef_t->visibleExp)
	{
		varStatement_sPtr = &varmenuDef_t->visibleExp;
		Load_Statement_sPtr(false);
	}

	varXString = &varmenuDef_t->allowedBinding;
	Load_XString(false);

	varXString = &varmenuDef_t->soundName;
	Load_XString(false);

	if (varmenuDef_t->rectXExp)
	{
		varStatement_sPtr = &varmenuDef_t->rectXExp;
		Load_Statement_sPtr(false);
	}

	if (varmenuDef_t->rectYExp)
	{
		varStatement_sPtr = &varmenuDef_t->rectYExp;
		Load_Statement_sPtr(false);
	}

	if (varmenuDef_t->rectWExp)
	{
		varStatement_sPtr = &varmenuDef_t->rectWExp;
		Load_Statement_sPtr(false);
	}

	if (varmenuDef_t->rectHExp)
	{
		varStatement_sPtr = &varmenuDef_t->rectHExp;
		Load_Statement_sPtr(false);
	}

	if (varmenuDef_t->openSoundExp)
	{
		varStatement_sPtr = &varmenuDef_t->openSoundExp;
		Load_Statement_sPtr(false);
	}

	if (varmenuDef_t->closeSoundExp)
	{
		varStatement_sPtr = &varmenuDef_t->closeSoundExp;
		Load_Statement_sPtr(false);
	}

	if (varmenuDef_t->items)
	{
		if (varmenuDef_t->items == (itemDef_s**)0xFFFFFFFF)
		{
			varmenuDef_t->items = AllocLoad_itemDef_sPtr();
			varitemDef_sPtr = varmenuDef_t->items;
			Load_itemDef_sPtrArray(true, (varmenuDef_t->itemCount));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varmenuDef_t->items);
		}
	}

	varmenuTransition = varmenuDef_t->scaleTransition;
	Load_menuTransitionArray(false, 1);

	varmenuTransition = varmenuDef_t->alphaTransition;
	Load_menuTransitionArray(false, 1);

	varmenuTransition = varmenuDef_t->xTransition;
	Load_menuTransitionArray(false, 1);

	varmenuTransition = varmenuDef_t->yTransition;
	Load_menuTransitionArray(false, 1);

	DB_PopStreamPos();
}

void Load_menuDef_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varmenuDef_t, sizeof(menuDef_t) * count);
	menuDef_t* pointer = varmenuDef_t;
	for (int i = 0; i < count; i++)
	{
		varmenuDef_t = pointer;
		Load_menuDef_t(false);
		pointer++;
	}
}

void Load_menuDef_tAsset(menuDef_t** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_MENU, (void**)varmenuDef_tPtr);
}

void Load_menuDef_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varmenuDef_t, sizeof(menuDef_t*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	menuDef_t* pointer = *varmenuDef_tPtr;
	if (*varmenuDef_tPtr != nullptr)
	{
		if (*varmenuDef_tPtr == (menuDef_t*)0xFFFFFFFF || *varmenuDef_tPtr == (menuDef_t*)0xFFFFFFFE)
		{
			*varmenuDef_tPtr = AllocLoad_menuDef_t();
			varmenuDef_t = *varmenuDef_tPtr;
			menuDef_t** insertedPointer = nullptr;
			if (pointer == (menuDef_t*)0xFFFFFFFE)
			{
				insertedPointer = (menuDef_t**)DB_InsertPointer();
			}
			Load_menuDef_t(true);
			Load_menuDef_tAsset(varmenuDef_tPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varmenuDef_tPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varmenuDef_tPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_menuDef_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varmenuDef_tPtr, sizeof(menuDef_t*) * count);
	menuDef_t** pointer = varmenuDef_tPtr;
	for (int i = 0; i < count; i++)
	{
		varmenuDef_tPtr = pointer;
		Load_menuDef_tPtr(false);
		pointer++;
	}
}

void Load_menuTransition(bool atStreamStart)
{
	Load_Stream(atStreamStart, varmenuTransition, sizeof(menuTransition));

}

void Load_menuTransitionArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varmenuTransition, sizeof(menuTransition) * count);
	menuTransition* pointer = varmenuTransition;
	for (int i = 0; i < count; i++)
	{
		varmenuTransition = pointer;
		Load_menuTransition(false);
		pointer++;
	}
}

void Load_menuTransitionPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varmenuTransition, sizeof(menuTransition));
	if (*varmenuTransitionPtr != nullptr)
	{
		if (*varmenuTransitionPtr == (menuTransition*)0xFFFFFFFF)
		{
			*varmenuTransitionPtr = AllocLoad_menuTransition();
			varmenuTransition = *varmenuTransitionPtr;
			Load_menuTransition(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varmenuTransitionPtr);
		}
	}
}

void Load_menuTransitionPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varmenuTransitionPtr, sizeof(menuTransition*) * count);
	menuTransition** pointer = varmenuTransitionPtr;
	for (int i = 0; i < count; i++)
	{
		varmenuTransitionPtr = pointer;
		Load_menuTransitionPtr(false);
		pointer++;
	}
}

void Load_multiDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varmultiDef_s, sizeof(multiDef_s));

	varXString = varmultiDef_s->dvarList;
	Load_XStringArray(false, 32);

	varXString = varmultiDef_s->dvarStr;
	Load_XStringArray(false, 32);

}

void Load_multiDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varmultiDef_s, sizeof(multiDef_s) * count);
	multiDef_s* pointer = varmultiDef_s;
	for (int i = 0; i < count; i++)
	{
		varmultiDef_s = pointer;
		Load_multiDef_s(false);
		pointer++;
	}
}

void Load_multiDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varmultiDef_s, sizeof(multiDef_s));
	if (*varmultiDef_sPtr != nullptr)
	{
		if (*varmultiDef_sPtr == (multiDef_s*)0xFFFFFFFF)
		{
			*varmultiDef_sPtr = AllocLoad_multiDef_s();
			varmultiDef_s = *varmultiDef_sPtr;
			Load_multiDef_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varmultiDef_sPtr);
		}
	}
}

void Load_multiDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varmultiDef_sPtr, sizeof(multiDef_s*) * count);
	multiDef_s** pointer = varmultiDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		varmultiDef_sPtr = pointer;
		Load_multiDef_sPtr(false);
		pointer++;
	}
}

void Load_newsTickerDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varnewsTickerDef_s, sizeof(newsTickerDef_s));

}

void Load_newsTickerDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varnewsTickerDef_s, sizeof(newsTickerDef_s) * count);
	newsTickerDef_s* pointer = varnewsTickerDef_s;
	for (int i = 0; i < count; i++)
	{
		varnewsTickerDef_s = pointer;
		Load_newsTickerDef_s(false);
		pointer++;
	}
}

void Load_newsTickerDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varnewsTickerDef_s, sizeof(newsTickerDef_s));
	if (*varnewsTickerDef_sPtr != nullptr)
	{
		if (*varnewsTickerDef_sPtr == (newsTickerDef_s*)0xFFFFFFFF)
		{
			*varnewsTickerDef_sPtr = AllocLoad_newsTickerDef_s();
			varnewsTickerDef_s = *varnewsTickerDef_sPtr;
			Load_newsTickerDef_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varnewsTickerDef_sPtr);
		}
	}
}

void Load_newsTickerDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varnewsTickerDef_sPtr, sizeof(newsTickerDef_s*) * count);
	newsTickerDef_s** pointer = varnewsTickerDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		varnewsTickerDef_sPtr = pointer;
		Load_newsTickerDef_sPtr(false);
		pointer++;
	}
}

void Load_operandInternalDataUnion(bool atStreamStart)
{
	Load_Stream(atStreamStart, varoperandInternalDataUnion, sizeof(operandInternalDataUnion));

	switch (varOperand->dataType)
	{
	case 0:
		varint32 = &varoperandInternalDataUnion->intVal;
		Load_int32(atStreamStart);
		break;
	case 1:
		varfloat = &varoperandInternalDataUnion->floatVal;
		Load_float(atStreamStart);
		break;
	case 2:
		varExpressionString = &varoperandInternalDataUnion->stringVal;
		Load_ExpressionString(atStreamStart);
		break;
	case 3:
		varStatement_sPtr = &varoperandInternalDataUnion->function;
		Load_Statement_sPtr(false);
		break;
	}
}

void Load_operandInternalDataUnionArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varoperandInternalDataUnion, sizeof(operandInternalDataUnion) * count);
	operandInternalDataUnion* pointer = varoperandInternalDataUnion;
	for (int i = 0; i < count; i++)
	{
		varoperandInternalDataUnion = pointer;
		Load_operandInternalDataUnion(false);
		pointer++;
	}
}

void Load_operandInternalDataUnionPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varoperandInternalDataUnion, sizeof(operandInternalDataUnion));
	if (*varoperandInternalDataUnionPtr != nullptr)
	{
		if (*varoperandInternalDataUnionPtr == (operandInternalDataUnion*)0xFFFFFFFF)
		{
			*varoperandInternalDataUnionPtr = AllocLoad_operandInternalDataUnion();
			varoperandInternalDataUnion = *varoperandInternalDataUnionPtr;
			Load_operandInternalDataUnion(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varoperandInternalDataUnionPtr);
		}
	}
}

void Load_operandInternalDataUnionPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varoperandInternalDataUnionPtr, sizeof(operandInternalDataUnion*) * count);
	operandInternalDataUnion** pointer = varoperandInternalDataUnionPtr;
	for (int i = 0; i < count; i++)
	{
		varoperandInternalDataUnionPtr = pointer;
		Load_operandInternalDataUnionPtr(false);
		pointer++;
	}
}

void Load_rectDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, varrectDef_s, sizeof(rectDef_s));

}

void Load_rectDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varrectDef_s, sizeof(rectDef_s) * count);
	rectDef_s* pointer = varrectDef_s;
	for (int i = 0; i < count; i++)
	{
		varrectDef_s = pointer;
		Load_rectDef_s(false);
		pointer++;
	}
}

void Load_rectDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varrectDef_s, sizeof(rectDef_s));
	if (*varrectDef_sPtr != nullptr)
	{
		if (*varrectDef_sPtr == (rectDef_s*)0xFFFFFFFF)
		{
			*varrectDef_sPtr = AllocLoad_rectDef_s();
			varrectDef_s = *varrectDef_sPtr;
			Load_rectDef_s(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varrectDef_sPtr);
		}
	}
}

void Load_rectDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varrectDef_sPtr, sizeof(rectDef_s*) * count);
	rectDef_s** pointer = varrectDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		varrectDef_sPtr = pointer;
		Load_rectDef_sPtr(false);
		pointer++;
	}
}

void Load_snd_alias_list_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varsnd_alias_list_t, sizeof(snd_alias_list_t));
	DB_PushStreamPos(XFILE_BLOCK_VIRTUAL);

	varXString = &varsnd_alias_list_t->aliasName;
	Load_XString(false);

	if (varsnd_alias_list_t->head)
	{
		if (varsnd_alias_list_t->head == (snd_alias_t*)0xFFFFFFFF)
		{
			varsnd_alias_list_t->head = AllocLoad_snd_alias_t();
			varsnd_alias_t = varsnd_alias_list_t->head;
			Load_snd_alias_tArray(true, (varsnd_alias_list_t->count));
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)&varsnd_alias_list_t->head);
		}
	}

	DB_PopStreamPos();
}

void Load_snd_alias_list_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varsnd_alias_list_t, sizeof(snd_alias_list_t) * count);
	snd_alias_list_t* pointer = varsnd_alias_list_t;
	for (int i = 0; i < count; i++)
	{
		varsnd_alias_list_t = pointer;
		Load_snd_alias_list_t(false);
		pointer++;
	}
}

void Load_snd_alias_list_tAsset(snd_alias_list_t** asset)
{
	DB_AddXAsset(XAssetType::ASSET_TYPE_SOUND, (void**)varsnd_alias_list_tPtr);
}

void Load_snd_alias_list_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varsnd_alias_list_t, sizeof(snd_alias_list_t*));
	DB_PushStreamPos(XFILE_BLOCK_TEMP);
	snd_alias_list_t* pointer = *varsnd_alias_list_tPtr;
	if (*varsnd_alias_list_tPtr != nullptr)
	{
		if (*varsnd_alias_list_tPtr == (snd_alias_list_t*)0xFFFFFFFF || *varsnd_alias_list_tPtr == (snd_alias_list_t*)0xFFFFFFFE)
		{
			*varsnd_alias_list_tPtr = AllocLoad_snd_alias_list_t();
			varsnd_alias_list_t = *varsnd_alias_list_tPtr;
			snd_alias_list_t** insertedPointer = nullptr;
			if (pointer == (snd_alias_list_t*)0xFFFFFFFE)
			{
				insertedPointer = (snd_alias_list_t**)DB_InsertPointer();
			}
			Load_snd_alias_list_t(true);
			Load_snd_alias_list_tAsset(varsnd_alias_list_tPtr);
			if (insertedPointer != nullptr)
			{
				*insertedPointer = *varsnd_alias_list_tPtr;
			}
		}
		else
		{
			DB_ConvertOffsetToAlias((void**)varsnd_alias_list_tPtr);
		}
	}
	DB_PopStreamPos();
}

void Load_snd_alias_list_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varsnd_alias_list_tPtr, sizeof(snd_alias_list_t*) * count);
	snd_alias_list_t** pointer = varsnd_alias_list_tPtr;
	for (int i = 0; i < count; i++)
	{
		varsnd_alias_list_tPtr = pointer;
		Load_snd_alias_list_tPtr(false);
		pointer++;
	}
}

void Load_snd_alias_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varsnd_alias_t, sizeof(snd_alias_t));

	varXString = &varsnd_alias_t->aliasName;
	Load_XString(false);

	varXString = &varsnd_alias_t->subtitle;
	Load_XString(false);

	varXString = &varsnd_alias_t->secondaryAliasName;
	Load_XString(false);

	varXString = &varsnd_alias_t->chainAliasName;
	Load_XString(false);

	varXString = &varsnd_alias_t->mixerGroup;
	Load_XString(false);

	if (varsnd_alias_t->soundFile)
	{
		varSoundFilePtr = &varsnd_alias_t->soundFile;
		Load_SoundFilePtr(false);
	}

	var$C8D87EB0090687D323381DFB7A82089C = &varsnd_alias_t->___u15;
	Load_$C8D87EB0090687D323381DFB7A82089C(false);

	varSndCurvePtr = &varsnd_alias_t->volumeFalloffCurve;
	Load_SndCurvePtr(false);

	if (varsnd_alias_t->speakerMap)
	{
		varSpeakerMapPtr = &varsnd_alias_t->speakerMap;
		Load_SpeakerMapPtr(false);
	}

}

void Load_snd_alias_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varsnd_alias_t, sizeof(snd_alias_t) * count);
	snd_alias_t* pointer = varsnd_alias_t;
	for (int i = 0; i < count; i++)
	{
		varsnd_alias_t = pointer;
		Load_snd_alias_t(false);
		pointer++;
	}
}

void Load_snd_alias_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varsnd_alias_t, sizeof(snd_alias_t));
	if (*varsnd_alias_tPtr != nullptr)
	{
		if (*varsnd_alias_tPtr == (snd_alias_t*)0xFFFFFFFF)
		{
			*varsnd_alias_tPtr = AllocLoad_snd_alias_t();
			varsnd_alias_t = *varsnd_alias_tPtr;
			Load_snd_alias_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varsnd_alias_tPtr);
		}
	}
}

void Load_snd_alias_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varsnd_alias_tPtr, sizeof(snd_alias_t*) * count);
	snd_alias_t** pointer = varsnd_alias_tPtr;
	for (int i = 0; i < count; i++)
	{
		varsnd_alias_tPtr = pointer;
		Load_snd_alias_tPtr(false);
		pointer++;
	}
}

void Load_textScrollDef_s(bool atStreamStart)
{
	Load_Stream(atStreamStart, vartextScrollDef_s, sizeof(textScrollDef_s));

}

void Load_textScrollDef_sArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, vartextScrollDef_s, sizeof(textScrollDef_s) * count);
	textScrollDef_s* pointer = vartextScrollDef_s;
	for (int i = 0; i < count; i++)
	{
		vartextScrollDef_s = pointer;
		Load_textScrollDef_s(false);
		pointer++;
	}
}

void Load_textScrollDef_sPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, vartextScrollDef_s, sizeof(textScrollDef_s));
	if (*vartextScrollDef_sPtr != nullptr)
	{
		*vartextScrollDef_sPtr = AllocLoad_textScrollDef_s();
		vartextScrollDef_s = *vartextScrollDef_sPtr;
		Load_textScrollDef_s(true);
	}
}

void Load_textScrollDef_sPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, vartextScrollDef_sPtr, sizeof(textScrollDef_s*) * count);
	textScrollDef_s** pointer = vartextScrollDef_sPtr;
	for (int i = 0; i < count; i++)
	{
		vartextScrollDef_sPtr = pointer;
		Load_textScrollDef_sPtr(false);
		pointer++;
	}
}

void Load_uint16(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint16, sizeof(uint16));

}

void Load_uint16Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint16, sizeof(uint16) * count);
	uint16* pointer = varuint16;
	for (int i = 0; i < count; i++)
	{
		varuint16 = pointer;
		Load_uint16(false);
		pointer++;
	}
}

void Load_uint16Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint16, sizeof(uint16));
	if (*varuint16Ptr != nullptr)
	{
		*varuint16Ptr = AllocLoad_uint16();
		varuint16 = *varuint16Ptr;
		Load_uint16(true);
	}
}

void Load_uint16PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint16Ptr, sizeof(uint16*) * count);
	uint16** pointer = varuint16Ptr;
	for (int i = 0; i < count; i++)
	{
		varuint16Ptr = pointer;
		Load_uint16Ptr(false);
		pointer++;
	}
}

void Load_uint32(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint32, sizeof(uint32));

}

void Load_uint32Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint32, sizeof(uint32) * count);
	uint32* pointer = varuint32;
	for (int i = 0; i < count; i++)
	{
		varuint32 = pointer;
		Load_uint32(false);
		pointer++;
	}
}

void Load_uint32Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint32, sizeof(uint32));
	if (*varuint32Ptr != nullptr)
	{
		*varuint32Ptr = AllocLoad_uint32();
		varuint32 = *varuint32Ptr;
		Load_uint32(true);
	}
}

void Load_uint32PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint32Ptr, sizeof(uint32*) * count);
	uint32** pointer = varuint32Ptr;
	for (int i = 0; i < count; i++)
	{
		varuint32Ptr = pointer;
		Load_uint32Ptr(false);
		pointer++;
	}
}

void Load_uint64(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint64, sizeof(uint64));

}

void Load_uint64Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint64, sizeof(uint64) * count);
	uint64* pointer = varuint64;
	for (int i = 0; i < count; i++)
	{
		varuint64 = pointer;
		Load_uint64(false);
		pointer++;
	}
}

void Load_uint64Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint64, sizeof(uint64));
	if (*varuint64Ptr != nullptr)
	{
		*varuint64Ptr = AllocLoad_uint64();
		varuint64 = *varuint64Ptr;
		Load_uint64(true);
	}
}

void Load_uint64PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint64Ptr, sizeof(uint64*) * count);
	uint64** pointer = varuint64Ptr;
	for (int i = 0; i < count; i++)
	{
		varuint64Ptr = pointer;
		Load_uint64Ptr(false);
		pointer++;
	}
}

void Load_uint8(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint8, sizeof(uint8));

}

void Load_uint8Array(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint8, sizeof(uint8) * count);
	uint8* pointer = varuint8;
	for (int i = 0; i < count; i++)
	{
		varuint8 = pointer;
		Load_uint8(false);
		pointer++;
	}
}

void Load_uint8Ptr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varuint8, sizeof(uint8));
	if (*varuint8Ptr != nullptr)
	{
		*varuint8Ptr = AllocLoad_uint8();
		varuint8 = *varuint8Ptr;
		Load_uint8(true);
	}
}

void Load_uint8PtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varuint8Ptr, sizeof(uint8*) * count);
	uint8** pointer = varuint8Ptr;
	for (int i = 0; i < count; i++)
	{
		varuint8Ptr = pointer;
		Load_uint8Ptr(false);
		pointer++;
	}
}

void Load_vec1_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec1_t, sizeof(vec1_t));

}

void Load_vec1_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec1_t, sizeof(vec1_t) * count);
	vec1_t* pointer = varvec1_t;
	for (int i = 0; i < count; i++)
	{
		varvec1_t = pointer;
		Load_vec1_t(false);
		pointer++;
	}
}

void Load_vec1_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec1_t, sizeof(vec1_t));
	if (*varvec1_tPtr != nullptr)
	{
		*varvec1_tPtr = AllocLoad_vec1_t();
		varvec1_t = *varvec1_tPtr;
		Load_vec1_t(true);
	}
}

void Load_vec1_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec1_tPtr, sizeof(vec1_t*) * count);
	vec1_t** pointer = varvec1_tPtr;
	for (int i = 0; i < count; i++)
	{
		varvec1_tPtr = pointer;
		Load_vec1_tPtr(false);
		pointer++;
	}
}

void Load_vec2_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec2_t, sizeof(vec2_t));

}

void Load_vec2_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec2_t, sizeof(vec2_t) * count);
	vec2_t* pointer = varvec2_t;
	for (int i = 0; i < count; i++)
	{
		varvec2_t = pointer;
		Load_vec2_t(false);
		pointer++;
	}
}

void Load_vec2_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec2_t, sizeof(vec2_t));
	if (*varvec2_tPtr != nullptr)
	{
		*varvec2_tPtr = AllocLoad_vec2_t();
		varvec2_t = *varvec2_tPtr;
		Load_vec2_t(true);
	}
}

void Load_vec2_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec2_tPtr, sizeof(vec2_t*) * count);
	vec2_t** pointer = varvec2_tPtr;
	for (int i = 0; i < count; i++)
	{
		varvec2_tPtr = pointer;
		Load_vec2_tPtr(false);
		pointer++;
	}
}

void Load_vec3_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec3_t, sizeof(vec3_t));

}

void Load_vec3_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec3_t, sizeof(vec3_t) * count);
	vec3_t* pointer = varvec3_t;
	for (int i = 0; i < count; i++)
	{
		varvec3_t = pointer;
		Load_vec3_t(false);
		pointer++;
	}
}

void Load_vec3_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec3_t, sizeof(vec3_t));
	if (*varvec3_tPtr != nullptr)
	{
		*varvec3_tPtr = AllocLoad_vec3_t();
		varvec3_t = *varvec3_tPtr;
		Load_vec3_t(true);
	}
}

void Load_vec3_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec3_tPtr, sizeof(vec3_t*) * count);
	vec3_t** pointer = varvec3_tPtr;
	for (int i = 0; i < count; i++)
	{
		varvec3_tPtr = pointer;
		Load_vec3_tPtr(false);
		pointer++;
	}
}

void Load_vec4_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec4_t, sizeof(vec4_t));

}

void Load_vec4_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec4_t, sizeof(vec4_t) * count);
	vec4_t* pointer = varvec4_t;
	for (int i = 0; i < count; i++)
	{
		varvec4_t = pointer;
		Load_vec4_t(false);
		pointer++;
	}
}

void Load_vec4_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varvec4_t, sizeof(vec4_t));
	if (*varvec4_tPtr != nullptr)
	{
		*varvec4_tPtr = AllocLoad_vec4_t();
		varvec4_t = *varvec4_tPtr;
		Load_vec4_t(true);
	}
}

void Load_vec4_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varvec4_tPtr, sizeof(vec4_t*) * count);
	vec4_t** pointer = varvec4_tPtr;
	for (int i = 0; i < count; i++)
	{
		varvec4_tPtr = pointer;
		Load_vec4_tPtr(false);
		pointer++;
	}
}

void Load_water_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varwater_t, sizeof(water_t));

	varWaterWritable = &varwater_t->writable;
	Load_WaterWritable(false);

	if (varwater_t->H0)
	{
		varcomplex_sPtr = &varwater_t->H0;
		Load_complex_sPtr(false);
	}

	if (varwater_t->wTerm)
	{
		varfloatPtr = &varwater_t->wTerm;
		Load_floatPtr(false);
	}

	varGfxImagePtr = &varwater_t->image;
	Load_GfxImagePtr(false);

}

void Load_water_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varwater_t, sizeof(water_t) * count);
	water_t* pointer = varwater_t;
	for (int i = 0; i < count; i++)
	{
		varwater_t = pointer;
		Load_water_t(false);
		pointer++;
	}
}

void Load_water_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varwater_t, sizeof(water_t));
	if (*varwater_tPtr != nullptr)
	{
		if (*varwater_tPtr == (water_t*)0xFFFFFFFF)
		{
			*varwater_tPtr = AllocLoad_water_t();
			varwater_t = *varwater_tPtr;
			Load_water_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varwater_tPtr);
		}
	}
}

void Load_water_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varwater_tPtr, sizeof(water_t*) * count);
	water_t** pointer = varwater_tPtr;
	for (int i = 0; i < count; i++)
	{
		varwater_tPtr = pointer;
		Load_water_tPtr(false);
		pointer++;
	}
}

void Load_windowDef_t(bool atStreamStart)
{
	Load_Stream(atStreamStart, varwindowDef_t, sizeof(windowDef_t));

	varXString = &varwindowDef_t->name;
	Load_XString(false);

	varrectDef_s = &varwindowDef_t->rect;
	Load_rectDef_s(false);

	varrectDef_s = &varwindowDef_t->rectClient;
	Load_rectDef_s(false);

	varXString = &varwindowDef_t->group;
	Load_XString(false);

	varMaterialPtr = &varwindowDef_t->background;
	Load_MaterialPtr(false);

}

void Load_windowDef_tArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varwindowDef_t, sizeof(windowDef_t) * count);
	windowDef_t* pointer = varwindowDef_t;
	for (int i = 0; i < count; i++)
	{
		varwindowDef_t = pointer;
		Load_windowDef_t(false);
		pointer++;
	}
}

void Load_windowDef_tPtr(bool atStreamStart)
{
	Load_Stream(atStreamStart, varwindowDef_t, sizeof(windowDef_t));
	if (*varwindowDef_tPtr != nullptr)
	{
		if (*varwindowDef_tPtr == (windowDef_t*)0xFFFFFFFF)
		{
			*varwindowDef_tPtr = AllocLoad_windowDef_t();
			varwindowDef_t = *varwindowDef_tPtr;
			Load_windowDef_t(true);
		}
		else
		{
			DB_ConvertOffsetToPointer((void**)varwindowDef_tPtr);
		}
	}
}

void Load_windowDef_tPtrArray(bool atStreamStart, int count)
{
	Load_Stream(atStreamStart, varwindowDef_tPtr, sizeof(windowDef_t*) * count);
	windowDef_t** pointer = varwindowDef_tPtr;
	for (int i = 0; i < count; i++)
	{
		varwindowDef_tPtr = pointer;
		Load_windowDef_tPtr(false);
		pointer++;
	}
}

water_t* AllocLoad_water_t()
{
	return (water_t*)DB_AllocStreamPos(3);
}

water_t** AllocLoad_water_tPtr()
{
	return (water_t**)DB_AllocStreamPos(3);
}

windowDef_t* AllocLoad_windowDef_t()
{
	return (windowDef_t*)DB_AllocStreamPos(3);
}

windowDef_t** AllocLoad_windowDef_tPtr()
{
	return (windowDef_t**)DB_AllocStreamPos(3);
}

const char *(*DB_XAssetGetNameHandler[ASSET_TYPE_COUNT])(XAssetHeader*) = 
{
	DB_PhysPresetGetName,
	DB_PhysCollmapGetName,
	DB_XAnimPartsGetName,
	DB_XModelSurfsGetName,
	DB_XModelGetName,
	DB_MaterialGetName,
	DB_MaterialPixelShaderGetName,
	DB_MaterialVertexShaderGetName,
	DB_MaterialVertexDeclarationGetName,
	DB_MaterialTechniqueSetGetName,
	DB_GfxImageGetName,
	DB_snd_alias_list_tGetName,
	DB_SndCurveGetName,
	nullptr,
	nullptr,
	DB_clipMap_tGetName,
	DB_ComWorldGetName,
	nullptr,
	DB_GameWorldMpGetName,
	DB_MapEntsGetName,
	DB_FxWorldGetName,
	nullptr,
	DB_GfxLightDefGetName,
	nullptr,
	DB_Font_sGetName,
	DB_MenuListGetName,
	DB_menuDef_tGetName,
	DB_LocalizeEntryGetName,
	nullptr,
	nullptr,
	DB_FxEffectDefGetName,
	nullptr,
	nullptr,
	nullptr,
	nullptr,
	nullptr,
	DB_RawFileGetName,
	DB_StringTableGetName,
	DB_LeaderboardDefGetName,
	DB_StructuredDataDefSetGetName,
	DB_TracerDefGetName,
	nullptr,
	nullptr,
};
}
